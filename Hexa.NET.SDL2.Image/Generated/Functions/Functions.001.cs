// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;
using Hexa.NET.SDL2;

namespace Hexa.NET.SDL2.Image
{
	public unsafe partial class SDLImage
	{

		/// <summary>
		/// Load a XV image directly.<br/>
		/// If you know you definitely have a XV image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_RWops<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadXV_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurface* LoadXVRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] SDLRWops* src)
		{
			SDLSurface* ret = LoadXVRWNative(src);
			return ret;
		}

		/// <summary>
		/// Load a XV image directly.<br/>
		/// If you know you definitely have a XV image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_RWops<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadXV_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurface* LoadXVRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] ref SDLRWops src)
		{
			fixed (SDLRWops* psrc = &src)
			{
				SDLSurface* ret = LoadXVRWNative((SDLRWops*)psrc);
				return ret;
			}
		}

		/// <summary>
		/// Load a WEBP image directly.<br/>
		/// If you know you definitely have a WEBP image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_RWops<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadWEBP_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLSurface* LoadWEBPRWNative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] SDLRWops* src)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, SDLSurface*>)funcTable[45])(src);
			#else
			return (SDLSurface*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[45])((nint)src);
			#endif
		}

		/// <summary>
		/// Load a WEBP image directly.<br/>
		/// If you know you definitely have a WEBP image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_RWops<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadWEBP_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurface* LoadWEBPRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] SDLRWops* src)
		{
			SDLSurface* ret = LoadWEBPRWNative(src);
			return ret;
		}

		/// <summary>
		/// Load a WEBP image directly.<br/>
		/// If you know you definitely have a WEBP image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_RWops<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadWEBP_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurface* LoadWEBPRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] ref SDLRWops src)
		{
			fixed (SDLRWops* psrc = &src)
			{
				SDLSurface* ret = LoadWEBPRWNative((SDLRWops*)psrc);
				return ret;
			}
		}

		/// <summary>
		/// Load an SVG image, scaled to a specific size.<br/>
		/// Since SVG files are resolution-independent, you specify the size you would<br/>
		/// like the output image to be and it will be generated at those dimensions.<br/>
		/// Either width or height may be 0 and the image will be auto-sized to<br/>
		/// preserve aspect ratio.<br/>
		/// When done with the returned surface, the app should dispose of it with a<br/>
		/// call to SDL_FreeSurface().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadSizedSVG_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLSurface* LoadSizedSVGRWNative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] SDLRWops* src, [NativeName(NativeNameType.Param, "width")] [NativeName(NativeNameType.Type, "int")] int width, [NativeName(NativeNameType.Param, "height")] [NativeName(NativeNameType.Type, "int")] int height)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, int, int, SDLSurface*>)funcTable[46])(src, width, height);
			#else
			return (SDLSurface*)((delegate* unmanaged[Cdecl]<nint, int, int, nint>)funcTable[46])((nint)src, width, height);
			#endif
		}

		/// <summary>
		/// Load an SVG image, scaled to a specific size.<br/>
		/// Since SVG files are resolution-independent, you specify the size you would<br/>
		/// like the output image to be and it will be generated at those dimensions.<br/>
		/// Either width or height may be 0 and the image will be auto-sized to<br/>
		/// preserve aspect ratio.<br/>
		/// When done with the returned surface, the app should dispose of it with a<br/>
		/// call to SDL_FreeSurface().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadSizedSVG_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurface* LoadSizedSVGRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] SDLRWops* src, [NativeName(NativeNameType.Param, "width")] [NativeName(NativeNameType.Type, "int")] int width, [NativeName(NativeNameType.Param, "height")] [NativeName(NativeNameType.Type, "int")] int height)
		{
			SDLSurface* ret = LoadSizedSVGRWNative(src, width, height);
			return ret;
		}

		/// <summary>
		/// Load an SVG image, scaled to a specific size.<br/>
		/// Since SVG files are resolution-independent, you specify the size you would<br/>
		/// like the output image to be and it will be generated at those dimensions.<br/>
		/// Either width or height may be 0 and the image will be auto-sized to<br/>
		/// preserve aspect ratio.<br/>
		/// When done with the returned surface, the app should dispose of it with a<br/>
		/// call to SDL_FreeSurface().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadSizedSVG_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurface* LoadSizedSVGRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] ref SDLRWops src, [NativeName(NativeNameType.Param, "width")] [NativeName(NativeNameType.Type, "int")] int width, [NativeName(NativeNameType.Param, "height")] [NativeName(NativeNameType.Type, "int")] int height)
		{
			fixed (SDLRWops* psrc = &src)
			{
				SDLSurface* ret = LoadSizedSVGRWNative((SDLRWops*)psrc, width, height);
				return ret;
			}
		}

		/// <summary>
		/// Load an XPM image from a memory array.<br/>
		/// The returned surface will be an 8bpp indexed surface, if possible,<br/>
		/// otherwise it will be 32bpp. If you always want 32-bit data, use<br/>
		/// IMG_ReadXPMFromArrayToRGB888() instead.<br/>
		/// When done with the returned surface, the app should dispose of it with a<br/>
		/// call to SDL_FreeSurface().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_ReadXPMFromArray")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLSurface* ReadXPMFromArrayNative([NativeName(NativeNameType.Param, "xpm")] [NativeName(NativeNameType.Type, "char * *")] byte** xpm)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte**, SDLSurface*>)funcTable[47])(xpm);
			#else
			return (SDLSurface*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[47])((nint)xpm);
			#endif
		}

		/// <summary>
		/// Load an XPM image from a memory array.<br/>
		/// The returned surface will be an 8bpp indexed surface, if possible,<br/>
		/// otherwise it will be 32bpp. If you always want 32-bit data, use<br/>
		/// IMG_ReadXPMFromArrayToRGB888() instead.<br/>
		/// When done with the returned surface, the app should dispose of it with a<br/>
		/// call to SDL_FreeSurface().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_ReadXPMFromArray")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurface* ReadXPMFromArray([NativeName(NativeNameType.Param, "xpm")] [NativeName(NativeNameType.Type, "char * *")] byte** xpm)
		{
			SDLSurface* ret = ReadXPMFromArrayNative(xpm);
			return ret;
		}

		/// <summary>
		/// Load an XPM image from a memory array.<br/>
		/// The returned surface will be an 8bpp indexed surface, if possible,<br/>
		/// otherwise it will be 32bpp. If you always want 32-bit data, use<br/>
		/// IMG_ReadXPMFromArrayToRGB888() instead.<br/>
		/// When done with the returned surface, the app should dispose of it with a<br/>
		/// call to SDL_FreeSurface().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_ReadXPMFromArray")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurface* ReadXPMFromArray([NativeName(NativeNameType.Param, "xpm")] [NativeName(NativeNameType.Type, "char * *")] ref byte* xpm)
		{
			fixed (byte** pxpm = &xpm)
			{
				SDLSurface* ret = ReadXPMFromArrayNative((byte**)pxpm);
				return ret;
			}
		}

		/// <summary>
		/// Load an XPM image from a memory array.<br/>
		/// The returned surface will always be a 32-bit RGB surface. If you want 8-bit<br/>
		/// indexed colors (and the XPM data allows it), use IMG_ReadXPMFromArray()<br/>
		/// instead.<br/>
		/// When done with the returned surface, the app should dispose of it with a<br/>
		/// call to SDL_FreeSurface().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_ReadXPMFromArrayToRGB888")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLSurface* ReadXPMFromArrayToRGB888Native([NativeName(NativeNameType.Param, "xpm")] [NativeName(NativeNameType.Type, "char * *")] byte** xpm)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte**, SDLSurface*>)funcTable[48])(xpm);
			#else
			return (SDLSurface*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[48])((nint)xpm);
			#endif
		}

		/// <summary>
		/// Load an XPM image from a memory array.<br/>
		/// The returned surface will always be a 32-bit RGB surface. If you want 8-bit<br/>
		/// indexed colors (and the XPM data allows it), use IMG_ReadXPMFromArray()<br/>
		/// instead.<br/>
		/// When done with the returned surface, the app should dispose of it with a<br/>
		/// call to SDL_FreeSurface().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_ReadXPMFromArrayToRGB888")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurface* ReadXPMFromArrayToRGB888([NativeName(NativeNameType.Param, "xpm")] [NativeName(NativeNameType.Type, "char * *")] byte** xpm)
		{
			SDLSurface* ret = ReadXPMFromArrayToRGB888Native(xpm);
			return ret;
		}

		/// <summary>
		/// Load an XPM image from a memory array.<br/>
		/// The returned surface will always be a 32-bit RGB surface. If you want 8-bit<br/>
		/// indexed colors (and the XPM data allows it), use IMG_ReadXPMFromArray()<br/>
		/// instead.<br/>
		/// When done with the returned surface, the app should dispose of it with a<br/>
		/// call to SDL_FreeSurface().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_ReadXPMFromArrayToRGB888")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurface* ReadXPMFromArrayToRGB888([NativeName(NativeNameType.Param, "xpm")] [NativeName(NativeNameType.Type, "char * *")] ref byte* xpm)
		{
			fixed (byte** pxpm = &xpm)
			{
				SDLSurface* ret = ReadXPMFromArrayToRGB888Native((byte**)pxpm);
				return ret;
			}
		}

		/// <summary>
		/// Save an SDL_Surface into a PNG image file.<br/>
		/// If the file already exists, it will be overwritten.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_SavePNG")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int SavePNGNative([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] byte* file)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSurface*, byte*, int>)funcTable[49])(surface, file);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int>)funcTable[49])((nint)surface, (nint)file);
			#endif
		}

		/// <summary>
		/// Save an SDL_Surface into a PNG image file.<br/>
		/// If the file already exists, it will be overwritten.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_SavePNG")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SavePNG([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] byte* file)
		{
			int ret = SavePNGNative(surface, file);
			return ret;
		}

		/// <summary>
		/// Save an SDL_Surface into a PNG image file.<br/>
		/// If the file already exists, it will be overwritten.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_SavePNG")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SavePNG([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] byte* file)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				int ret = SavePNGNative((SDLSurface*)psurface, file);
				return ret;
			}
		}

		/// <summary>
		/// Save an SDL_Surface into a PNG image file.<br/>
		/// If the file already exists, it will be overwritten.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_SavePNG")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SavePNG([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] ref byte file)
		{
			fixed (byte* pfile = &file)
			{
				int ret = SavePNGNative(surface, (byte*)pfile);
				return ret;
			}
		}

		/// <summary>
		/// Save an SDL_Surface into a PNG image file.<br/>
		/// If the file already exists, it will be overwritten.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_SavePNG")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SavePNG([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> file)
		{
			fixed (byte* pfile = file)
			{
				int ret = SavePNGNative(surface, (byte*)pfile);
				return ret;
			}
		}

		/// <summary>
		/// Save an SDL_Surface into a PNG image file.<br/>
		/// If the file already exists, it will be overwritten.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_SavePNG")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SavePNG([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] string file)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (file != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(file);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(file, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = SavePNGNative(surface, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Save an SDL_Surface into a PNG image file.<br/>
		/// If the file already exists, it will be overwritten.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_SavePNG")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SavePNG([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] ref byte file)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				fixed (byte* pfile = &file)
				{
					int ret = SavePNGNative((SDLSurface*)psurface, (byte*)pfile);
					return ret;
				}
			}
		}

		/// <summary>
		/// Save an SDL_Surface into a PNG image file.<br/>
		/// If the file already exists, it will be overwritten.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_SavePNG")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SavePNG([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> file)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				fixed (byte* pfile = file)
				{
					int ret = SavePNGNative((SDLSurface*)psurface, (byte*)pfile);
					return ret;
				}
			}
		}

		/// <summary>
		/// Save an SDL_Surface into a PNG image file.<br/>
		/// If the file already exists, it will be overwritten.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_SavePNG")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SavePNG([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] string file)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (file != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(file);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(file, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				int ret = SavePNGNative((SDLSurface*)psurface, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// Save an SDL_Surface into PNG image data, via an SDL_RWops.<br/>
		/// If you just want to save to a filename, you can use IMG_SavePNG() instead.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_SavePNG_RW")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int SavePNGRWNative([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_RWops *")] SDLRWops* dst, [NativeName(NativeNameType.Param, "freedst")] [NativeName(NativeNameType.Type, "int")] int freedst)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSurface*, SDLRWops*, int, int>)funcTable[50])(surface, dst, freedst);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int, int>)funcTable[50])((nint)surface, (nint)dst, freedst);
			#endif
		}

		/// <summary>
		/// Save an SDL_Surface into PNG image data, via an SDL_RWops.<br/>
		/// If you just want to save to a filename, you can use IMG_SavePNG() instead.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_SavePNG_RW")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SavePNGRW([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_RWops *")] SDLRWops* dst, [NativeName(NativeNameType.Param, "freedst")] [NativeName(NativeNameType.Type, "int")] int freedst)
		{
			int ret = SavePNGRWNative(surface, dst, freedst);
			return ret;
		}

		/// <summary>
		/// Save an SDL_Surface into PNG image data, via an SDL_RWops.<br/>
		/// If you just want to save to a filename, you can use IMG_SavePNG() instead.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_SavePNG_RW")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SavePNGRW([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_RWops *")] SDLRWops* dst, [NativeName(NativeNameType.Param, "freedst")] [NativeName(NativeNameType.Type, "int")] int freedst)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				int ret = SavePNGRWNative((SDLSurface*)psurface, dst, freedst);
				return ret;
			}
		}

		/// <summary>
		/// Save an SDL_Surface into PNG image data, via an SDL_RWops.<br/>
		/// If you just want to save to a filename, you can use IMG_SavePNG() instead.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_SavePNG_RW")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SavePNGRW([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_RWops *")] ref SDLRWops dst, [NativeName(NativeNameType.Param, "freedst")] [NativeName(NativeNameType.Type, "int")] int freedst)
		{
			fixed (SDLRWops* pdst = &dst)
			{
				int ret = SavePNGRWNative(surface, (SDLRWops*)pdst, freedst);
				return ret;
			}
		}

		/// <summary>
		/// Save an SDL_Surface into PNG image data, via an SDL_RWops.<br/>
		/// If you just want to save to a filename, you can use IMG_SavePNG() instead.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_SavePNG_RW")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SavePNGRW([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_RWops *")] ref SDLRWops dst, [NativeName(NativeNameType.Param, "freedst")] [NativeName(NativeNameType.Type, "int")] int freedst)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				fixed (SDLRWops* pdst = &dst)
				{
					int ret = SavePNGRWNative((SDLSurface*)psurface, (SDLRWops*)pdst, freedst);
					return ret;
				}
			}
		}

		/// <summary>
		/// Save an SDL_Surface into a JPEG image file.<br/>
		/// If the file already exists, it will be overwritten.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_SaveJPG")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int SaveJPGNative([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] byte* file, [NativeName(NativeNameType.Param, "quality")] [NativeName(NativeNameType.Type, "int")] int quality)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSurface*, byte*, int, int>)funcTable[51])(surface, file, quality);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int, int>)funcTable[51])((nint)surface, (nint)file, quality);
			#endif
		}

		/// <summary>
		/// Save an SDL_Surface into a JPEG image file.<br/>
		/// If the file already exists, it will be overwritten.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_SaveJPG")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SaveJPG([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] byte* file, [NativeName(NativeNameType.Param, "quality")] [NativeName(NativeNameType.Type, "int")] int quality)
		{
			int ret = SaveJPGNative(surface, file, quality);
			return ret;
		}

		/// <summary>
		/// Save an SDL_Surface into a JPEG image file.<br/>
		/// If the file already exists, it will be overwritten.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_SaveJPG")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SaveJPG([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] byte* file, [NativeName(NativeNameType.Param, "quality")] [NativeName(NativeNameType.Type, "int")] int quality)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				int ret = SaveJPGNative((SDLSurface*)psurface, file, quality);
				return ret;
			}
		}

		/// <summary>
		/// Save an SDL_Surface into a JPEG image file.<br/>
		/// If the file already exists, it will be overwritten.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_SaveJPG")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SaveJPG([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] ref byte file, [NativeName(NativeNameType.Param, "quality")] [NativeName(NativeNameType.Type, "int")] int quality)
		{
			fixed (byte* pfile = &file)
			{
				int ret = SaveJPGNative(surface, (byte*)pfile, quality);
				return ret;
			}
		}

		/// <summary>
		/// Save an SDL_Surface into a JPEG image file.<br/>
		/// If the file already exists, it will be overwritten.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_SaveJPG")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SaveJPG([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> file, [NativeName(NativeNameType.Param, "quality")] [NativeName(NativeNameType.Type, "int")] int quality)
		{
			fixed (byte* pfile = file)
			{
				int ret = SaveJPGNative(surface, (byte*)pfile, quality);
				return ret;
			}
		}

		/// <summary>
		/// Save an SDL_Surface into a JPEG image file.<br/>
		/// If the file already exists, it will be overwritten.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_SaveJPG")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SaveJPG([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] string file, [NativeName(NativeNameType.Param, "quality")] [NativeName(NativeNameType.Type, "int")] int quality)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (file != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(file);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(file, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = SaveJPGNative(surface, pStr0, quality);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Save an SDL_Surface into a JPEG image file.<br/>
		/// If the file already exists, it will be overwritten.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_SaveJPG")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SaveJPG([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] ref byte file, [NativeName(NativeNameType.Param, "quality")] [NativeName(NativeNameType.Type, "int")] int quality)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				fixed (byte* pfile = &file)
				{
					int ret = SaveJPGNative((SDLSurface*)psurface, (byte*)pfile, quality);
					return ret;
				}
			}
		}

		/// <summary>
		/// Save an SDL_Surface into a JPEG image file.<br/>
		/// If the file already exists, it will be overwritten.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_SaveJPG")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SaveJPG([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> file, [NativeName(NativeNameType.Param, "quality")] [NativeName(NativeNameType.Type, "int")] int quality)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				fixed (byte* pfile = file)
				{
					int ret = SaveJPGNative((SDLSurface*)psurface, (byte*)pfile, quality);
					return ret;
				}
			}
		}

		/// <summary>
		/// Save an SDL_Surface into a JPEG image file.<br/>
		/// If the file already exists, it will be overwritten.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_SaveJPG")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SaveJPG([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] string file, [NativeName(NativeNameType.Param, "quality")] [NativeName(NativeNameType.Type, "int")] int quality)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (file != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(file);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(file, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				int ret = SaveJPGNative((SDLSurface*)psurface, pStr0, quality);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// Save an SDL_Surface into JPEG image data, via an SDL_RWops.<br/>
		/// If you just want to save to a filename, you can use IMG_SaveJPG() instead.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_SaveJPG_RW")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int SaveJPGRWNative([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_RWops *")] SDLRWops* dst, [NativeName(NativeNameType.Param, "freedst")] [NativeName(NativeNameType.Type, "int")] int freedst, [NativeName(NativeNameType.Param, "quality")] [NativeName(NativeNameType.Type, "int")] int quality)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSurface*, SDLRWops*, int, int, int>)funcTable[52])(surface, dst, freedst, quality);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int, int, int>)funcTable[52])((nint)surface, (nint)dst, freedst, quality);
			#endif
		}

		/// <summary>
		/// Save an SDL_Surface into JPEG image data, via an SDL_RWops.<br/>
		/// If you just want to save to a filename, you can use IMG_SaveJPG() instead.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_SaveJPG_RW")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SaveJPGRW([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_RWops *")] SDLRWops* dst, [NativeName(NativeNameType.Param, "freedst")] [NativeName(NativeNameType.Type, "int")] int freedst, [NativeName(NativeNameType.Param, "quality")] [NativeName(NativeNameType.Type, "int")] int quality)
		{
			int ret = SaveJPGRWNative(surface, dst, freedst, quality);
			return ret;
		}

		/// <summary>
		/// Save an SDL_Surface into JPEG image data, via an SDL_RWops.<br/>
		/// If you just want to save to a filename, you can use IMG_SaveJPG() instead.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_SaveJPG_RW")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SaveJPGRW([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_RWops *")] SDLRWops* dst, [NativeName(NativeNameType.Param, "freedst")] [NativeName(NativeNameType.Type, "int")] int freedst, [NativeName(NativeNameType.Param, "quality")] [NativeName(NativeNameType.Type, "int")] int quality)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				int ret = SaveJPGRWNative((SDLSurface*)psurface, dst, freedst, quality);
				return ret;
			}
		}

		/// <summary>
		/// Save an SDL_Surface into JPEG image data, via an SDL_RWops.<br/>
		/// If you just want to save to a filename, you can use IMG_SaveJPG() instead.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_SaveJPG_RW")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SaveJPGRW([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_RWops *")] ref SDLRWops dst, [NativeName(NativeNameType.Param, "freedst")] [NativeName(NativeNameType.Type, "int")] int freedst, [NativeName(NativeNameType.Param, "quality")] [NativeName(NativeNameType.Type, "int")] int quality)
		{
			fixed (SDLRWops* pdst = &dst)
			{
				int ret = SaveJPGRWNative(surface, (SDLRWops*)pdst, freedst, quality);
				return ret;
			}
		}

		/// <summary>
		/// Save an SDL_Surface into JPEG image data, via an SDL_RWops.<br/>
		/// If you just want to save to a filename, you can use IMG_SaveJPG() instead.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_SaveJPG_RW")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int SaveJPGRW([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_RWops *")] ref SDLRWops dst, [NativeName(NativeNameType.Param, "freedst")] [NativeName(NativeNameType.Type, "int")] int freedst, [NativeName(NativeNameType.Param, "quality")] [NativeName(NativeNameType.Type, "int")] int quality)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				fixed (SDLRWops* pdst = &dst)
				{
					int ret = SaveJPGRWNative((SDLSurface*)psurface, (SDLRWops*)pdst, freedst, quality);
					return ret;
				}
			}
		}

		/// <summary>
		/// Load an animation from a file.<br/>
		/// When done with the returned animation, the app should dispose of it with a<br/>
		/// call to IMG_FreeAnimation().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadAnimation")]
		[return: NativeName(NativeNameType.Type, "IMG_Animation *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static IMGAnimation* LoadAnimationNative([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] byte* file)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, IMGAnimation*>)funcTable[53])(file);
			#else
			return (IMGAnimation*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[53])((nint)file);
			#endif
		}

		/// <summary>
		/// Load an animation from a file.<br/>
		/// When done with the returned animation, the app should dispose of it with a<br/>
		/// call to IMG_FreeAnimation().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadAnimation")]
		[return: NativeName(NativeNameType.Type, "IMG_Animation *")]
		public static IMGAnimation* LoadAnimation([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] byte* file)
		{
			IMGAnimation* ret = LoadAnimationNative(file);
			return ret;
		}

		/// <summary>
		/// Load an animation from a file.<br/>
		/// When done with the returned animation, the app should dispose of it with a<br/>
		/// call to IMG_FreeAnimation().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadAnimation")]
		[return: NativeName(NativeNameType.Type, "IMG_Animation *")]
		public static IMGAnimation* LoadAnimation([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] ref byte file)
		{
			fixed (byte* pfile = &file)
			{
				IMGAnimation* ret = LoadAnimationNative((byte*)pfile);
				return ret;
			}
		}

		/// <summary>
		/// Load an animation from a file.<br/>
		/// When done with the returned animation, the app should dispose of it with a<br/>
		/// call to IMG_FreeAnimation().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadAnimation")]
		[return: NativeName(NativeNameType.Type, "IMG_Animation *")]
		public static IMGAnimation* LoadAnimation([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> file)
		{
			fixed (byte* pfile = file)
			{
				IMGAnimation* ret = LoadAnimationNative((byte*)pfile);
				return ret;
			}
		}

		/// <summary>
		/// Load an animation from a file.<br/>
		/// When done with the returned animation, the app should dispose of it with a<br/>
		/// call to IMG_FreeAnimation().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadAnimation")]
		[return: NativeName(NativeNameType.Type, "IMG_Animation *")]
		public static IMGAnimation* LoadAnimation([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] string file)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (file != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(file);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(file, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			IMGAnimation* ret = LoadAnimationNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Load an animation from an SDL_RWops.<br/>
		/// If `freesrc` is non-zero, the RWops will be closed before returning,<br/>
		/// whether this function succeeds or not. SDL_image reads everything it needs<br/>
		/// from the RWops during this call in any case.<br/>
		/// When done with the returned animation, the app should dispose of it with a<br/>
		/// call to IMG_FreeAnimation().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadAnimation_RW")]
		[return: NativeName(NativeNameType.Type, "IMG_Animation *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static IMGAnimation* LoadAnimationRWNative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] SDLRWops* src, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, int, IMGAnimation*>)funcTable[54])(src, freesrc);
			#else
			return (IMGAnimation*)((delegate* unmanaged[Cdecl]<nint, int, nint>)funcTable[54])((nint)src, freesrc);
			#endif
		}

		/// <summary>
		/// Load an animation from an SDL_RWops.<br/>
		/// If `freesrc` is non-zero, the RWops will be closed before returning,<br/>
		/// whether this function succeeds or not. SDL_image reads everything it needs<br/>
		/// from the RWops during this call in any case.<br/>
		/// When done with the returned animation, the app should dispose of it with a<br/>
		/// call to IMG_FreeAnimation().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadAnimation_RW")]
		[return: NativeName(NativeNameType.Type, "IMG_Animation *")]
		public static IMGAnimation* LoadAnimationRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] SDLRWops* src, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc)
		{
			IMGAnimation* ret = LoadAnimationRWNative(src, freesrc);
			return ret;
		}

		/// <summary>
		/// Load an animation from an SDL_RWops.<br/>
		/// If `freesrc` is non-zero, the RWops will be closed before returning,<br/>
		/// whether this function succeeds or not. SDL_image reads everything it needs<br/>
		/// from the RWops during this call in any case.<br/>
		/// When done with the returned animation, the app should dispose of it with a<br/>
		/// call to IMG_FreeAnimation().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadAnimation_RW")]
		[return: NativeName(NativeNameType.Type, "IMG_Animation *")]
		public static IMGAnimation* LoadAnimationRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] ref SDLRWops src, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc)
		{
			fixed (SDLRWops* psrc = &src)
			{
				IMGAnimation* ret = LoadAnimationRWNative((SDLRWops*)psrc, freesrc);
				return ret;
			}
		}

		/// <summary>
		/// Load an animation from an SDL datasource<br/>
		/// Even though this function accepts a file type, SDL_image may still try<br/>
		/// other decoders that are capable of detecting file type from the contents of<br/>
		/// the image data, but may rely on the caller-provided type string for formats<br/>
		/// that it cannot autodetect. If `type` is NULL, SDL_image will rely solely on<br/>
		/// its ability to guess the format.<br/>
		/// If `freesrc` is non-zero, the RWops will be closed before returning,<br/>
		/// whether this function succeeds or not. SDL_image reads everything it needs<br/>
		/// from the RWops during this call in any case.<br/>
		/// When done with the returned animation, the app should dispose of it with a<br/>
		/// call to IMG_FreeAnimation().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadAnimationTyped_RW")]
		[return: NativeName(NativeNameType.Type, "IMG_Animation *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static IMGAnimation* LoadAnimationTypedRWNative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] SDLRWops* src, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "char const *")] byte* type)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, int, byte*, IMGAnimation*>)funcTable[55])(src, freesrc, type);
			#else
			return (IMGAnimation*)((delegate* unmanaged[Cdecl]<nint, int, nint, nint>)funcTable[55])((nint)src, freesrc, (nint)type);
			#endif
		}

		/// <summary>
		/// Load an animation from an SDL datasource<br/>
		/// Even though this function accepts a file type, SDL_image may still try<br/>
		/// other decoders that are capable of detecting file type from the contents of<br/>
		/// the image data, but may rely on the caller-provided type string for formats<br/>
		/// that it cannot autodetect. If `type` is NULL, SDL_image will rely solely on<br/>
		/// its ability to guess the format.<br/>
		/// If `freesrc` is non-zero, the RWops will be closed before returning,<br/>
		/// whether this function succeeds or not. SDL_image reads everything it needs<br/>
		/// from the RWops during this call in any case.<br/>
		/// When done with the returned animation, the app should dispose of it with a<br/>
		/// call to IMG_FreeAnimation().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadAnimationTyped_RW")]
		[return: NativeName(NativeNameType.Type, "IMG_Animation *")]
		public static IMGAnimation* LoadAnimationTypedRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] SDLRWops* src, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "char const *")] byte* type)
		{
			IMGAnimation* ret = LoadAnimationTypedRWNative(src, freesrc, type);
			return ret;
		}

		/// <summary>
		/// Load an animation from an SDL datasource<br/>
		/// Even though this function accepts a file type, SDL_image may still try<br/>
		/// other decoders that are capable of detecting file type from the contents of<br/>
		/// the image data, but may rely on the caller-provided type string for formats<br/>
		/// that it cannot autodetect. If `type` is NULL, SDL_image will rely solely on<br/>
		/// its ability to guess the format.<br/>
		/// If `freesrc` is non-zero, the RWops will be closed before returning,<br/>
		/// whether this function succeeds or not. SDL_image reads everything it needs<br/>
		/// from the RWops during this call in any case.<br/>
		/// When done with the returned animation, the app should dispose of it with a<br/>
		/// call to IMG_FreeAnimation().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadAnimationTyped_RW")]
		[return: NativeName(NativeNameType.Type, "IMG_Animation *")]
		public static IMGAnimation* LoadAnimationTypedRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] ref SDLRWops src, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "char const *")] byte* type)
		{
			fixed (SDLRWops* psrc = &src)
			{
				IMGAnimation* ret = LoadAnimationTypedRWNative((SDLRWops*)psrc, freesrc, type);
				return ret;
			}
		}

		/// <summary>
		/// Load an animation from an SDL datasource<br/>
		/// Even though this function accepts a file type, SDL_image may still try<br/>
		/// other decoders that are capable of detecting file type from the contents of<br/>
		/// the image data, but may rely on the caller-provided type string for formats<br/>
		/// that it cannot autodetect. If `type` is NULL, SDL_image will rely solely on<br/>
		/// its ability to guess the format.<br/>
		/// If `freesrc` is non-zero, the RWops will be closed before returning,<br/>
		/// whether this function succeeds or not. SDL_image reads everything it needs<br/>
		/// from the RWops during this call in any case.<br/>
		/// When done with the returned animation, the app should dispose of it with a<br/>
		/// call to IMG_FreeAnimation().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadAnimationTyped_RW")]
		[return: NativeName(NativeNameType.Type, "IMG_Animation *")]
		public static IMGAnimation* LoadAnimationTypedRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] SDLRWops* src, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "char const *")] ref byte type)
		{
			fixed (byte* ptype = &type)
			{
				IMGAnimation* ret = LoadAnimationTypedRWNative(src, freesrc, (byte*)ptype);
				return ret;
			}
		}

		/// <summary>
		/// Load an animation from an SDL datasource<br/>
		/// Even though this function accepts a file type, SDL_image may still try<br/>
		/// other decoders that are capable of detecting file type from the contents of<br/>
		/// the image data, but may rely on the caller-provided type string for formats<br/>
		/// that it cannot autodetect. If `type` is NULL, SDL_image will rely solely on<br/>
		/// its ability to guess the format.<br/>
		/// If `freesrc` is non-zero, the RWops will be closed before returning,<br/>
		/// whether this function succeeds or not. SDL_image reads everything it needs<br/>
		/// from the RWops during this call in any case.<br/>
		/// When done with the returned animation, the app should dispose of it with a<br/>
		/// call to IMG_FreeAnimation().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadAnimationTyped_RW")]
		[return: NativeName(NativeNameType.Type, "IMG_Animation *")]
		public static IMGAnimation* LoadAnimationTypedRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] SDLRWops* src, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> type)
		{
			fixed (byte* ptype = type)
			{
				IMGAnimation* ret = LoadAnimationTypedRWNative(src, freesrc, (byte*)ptype);
				return ret;
			}
		}

		/// <summary>
		/// Load an animation from an SDL datasource<br/>
		/// Even though this function accepts a file type, SDL_image may still try<br/>
		/// other decoders that are capable of detecting file type from the contents of<br/>
		/// the image data, but may rely on the caller-provided type string for formats<br/>
		/// that it cannot autodetect. If `type` is NULL, SDL_image will rely solely on<br/>
		/// its ability to guess the format.<br/>
		/// If `freesrc` is non-zero, the RWops will be closed before returning,<br/>
		/// whether this function succeeds or not. SDL_image reads everything it needs<br/>
		/// from the RWops during this call in any case.<br/>
		/// When done with the returned animation, the app should dispose of it with a<br/>
		/// call to IMG_FreeAnimation().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadAnimationTyped_RW")]
		[return: NativeName(NativeNameType.Type, "IMG_Animation *")]
		public static IMGAnimation* LoadAnimationTypedRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] SDLRWops* src, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "char const *")] string type)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (type != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(type);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(type, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			IMGAnimation* ret = LoadAnimationTypedRWNative(src, freesrc, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Load an animation from an SDL datasource<br/>
		/// Even though this function accepts a file type, SDL_image may still try<br/>
		/// other decoders that are capable of detecting file type from the contents of<br/>
		/// the image data, but may rely on the caller-provided type string for formats<br/>
		/// that it cannot autodetect. If `type` is NULL, SDL_image will rely solely on<br/>
		/// its ability to guess the format.<br/>
		/// If `freesrc` is non-zero, the RWops will be closed before returning,<br/>
		/// whether this function succeeds or not. SDL_image reads everything it needs<br/>
		/// from the RWops during this call in any case.<br/>
		/// When done with the returned animation, the app should dispose of it with a<br/>
		/// call to IMG_FreeAnimation().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadAnimationTyped_RW")]
		[return: NativeName(NativeNameType.Type, "IMG_Animation *")]
		public static IMGAnimation* LoadAnimationTypedRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] ref SDLRWops src, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "char const *")] ref byte type)
		{
			fixed (SDLRWops* psrc = &src)
			{
				fixed (byte* ptype = &type)
				{
					IMGAnimation* ret = LoadAnimationTypedRWNative((SDLRWops*)psrc, freesrc, (byte*)ptype);
					return ret;
				}
			}
		}

		/// <summary>
		/// Load an animation from an SDL datasource<br/>
		/// Even though this function accepts a file type, SDL_image may still try<br/>
		/// other decoders that are capable of detecting file type from the contents of<br/>
		/// the image data, but may rely on the caller-provided type string for formats<br/>
		/// that it cannot autodetect. If `type` is NULL, SDL_image will rely solely on<br/>
		/// its ability to guess the format.<br/>
		/// If `freesrc` is non-zero, the RWops will be closed before returning,<br/>
		/// whether this function succeeds or not. SDL_image reads everything it needs<br/>
		/// from the RWops during this call in any case.<br/>
		/// When done with the returned animation, the app should dispose of it with a<br/>
		/// call to IMG_FreeAnimation().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadAnimationTyped_RW")]
		[return: NativeName(NativeNameType.Type, "IMG_Animation *")]
		public static IMGAnimation* LoadAnimationTypedRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] ref SDLRWops src, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> type)
		{
			fixed (SDLRWops* psrc = &src)
			{
				fixed (byte* ptype = type)
				{
					IMGAnimation* ret = LoadAnimationTypedRWNative((SDLRWops*)psrc, freesrc, (byte*)ptype);
					return ret;
				}
			}
		}

		/// <summary>
		/// Load an animation from an SDL datasource<br/>
		/// Even though this function accepts a file type, SDL_image may still try<br/>
		/// other decoders that are capable of detecting file type from the contents of<br/>
		/// the image data, but may rely on the caller-provided type string for formats<br/>
		/// that it cannot autodetect. If `type` is NULL, SDL_image will rely solely on<br/>
		/// its ability to guess the format.<br/>
		/// If `freesrc` is non-zero, the RWops will be closed before returning,<br/>
		/// whether this function succeeds or not. SDL_image reads everything it needs<br/>
		/// from the RWops during this call in any case.<br/>
		/// When done with the returned animation, the app should dispose of it with a<br/>
		/// call to IMG_FreeAnimation().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadAnimationTyped_RW")]
		[return: NativeName(NativeNameType.Type, "IMG_Animation *")]
		public static IMGAnimation* LoadAnimationTypedRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] ref SDLRWops src, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "char const *")] string type)
		{
			fixed (SDLRWops* psrc = &src)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (type != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(type);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(type, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				IMGAnimation* ret = LoadAnimationTypedRWNative((SDLRWops*)psrc, freesrc, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// Dispose of an IMG_Animation and free its resources.<br/>
		/// The provided `anim` pointer is not valid once this call returns.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_FreeAnimation")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FreeAnimationNative([NativeName(NativeNameType.Param, "anim")] [NativeName(NativeNameType.Type, "IMG_Animation *")] IMGAnimation* anim)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<IMGAnimation*, void>)funcTable[56])(anim);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[56])((nint)anim);
			#endif
		}

		/// <summary>
		/// Dispose of an IMG_Animation and free its resources.<br/>
		/// The provided `anim` pointer is not valid once this call returns.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_FreeAnimation")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void FreeAnimation([NativeName(NativeNameType.Param, "anim")] [NativeName(NativeNameType.Type, "IMG_Animation *")] IMGAnimation* anim)
		{
			FreeAnimationNative(anim);
		}

		/// <summary>
		/// Dispose of an IMG_Animation and free its resources.<br/>
		/// The provided `anim` pointer is not valid once this call returns.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_FreeAnimation")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void FreeAnimation([NativeName(NativeNameType.Param, "anim")] [NativeName(NativeNameType.Type, "IMG_Animation *")] ref IMGAnimation anim)
		{
			fixed (IMGAnimation* panim = &anim)
			{
				FreeAnimationNative((IMGAnimation*)panim);
			}
		}

		/// <summary>
		/// Load a GIF animation directly.<br/>
		/// If you know you definitely have a GIF image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_RWops<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadGIFAnimation_RW")]
		[return: NativeName(NativeNameType.Type, "IMG_Animation *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static IMGAnimation* LoadGIFAnimationRWNative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] SDLRWops* src)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, IMGAnimation*>)funcTable[57])(src);
			#else
			return (IMGAnimation*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[57])((nint)src);
			#endif
		}

		/// <summary>
		/// Load a GIF animation directly.<br/>
		/// If you know you definitely have a GIF image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_RWops<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadGIFAnimation_RW")]
		[return: NativeName(NativeNameType.Type, "IMG_Animation *")]
		public static IMGAnimation* LoadGIFAnimationRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] SDLRWops* src)
		{
			IMGAnimation* ret = LoadGIFAnimationRWNative(src);
			return ret;
		}

		/// <summary>
		/// Load a GIF animation directly.<br/>
		/// If you know you definitely have a GIF image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_RWops<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadGIFAnimation_RW")]
		[return: NativeName(NativeNameType.Type, "IMG_Animation *")]
		public static IMGAnimation* LoadGIFAnimationRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] ref SDLRWops src)
		{
			fixed (SDLRWops* psrc = &src)
			{
				IMGAnimation* ret = LoadGIFAnimationRWNative((SDLRWops*)psrc);
				return ret;
			}
		}

		/// <summary>
		/// Load a WEBP animation directly.<br/>
		/// If you know you definitely have a WEBP image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_RWops<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadWEBPAnimation_RW")]
		[return: NativeName(NativeNameType.Type, "IMG_Animation *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static IMGAnimation* LoadWEBPAnimationRWNative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] SDLRWops* src)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, IMGAnimation*>)funcTable[58])(src);
			#else
			return (IMGAnimation*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[58])((nint)src);
			#endif
		}

		/// <summary>
		/// Load a WEBP animation directly.<br/>
		/// If you know you definitely have a WEBP image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_RWops<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadWEBPAnimation_RW")]
		[return: NativeName(NativeNameType.Type, "IMG_Animation *")]
		public static IMGAnimation* LoadWEBPAnimationRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] SDLRWops* src)
		{
			IMGAnimation* ret = LoadWEBPAnimationRWNative(src);
			return ret;
		}

		/// <summary>
		/// Load a WEBP animation directly.<br/>
		/// If you know you definitely have a WEBP image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_RWops<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadWEBPAnimation_RW")]
		[return: NativeName(NativeNameType.Type, "IMG_Animation *")]
		public static IMGAnimation* LoadWEBPAnimationRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] ref SDLRWops src)
		{
			fixed (SDLRWops* psrc = &src)
			{
				IMGAnimation* ret = LoadWEBPAnimationRWNative((SDLRWops*)psrc);
				return ret;
			}
		}

	}
}
