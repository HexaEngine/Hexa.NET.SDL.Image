// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;
using Hexa.NET.SDL2;

namespace Hexa.NET.SDL2.Image
{
	public unsafe partial class SDLImage
	{

		/// <summary>
		/// Load a WEBP image directly.<br/>
		/// If you know you definitely have a WEBP image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_RWops<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadWEBP_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface*")]
		public static SDLSurface* IMGLoadWEBPRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src)
		{
			SDLSurface* ret = IMGLoadWEBPRWNative(src);
			return ret;
		}

		/// <summary>
		/// Load a WEBP image directly.<br/>
		/// If you know you definitely have a WEBP image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_RWops<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadWEBP_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface*")]
		public static SDLSurface* IMGLoadWEBPRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops src)
		{
			fixed (SDLRWops* psrc = &src)
			{
				SDLSurface* ret = IMGLoadWEBPRWNative((SDLRWops*)psrc);
				return ret;
			}
		}

		/// <summary>
		/// Load an SVG image, scaled to a specific size.<br/>
		/// Since SVG files are resolution-independent, you specify the size you would<br/>
		/// like the output image to be and it will be generated at those dimensions.<br/>
		/// Either width or height may be 0 and the image will be auto-sized to<br/>
		/// preserve aspect ratio.<br/>
		/// When done with the returned surface, the app should dispose of it with a<br/>
		/// call to SDL_FreeSurface().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadSizedSVG_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface*")]
		internal static SDLSurface* IMGLoadSizedSVGRWNative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src, [NativeName(NativeNameType.Param, "width")] [NativeName(NativeNameType.Type, "int")] int width, [NativeName(NativeNameType.Param, "height")] [NativeName(NativeNameType.Type, "int")] int height)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, int, int, SDLSurface*>)vt[46])(src, width, height);
			#else
			return (SDLSurface*)((delegate* unmanaged[Cdecl]<nint, int, int, nint>)vt[46])((nint)src, width, height);
			#endif
		}

		/// <summary>
		/// Load an SVG image, scaled to a specific size.<br/>
		/// Since SVG files are resolution-independent, you specify the size you would<br/>
		/// like the output image to be and it will be generated at those dimensions.<br/>
		/// Either width or height may be 0 and the image will be auto-sized to<br/>
		/// preserve aspect ratio.<br/>
		/// When done with the returned surface, the app should dispose of it with a<br/>
		/// call to SDL_FreeSurface().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadSizedSVG_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface*")]
		public static SDLSurface* IMGLoadSizedSVGRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src, [NativeName(NativeNameType.Param, "width")] [NativeName(NativeNameType.Type, "int")] int width, [NativeName(NativeNameType.Param, "height")] [NativeName(NativeNameType.Type, "int")] int height)
		{
			SDLSurface* ret = IMGLoadSizedSVGRWNative(src, width, height);
			return ret;
		}

		/// <summary>
		/// Load an SVG image, scaled to a specific size.<br/>
		/// Since SVG files are resolution-independent, you specify the size you would<br/>
		/// like the output image to be and it will be generated at those dimensions.<br/>
		/// Either width or height may be 0 and the image will be auto-sized to<br/>
		/// preserve aspect ratio.<br/>
		/// When done with the returned surface, the app should dispose of it with a<br/>
		/// call to SDL_FreeSurface().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadSizedSVG_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface*")]
		public static SDLSurface* IMGLoadSizedSVGRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops src, [NativeName(NativeNameType.Param, "width")] [NativeName(NativeNameType.Type, "int")] int width, [NativeName(NativeNameType.Param, "height")] [NativeName(NativeNameType.Type, "int")] int height)
		{
			fixed (SDLRWops* psrc = &src)
			{
				SDLSurface* ret = IMGLoadSizedSVGRWNative((SDLRWops*)psrc, width, height);
				return ret;
			}
		}

		/// <summary>
		/// Load an XPM image from a memory array.<br/>
		/// The returned surface will be an 8bpp indexed surface, if possible,<br/>
		/// otherwise it will be 32bpp. If you always want 32-bit data, use<br/>
		/// IMG_ReadXPMFromArrayToRGB888() instead.<br/>
		/// When done with the returned surface, the app should dispose of it with a<br/>
		/// call to SDL_FreeSurface().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_ReadXPMFromArray")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface*")]
		internal static SDLSurface* IMGReadXPMFromArrayNative([NativeName(NativeNameType.Param, "xpm")] [NativeName(NativeNameType.Type, "char**")] byte** xpm)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte**, SDLSurface*>)vt[47])(xpm);
			#else
			return (SDLSurface*)((delegate* unmanaged[Cdecl]<nint, nint>)vt[47])((nint)xpm);
			#endif
		}

		/// <summary>
		/// Load an XPM image from a memory array.<br/>
		/// The returned surface will be an 8bpp indexed surface, if possible,<br/>
		/// otherwise it will be 32bpp. If you always want 32-bit data, use<br/>
		/// IMG_ReadXPMFromArrayToRGB888() instead.<br/>
		/// When done with the returned surface, the app should dispose of it with a<br/>
		/// call to SDL_FreeSurface().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_ReadXPMFromArray")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface*")]
		public static SDLSurface* IMGReadXPMFromArray([NativeName(NativeNameType.Param, "xpm")] [NativeName(NativeNameType.Type, "char**")] byte** xpm)
		{
			SDLSurface* ret = IMGReadXPMFromArrayNative(xpm);
			return ret;
		}

		/// <summary>
		/// Load an XPM image from a memory array.<br/>
		/// The returned surface will be an 8bpp indexed surface, if possible,<br/>
		/// otherwise it will be 32bpp. If you always want 32-bit data, use<br/>
		/// IMG_ReadXPMFromArrayToRGB888() instead.<br/>
		/// When done with the returned surface, the app should dispose of it with a<br/>
		/// call to SDL_FreeSurface().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_ReadXPMFromArray")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface*")]
		public static SDLSurface* IMGReadXPMFromArray([NativeName(NativeNameType.Param, "xpm")] [NativeName(NativeNameType.Type, "char**")] ref byte* xpm)
		{
			fixed (byte** pxpm = &xpm)
			{
				SDLSurface* ret = IMGReadXPMFromArrayNative((byte**)pxpm);
				return ret;
			}
		}

		/// <summary>
		/// Load an XPM image from a memory array.<br/>
		/// The returned surface will always be a 32-bit RGB surface. If you want 8-bit<br/>
		/// indexed colors (and the XPM data allows it), use IMG_ReadXPMFromArray()<br/>
		/// instead.<br/>
		/// When done with the returned surface, the app should dispose of it with a<br/>
		/// call to SDL_FreeSurface().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_ReadXPMFromArrayToRGB888")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface*")]
		internal static SDLSurface* IMGReadXPMFromArrayToRGB888Native([NativeName(NativeNameType.Param, "xpm")] [NativeName(NativeNameType.Type, "char**")] byte** xpm)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte**, SDLSurface*>)vt[48])(xpm);
			#else
			return (SDLSurface*)((delegate* unmanaged[Cdecl]<nint, nint>)vt[48])((nint)xpm);
			#endif
		}

		/// <summary>
		/// Load an XPM image from a memory array.<br/>
		/// The returned surface will always be a 32-bit RGB surface. If you want 8-bit<br/>
		/// indexed colors (and the XPM data allows it), use IMG_ReadXPMFromArray()<br/>
		/// instead.<br/>
		/// When done with the returned surface, the app should dispose of it with a<br/>
		/// call to SDL_FreeSurface().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_ReadXPMFromArrayToRGB888")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface*")]
		public static SDLSurface* IMGReadXPMFromArrayToRGB888([NativeName(NativeNameType.Param, "xpm")] [NativeName(NativeNameType.Type, "char**")] byte** xpm)
		{
			SDLSurface* ret = IMGReadXPMFromArrayToRGB888Native(xpm);
			return ret;
		}

		/// <summary>
		/// Load an XPM image from a memory array.<br/>
		/// The returned surface will always be a 32-bit RGB surface. If you want 8-bit<br/>
		/// indexed colors (and the XPM data allows it), use IMG_ReadXPMFromArray()<br/>
		/// instead.<br/>
		/// When done with the returned surface, the app should dispose of it with a<br/>
		/// call to SDL_FreeSurface().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_ReadXPMFromArrayToRGB888")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface*")]
		public static SDLSurface* IMGReadXPMFromArrayToRGB888([NativeName(NativeNameType.Param, "xpm")] [NativeName(NativeNameType.Type, "char**")] ref byte* xpm)
		{
			fixed (byte** pxpm = &xpm)
			{
				SDLSurface* ret = IMGReadXPMFromArrayToRGB888Native((byte**)pxpm);
				return ret;
			}
		}

		/// <summary>
		/// Save an SDL_Surface into a PNG image file.<br/>
		/// If the file already exists, it will be overwritten.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_SavePNG")]
		[return: NativeName(NativeNameType.Type, "int")]
		internal static int IMGSavePNGNative([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface, [NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "const char*")] byte* file)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSurface*, byte*, int>)vt[49])(surface, file);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int>)vt[49])((nint)surface, (nint)file);
			#endif
		}

		/// <summary>
		/// Save an SDL_Surface into a PNG image file.<br/>
		/// If the file already exists, it will be overwritten.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_SavePNG")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int IMGSavePNG([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface, [NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "const char*")] byte* file)
		{
			int ret = IMGSavePNGNative(surface, file);
			return ret;
		}

		/// <summary>
		/// Save an SDL_Surface into a PNG image file.<br/>
		/// If the file already exists, it will be overwritten.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_SavePNG")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int IMGSavePNG([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "const char*")] byte* file)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				int ret = IMGSavePNGNative((SDLSurface*)psurface, file);
				return ret;
			}
		}

		/// <summary>
		/// Save an SDL_Surface into a PNG image file.<br/>
		/// If the file already exists, it will be overwritten.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_SavePNG")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int IMGSavePNG([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface, [NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "const char*")] ref byte file)
		{
			fixed (byte* pfile = &file)
			{
				int ret = IMGSavePNGNative(surface, (byte*)pfile);
				return ret;
			}
		}

		/// <summary>
		/// Save an SDL_Surface into a PNG image file.<br/>
		/// If the file already exists, it will be overwritten.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_SavePNG")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int IMGSavePNG([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface, [NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> file)
		{
			fixed (byte* pfile = file)
			{
				int ret = IMGSavePNGNative(surface, (byte*)pfile);
				return ret;
			}
		}

		/// <summary>
		/// Save an SDL_Surface into a PNG image file.<br/>
		/// If the file already exists, it will be overwritten.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_SavePNG")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int IMGSavePNG([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface, [NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "const char*")] string file)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (file != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(file);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(file, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = IMGSavePNGNative(surface, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Save an SDL_Surface into a PNG image file.<br/>
		/// If the file already exists, it will be overwritten.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_SavePNG")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int IMGSavePNG([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "const char*")] ref byte file)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				fixed (byte* pfile = &file)
				{
					int ret = IMGSavePNGNative((SDLSurface*)psurface, (byte*)pfile);
					return ret;
				}
			}
		}

		/// <summary>
		/// Save an SDL_Surface into a PNG image file.<br/>
		/// If the file already exists, it will be overwritten.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_SavePNG")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int IMGSavePNG([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> file)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				fixed (byte* pfile = file)
				{
					int ret = IMGSavePNGNative((SDLSurface*)psurface, (byte*)pfile);
					return ret;
				}
			}
		}

		/// <summary>
		/// Save an SDL_Surface into a PNG image file.<br/>
		/// If the file already exists, it will be overwritten.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_SavePNG")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int IMGSavePNG([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "const char*")] string file)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (file != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(file);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(file, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				int ret = IMGSavePNGNative((SDLSurface*)psurface, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// Save an SDL_Surface into PNG image data, via an SDL_RWops.<br/>
		/// If you just want to save to a filename, you can use IMG_SavePNG() instead.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_SavePNG_RW")]
		[return: NativeName(NativeNameType.Type, "int")]
		internal static int IMGSavePNGRWNative([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* dst, [NativeName(NativeNameType.Param, "freedst")] [NativeName(NativeNameType.Type, "int")] int freedst)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSurface*, SDLRWops*, int, int>)vt[50])(surface, dst, freedst);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int, int>)vt[50])((nint)surface, (nint)dst, freedst);
			#endif
		}

		/// <summary>
		/// Save an SDL_Surface into PNG image data, via an SDL_RWops.<br/>
		/// If you just want to save to a filename, you can use IMG_SavePNG() instead.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_SavePNG_RW")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int IMGSavePNGRW([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* dst, [NativeName(NativeNameType.Param, "freedst")] [NativeName(NativeNameType.Type, "int")] int freedst)
		{
			int ret = IMGSavePNGRWNative(surface, dst, freedst);
			return ret;
		}

		/// <summary>
		/// Save an SDL_Surface into PNG image data, via an SDL_RWops.<br/>
		/// If you just want to save to a filename, you can use IMG_SavePNG() instead.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_SavePNG_RW")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int IMGSavePNGRW([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* dst, [NativeName(NativeNameType.Param, "freedst")] [NativeName(NativeNameType.Type, "int")] int freedst)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				int ret = IMGSavePNGRWNative((SDLSurface*)psurface, dst, freedst);
				return ret;
			}
		}

		/// <summary>
		/// Save an SDL_Surface into PNG image data, via an SDL_RWops.<br/>
		/// If you just want to save to a filename, you can use IMG_SavePNG() instead.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_SavePNG_RW")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int IMGSavePNGRW([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops dst, [NativeName(NativeNameType.Param, "freedst")] [NativeName(NativeNameType.Type, "int")] int freedst)
		{
			fixed (SDLRWops* pdst = &dst)
			{
				int ret = IMGSavePNGRWNative(surface, (SDLRWops*)pdst, freedst);
				return ret;
			}
		}

		/// <summary>
		/// Save an SDL_Surface into PNG image data, via an SDL_RWops.<br/>
		/// If you just want to save to a filename, you can use IMG_SavePNG() instead.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_SavePNG_RW")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int IMGSavePNGRW([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops dst, [NativeName(NativeNameType.Param, "freedst")] [NativeName(NativeNameType.Type, "int")] int freedst)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				fixed (SDLRWops* pdst = &dst)
				{
					int ret = IMGSavePNGRWNative((SDLSurface*)psurface, (SDLRWops*)pdst, freedst);
					return ret;
				}
			}
		}

		/// <summary>
		/// Save an SDL_Surface into a JPEG image file.<br/>
		/// If the file already exists, it will be overwritten.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_SaveJPG")]
		[return: NativeName(NativeNameType.Type, "int")]
		internal static int IMGSaveJPGNative([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface, [NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "const char*")] byte* file, [NativeName(NativeNameType.Param, "quality")] [NativeName(NativeNameType.Type, "int")] int quality)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSurface*, byte*, int, int>)vt[51])(surface, file, quality);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int, int>)vt[51])((nint)surface, (nint)file, quality);
			#endif
		}

		/// <summary>
		/// Save an SDL_Surface into a JPEG image file.<br/>
		/// If the file already exists, it will be overwritten.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_SaveJPG")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int IMGSaveJPG([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface, [NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "const char*")] byte* file, [NativeName(NativeNameType.Param, "quality")] [NativeName(NativeNameType.Type, "int")] int quality)
		{
			int ret = IMGSaveJPGNative(surface, file, quality);
			return ret;
		}

		/// <summary>
		/// Save an SDL_Surface into a JPEG image file.<br/>
		/// If the file already exists, it will be overwritten.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_SaveJPG")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int IMGSaveJPG([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "const char*")] byte* file, [NativeName(NativeNameType.Param, "quality")] [NativeName(NativeNameType.Type, "int")] int quality)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				int ret = IMGSaveJPGNative((SDLSurface*)psurface, file, quality);
				return ret;
			}
		}

		/// <summary>
		/// Save an SDL_Surface into a JPEG image file.<br/>
		/// If the file already exists, it will be overwritten.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_SaveJPG")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int IMGSaveJPG([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface, [NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "const char*")] ref byte file, [NativeName(NativeNameType.Param, "quality")] [NativeName(NativeNameType.Type, "int")] int quality)
		{
			fixed (byte* pfile = &file)
			{
				int ret = IMGSaveJPGNative(surface, (byte*)pfile, quality);
				return ret;
			}
		}

		/// <summary>
		/// Save an SDL_Surface into a JPEG image file.<br/>
		/// If the file already exists, it will be overwritten.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_SaveJPG")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int IMGSaveJPG([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface, [NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> file, [NativeName(NativeNameType.Param, "quality")] [NativeName(NativeNameType.Type, "int")] int quality)
		{
			fixed (byte* pfile = file)
			{
				int ret = IMGSaveJPGNative(surface, (byte*)pfile, quality);
				return ret;
			}
		}

		/// <summary>
		/// Save an SDL_Surface into a JPEG image file.<br/>
		/// If the file already exists, it will be overwritten.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_SaveJPG")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int IMGSaveJPG([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface, [NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "const char*")] string file, [NativeName(NativeNameType.Param, "quality")] [NativeName(NativeNameType.Type, "int")] int quality)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (file != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(file);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(file, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = IMGSaveJPGNative(surface, pStr0, quality);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Save an SDL_Surface into a JPEG image file.<br/>
		/// If the file already exists, it will be overwritten.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_SaveJPG")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int IMGSaveJPG([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "const char*")] ref byte file, [NativeName(NativeNameType.Param, "quality")] [NativeName(NativeNameType.Type, "int")] int quality)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				fixed (byte* pfile = &file)
				{
					int ret = IMGSaveJPGNative((SDLSurface*)psurface, (byte*)pfile, quality);
					return ret;
				}
			}
		}

		/// <summary>
		/// Save an SDL_Surface into a JPEG image file.<br/>
		/// If the file already exists, it will be overwritten.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_SaveJPG")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int IMGSaveJPG([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> file, [NativeName(NativeNameType.Param, "quality")] [NativeName(NativeNameType.Type, "int")] int quality)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				fixed (byte* pfile = file)
				{
					int ret = IMGSaveJPGNative((SDLSurface*)psurface, (byte*)pfile, quality);
					return ret;
				}
			}
		}

		/// <summary>
		/// Save an SDL_Surface into a JPEG image file.<br/>
		/// If the file already exists, it will be overwritten.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_SaveJPG")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int IMGSaveJPG([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "const char*")] string file, [NativeName(NativeNameType.Param, "quality")] [NativeName(NativeNameType.Type, "int")] int quality)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (file != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(file);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(file, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				int ret = IMGSaveJPGNative((SDLSurface*)psurface, pStr0, quality);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// Save an SDL_Surface into JPEG image data, via an SDL_RWops.<br/>
		/// If you just want to save to a filename, you can use IMG_SaveJPG() instead.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_SaveJPG_RW")]
		[return: NativeName(NativeNameType.Type, "int")]
		internal static int IMGSaveJPGRWNative([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* dst, [NativeName(NativeNameType.Param, "freedst")] [NativeName(NativeNameType.Type, "int")] int freedst, [NativeName(NativeNameType.Param, "quality")] [NativeName(NativeNameType.Type, "int")] int quality)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSurface*, SDLRWops*, int, int, int>)vt[52])(surface, dst, freedst, quality);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int, int, int>)vt[52])((nint)surface, (nint)dst, freedst, quality);
			#endif
		}

		/// <summary>
		/// Save an SDL_Surface into JPEG image data, via an SDL_RWops.<br/>
		/// If you just want to save to a filename, you can use IMG_SaveJPG() instead.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_SaveJPG_RW")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int IMGSaveJPGRW([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* dst, [NativeName(NativeNameType.Param, "freedst")] [NativeName(NativeNameType.Type, "int")] int freedst, [NativeName(NativeNameType.Param, "quality")] [NativeName(NativeNameType.Type, "int")] int quality)
		{
			int ret = IMGSaveJPGRWNative(surface, dst, freedst, quality);
			return ret;
		}

		/// <summary>
		/// Save an SDL_Surface into JPEG image data, via an SDL_RWops.<br/>
		/// If you just want to save to a filename, you can use IMG_SaveJPG() instead.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_SaveJPG_RW")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int IMGSaveJPGRW([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* dst, [NativeName(NativeNameType.Param, "freedst")] [NativeName(NativeNameType.Type, "int")] int freedst, [NativeName(NativeNameType.Param, "quality")] [NativeName(NativeNameType.Type, "int")] int quality)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				int ret = IMGSaveJPGRWNative((SDLSurface*)psurface, dst, freedst, quality);
				return ret;
			}
		}

		/// <summary>
		/// Save an SDL_Surface into JPEG image data, via an SDL_RWops.<br/>
		/// If you just want to save to a filename, you can use IMG_SaveJPG() instead.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_SaveJPG_RW")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int IMGSaveJPGRW([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] SDLSurface* surface, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops dst, [NativeName(NativeNameType.Param, "freedst")] [NativeName(NativeNameType.Type, "int")] int freedst, [NativeName(NativeNameType.Param, "quality")] [NativeName(NativeNameType.Type, "int")] int quality)
		{
			fixed (SDLRWops* pdst = &dst)
			{
				int ret = IMGSaveJPGRWNative(surface, (SDLRWops*)pdst, freedst, quality);
				return ret;
			}
		}

		/// <summary>
		/// Save an SDL_Surface into JPEG image data, via an SDL_RWops.<br/>
		/// If you just want to save to a filename, you can use IMG_SaveJPG() instead.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_SaveJPG_RW")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int IMGSaveJPGRW([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface*")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops dst, [NativeName(NativeNameType.Param, "freedst")] [NativeName(NativeNameType.Type, "int")] int freedst, [NativeName(NativeNameType.Param, "quality")] [NativeName(NativeNameType.Type, "int")] int quality)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				fixed (SDLRWops* pdst = &dst)
				{
					int ret = IMGSaveJPGRWNative((SDLSurface*)psurface, (SDLRWops*)pdst, freedst, quality);
					return ret;
				}
			}
		}

		/// <summary>
		/// Load an animation from a file.<br/>
		/// When done with the returned animation, the app should dispose of it with a<br/>
		/// call to IMG_FreeAnimation().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadAnimation")]
		[return: NativeName(NativeNameType.Type, "IMG_Animation*")]
		internal static IMGAnimation* IMGLoadAnimationNative([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "const char*")] byte* file)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, IMGAnimation*>)vt[53])(file);
			#else
			return (IMGAnimation*)((delegate* unmanaged[Cdecl]<nint, nint>)vt[53])((nint)file);
			#endif
		}

		/// <summary>
		/// Load an animation from a file.<br/>
		/// When done with the returned animation, the app should dispose of it with a<br/>
		/// call to IMG_FreeAnimation().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadAnimation")]
		[return: NativeName(NativeNameType.Type, "IMG_Animation*")]
		public static IMGAnimation* IMGLoadAnimation([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "const char*")] byte* file)
		{
			IMGAnimation* ret = IMGLoadAnimationNative(file);
			return ret;
		}

		/// <summary>
		/// Load an animation from a file.<br/>
		/// When done with the returned animation, the app should dispose of it with a<br/>
		/// call to IMG_FreeAnimation().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadAnimation")]
		[return: NativeName(NativeNameType.Type, "IMG_Animation*")]
		public static IMGAnimation* IMGLoadAnimation([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "const char*")] ref byte file)
		{
			fixed (byte* pfile = &file)
			{
				IMGAnimation* ret = IMGLoadAnimationNative((byte*)pfile);
				return ret;
			}
		}

		/// <summary>
		/// Load an animation from a file.<br/>
		/// When done with the returned animation, the app should dispose of it with a<br/>
		/// call to IMG_FreeAnimation().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadAnimation")]
		[return: NativeName(NativeNameType.Type, "IMG_Animation*")]
		public static IMGAnimation* IMGLoadAnimation([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> file)
		{
			fixed (byte* pfile = file)
			{
				IMGAnimation* ret = IMGLoadAnimationNative((byte*)pfile);
				return ret;
			}
		}

		/// <summary>
		/// Load an animation from a file.<br/>
		/// When done with the returned animation, the app should dispose of it with a<br/>
		/// call to IMG_FreeAnimation().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadAnimation")]
		[return: NativeName(NativeNameType.Type, "IMG_Animation*")]
		public static IMGAnimation* IMGLoadAnimation([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "const char*")] string file)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (file != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(file);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(file, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			IMGAnimation* ret = IMGLoadAnimationNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Load an animation from an SDL_RWops.<br/>
		/// If `freesrc` is non-zero, the RWops will be closed before returning,<br/>
		/// whether this function succeeds or not. SDL_image reads everything it needs<br/>
		/// from the RWops during this call in any case.<br/>
		/// When done with the returned animation, the app should dispose of it with a<br/>
		/// call to IMG_FreeAnimation().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadAnimation_RW")]
		[return: NativeName(NativeNameType.Type, "IMG_Animation*")]
		internal static IMGAnimation* IMGLoadAnimationRWNative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, int, IMGAnimation*>)vt[54])(src, freesrc);
			#else
			return (IMGAnimation*)((delegate* unmanaged[Cdecl]<nint, int, nint>)vt[54])((nint)src, freesrc);
			#endif
		}

		/// <summary>
		/// Load an animation from an SDL_RWops.<br/>
		/// If `freesrc` is non-zero, the RWops will be closed before returning,<br/>
		/// whether this function succeeds or not. SDL_image reads everything it needs<br/>
		/// from the RWops during this call in any case.<br/>
		/// When done with the returned animation, the app should dispose of it with a<br/>
		/// call to IMG_FreeAnimation().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadAnimation_RW")]
		[return: NativeName(NativeNameType.Type, "IMG_Animation*")]
		public static IMGAnimation* IMGLoadAnimationRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc)
		{
			IMGAnimation* ret = IMGLoadAnimationRWNative(src, freesrc);
			return ret;
		}

		/// <summary>
		/// Load an animation from an SDL_RWops.<br/>
		/// If `freesrc` is non-zero, the RWops will be closed before returning,<br/>
		/// whether this function succeeds or not. SDL_image reads everything it needs<br/>
		/// from the RWops during this call in any case.<br/>
		/// When done with the returned animation, the app should dispose of it with a<br/>
		/// call to IMG_FreeAnimation().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadAnimation_RW")]
		[return: NativeName(NativeNameType.Type, "IMG_Animation*")]
		public static IMGAnimation* IMGLoadAnimationRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops src, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc)
		{
			fixed (SDLRWops* psrc = &src)
			{
				IMGAnimation* ret = IMGLoadAnimationRWNative((SDLRWops*)psrc, freesrc);
				return ret;
			}
		}

		/// <summary>
		/// Load an animation from an SDL datasource<br/>
		/// Even though this function accepts a file type, SDL_image may still try<br/>
		/// other decoders that are capable of detecting file type from the contents of<br/>
		/// the image data, but may rely on the caller-provided type string for formats<br/>
		/// that it cannot autodetect. If `type` is NULL, SDL_image will rely solely on<br/>
		/// its ability to guess the format.<br/>
		/// If `freesrc` is non-zero, the RWops will be closed before returning,<br/>
		/// whether this function succeeds or not. SDL_image reads everything it needs<br/>
		/// from the RWops during this call in any case.<br/>
		/// When done with the returned animation, the app should dispose of it with a<br/>
		/// call to IMG_FreeAnimation().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadAnimationTyped_RW")]
		[return: NativeName(NativeNameType.Type, "IMG_Animation*")]
		internal static IMGAnimation* IMGLoadAnimationTypedRWNative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "const char*")] byte* type)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, int, byte*, IMGAnimation*>)vt[55])(src, freesrc, type);
			#else
			return (IMGAnimation*)((delegate* unmanaged[Cdecl]<nint, int, nint, nint>)vt[55])((nint)src, freesrc, (nint)type);
			#endif
		}

		/// <summary>
		/// Load an animation from an SDL datasource<br/>
		/// Even though this function accepts a file type, SDL_image may still try<br/>
		/// other decoders that are capable of detecting file type from the contents of<br/>
		/// the image data, but may rely on the caller-provided type string for formats<br/>
		/// that it cannot autodetect. If `type` is NULL, SDL_image will rely solely on<br/>
		/// its ability to guess the format.<br/>
		/// If `freesrc` is non-zero, the RWops will be closed before returning,<br/>
		/// whether this function succeeds or not. SDL_image reads everything it needs<br/>
		/// from the RWops during this call in any case.<br/>
		/// When done with the returned animation, the app should dispose of it with a<br/>
		/// call to IMG_FreeAnimation().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadAnimationTyped_RW")]
		[return: NativeName(NativeNameType.Type, "IMG_Animation*")]
		public static IMGAnimation* IMGLoadAnimationTypedRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "const char*")] byte* type)
		{
			IMGAnimation* ret = IMGLoadAnimationTypedRWNative(src, freesrc, type);
			return ret;
		}

		/// <summary>
		/// Load an animation from an SDL datasource<br/>
		/// Even though this function accepts a file type, SDL_image may still try<br/>
		/// other decoders that are capable of detecting file type from the contents of<br/>
		/// the image data, but may rely on the caller-provided type string for formats<br/>
		/// that it cannot autodetect. If `type` is NULL, SDL_image will rely solely on<br/>
		/// its ability to guess the format.<br/>
		/// If `freesrc` is non-zero, the RWops will be closed before returning,<br/>
		/// whether this function succeeds or not. SDL_image reads everything it needs<br/>
		/// from the RWops during this call in any case.<br/>
		/// When done with the returned animation, the app should dispose of it with a<br/>
		/// call to IMG_FreeAnimation().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadAnimationTyped_RW")]
		[return: NativeName(NativeNameType.Type, "IMG_Animation*")]
		public static IMGAnimation* IMGLoadAnimationTypedRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops src, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "const char*")] byte* type)
		{
			fixed (SDLRWops* psrc = &src)
			{
				IMGAnimation* ret = IMGLoadAnimationTypedRWNative((SDLRWops*)psrc, freesrc, type);
				return ret;
			}
		}

		/// <summary>
		/// Load an animation from an SDL datasource<br/>
		/// Even though this function accepts a file type, SDL_image may still try<br/>
		/// other decoders that are capable of detecting file type from the contents of<br/>
		/// the image data, but may rely on the caller-provided type string for formats<br/>
		/// that it cannot autodetect. If `type` is NULL, SDL_image will rely solely on<br/>
		/// its ability to guess the format.<br/>
		/// If `freesrc` is non-zero, the RWops will be closed before returning,<br/>
		/// whether this function succeeds or not. SDL_image reads everything it needs<br/>
		/// from the RWops during this call in any case.<br/>
		/// When done with the returned animation, the app should dispose of it with a<br/>
		/// call to IMG_FreeAnimation().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadAnimationTyped_RW")]
		[return: NativeName(NativeNameType.Type, "IMG_Animation*")]
		public static IMGAnimation* IMGLoadAnimationTypedRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "const char*")] ref byte type)
		{
			fixed (byte* ptype = &type)
			{
				IMGAnimation* ret = IMGLoadAnimationTypedRWNative(src, freesrc, (byte*)ptype);
				return ret;
			}
		}

		/// <summary>
		/// Load an animation from an SDL datasource<br/>
		/// Even though this function accepts a file type, SDL_image may still try<br/>
		/// other decoders that are capable of detecting file type from the contents of<br/>
		/// the image data, but may rely on the caller-provided type string for formats<br/>
		/// that it cannot autodetect. If `type` is NULL, SDL_image will rely solely on<br/>
		/// its ability to guess the format.<br/>
		/// If `freesrc` is non-zero, the RWops will be closed before returning,<br/>
		/// whether this function succeeds or not. SDL_image reads everything it needs<br/>
		/// from the RWops during this call in any case.<br/>
		/// When done with the returned animation, the app should dispose of it with a<br/>
		/// call to IMG_FreeAnimation().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadAnimationTyped_RW")]
		[return: NativeName(NativeNameType.Type, "IMG_Animation*")]
		public static IMGAnimation* IMGLoadAnimationTypedRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> type)
		{
			fixed (byte* ptype = type)
			{
				IMGAnimation* ret = IMGLoadAnimationTypedRWNative(src, freesrc, (byte*)ptype);
				return ret;
			}
		}

		/// <summary>
		/// Load an animation from an SDL datasource<br/>
		/// Even though this function accepts a file type, SDL_image may still try<br/>
		/// other decoders that are capable of detecting file type from the contents of<br/>
		/// the image data, but may rely on the caller-provided type string for formats<br/>
		/// that it cannot autodetect. If `type` is NULL, SDL_image will rely solely on<br/>
		/// its ability to guess the format.<br/>
		/// If `freesrc` is non-zero, the RWops will be closed before returning,<br/>
		/// whether this function succeeds or not. SDL_image reads everything it needs<br/>
		/// from the RWops during this call in any case.<br/>
		/// When done with the returned animation, the app should dispose of it with a<br/>
		/// call to IMG_FreeAnimation().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadAnimationTyped_RW")]
		[return: NativeName(NativeNameType.Type, "IMG_Animation*")]
		public static IMGAnimation* IMGLoadAnimationTypedRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "const char*")] string type)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (type != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(type);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(type, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			IMGAnimation* ret = IMGLoadAnimationTypedRWNative(src, freesrc, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Load an animation from an SDL datasource<br/>
		/// Even though this function accepts a file type, SDL_image may still try<br/>
		/// other decoders that are capable of detecting file type from the contents of<br/>
		/// the image data, but may rely on the caller-provided type string for formats<br/>
		/// that it cannot autodetect. If `type` is NULL, SDL_image will rely solely on<br/>
		/// its ability to guess the format.<br/>
		/// If `freesrc` is non-zero, the RWops will be closed before returning,<br/>
		/// whether this function succeeds or not. SDL_image reads everything it needs<br/>
		/// from the RWops during this call in any case.<br/>
		/// When done with the returned animation, the app should dispose of it with a<br/>
		/// call to IMG_FreeAnimation().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadAnimationTyped_RW")]
		[return: NativeName(NativeNameType.Type, "IMG_Animation*")]
		public static IMGAnimation* IMGLoadAnimationTypedRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops src, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "const char*")] ref byte type)
		{
			fixed (SDLRWops* psrc = &src)
			{
				fixed (byte* ptype = &type)
				{
					IMGAnimation* ret = IMGLoadAnimationTypedRWNative((SDLRWops*)psrc, freesrc, (byte*)ptype);
					return ret;
				}
			}
		}

		/// <summary>
		/// Load an animation from an SDL datasource<br/>
		/// Even though this function accepts a file type, SDL_image may still try<br/>
		/// other decoders that are capable of detecting file type from the contents of<br/>
		/// the image data, but may rely on the caller-provided type string for formats<br/>
		/// that it cannot autodetect. If `type` is NULL, SDL_image will rely solely on<br/>
		/// its ability to guess the format.<br/>
		/// If `freesrc` is non-zero, the RWops will be closed before returning,<br/>
		/// whether this function succeeds or not. SDL_image reads everything it needs<br/>
		/// from the RWops during this call in any case.<br/>
		/// When done with the returned animation, the app should dispose of it with a<br/>
		/// call to IMG_FreeAnimation().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadAnimationTyped_RW")]
		[return: NativeName(NativeNameType.Type, "IMG_Animation*")]
		public static IMGAnimation* IMGLoadAnimationTypedRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops src, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> type)
		{
			fixed (SDLRWops* psrc = &src)
			{
				fixed (byte* ptype = type)
				{
					IMGAnimation* ret = IMGLoadAnimationTypedRWNative((SDLRWops*)psrc, freesrc, (byte*)ptype);
					return ret;
				}
			}
		}

		/// <summary>
		/// Load an animation from an SDL datasource<br/>
		/// Even though this function accepts a file type, SDL_image may still try<br/>
		/// other decoders that are capable of detecting file type from the contents of<br/>
		/// the image data, but may rely on the caller-provided type string for formats<br/>
		/// that it cannot autodetect. If `type` is NULL, SDL_image will rely solely on<br/>
		/// its ability to guess the format.<br/>
		/// If `freesrc` is non-zero, the RWops will be closed before returning,<br/>
		/// whether this function succeeds or not. SDL_image reads everything it needs<br/>
		/// from the RWops during this call in any case.<br/>
		/// When done with the returned animation, the app should dispose of it with a<br/>
		/// call to IMG_FreeAnimation().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadAnimationTyped_RW")]
		[return: NativeName(NativeNameType.Type, "IMG_Animation*")]
		public static IMGAnimation* IMGLoadAnimationTypedRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops src, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "const char*")] string type)
		{
			fixed (SDLRWops* psrc = &src)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (type != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(type);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(type, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				IMGAnimation* ret = IMGLoadAnimationTypedRWNative((SDLRWops*)psrc, freesrc, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// Dispose of an IMG_Animation and free its resources.<br/>
		/// The provided `anim` pointer is not valid once this call returns.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_FreeAnimation")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void IMGFreeAnimationNative([NativeName(NativeNameType.Param, "anim")] [NativeName(NativeNameType.Type, "IMG_Animation*")] IMGAnimation* anim)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<IMGAnimation*, void>)vt[56])(anim);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[56])((nint)anim);
			#endif
		}

		/// <summary>
		/// Dispose of an IMG_Animation and free its resources.<br/>
		/// The provided `anim` pointer is not valid once this call returns.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_FreeAnimation")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void IMGFreeAnimation([NativeName(NativeNameType.Param, "anim")] [NativeName(NativeNameType.Type, "IMG_Animation*")] IMGAnimation* anim)
		{
			IMGFreeAnimationNative(anim);
		}

		/// <summary>
		/// Dispose of an IMG_Animation and free its resources.<br/>
		/// The provided `anim` pointer is not valid once this call returns.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_FreeAnimation")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void IMGFreeAnimation([NativeName(NativeNameType.Param, "anim")] [NativeName(NativeNameType.Type, "IMG_Animation*")] ref IMGAnimation anim)
		{
			fixed (IMGAnimation* panim = &anim)
			{
				IMGFreeAnimationNative((IMGAnimation*)panim);
			}
		}

		/// <summary>
		/// Load a GIF animation directly.<br/>
		/// If you know you definitely have a GIF image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_RWops<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadGIFAnimation_RW")]
		[return: NativeName(NativeNameType.Type, "IMG_Animation*")]
		internal static IMGAnimation* IMGLoadGIFAnimationRWNative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, IMGAnimation*>)vt[57])(src);
			#else
			return (IMGAnimation*)((delegate* unmanaged[Cdecl]<nint, nint>)vt[57])((nint)src);
			#endif
		}

		/// <summary>
		/// Load a GIF animation directly.<br/>
		/// If you know you definitely have a GIF image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_RWops<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadGIFAnimation_RW")]
		[return: NativeName(NativeNameType.Type, "IMG_Animation*")]
		public static IMGAnimation* IMGLoadGIFAnimationRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src)
		{
			IMGAnimation* ret = IMGLoadGIFAnimationRWNative(src);
			return ret;
		}

		/// <summary>
		/// Load a GIF animation directly.<br/>
		/// If you know you definitely have a GIF image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_RWops<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadGIFAnimation_RW")]
		[return: NativeName(NativeNameType.Type, "IMG_Animation*")]
		public static IMGAnimation* IMGLoadGIFAnimationRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops src)
		{
			fixed (SDLRWops* psrc = &src)
			{
				IMGAnimation* ret = IMGLoadGIFAnimationRWNative((SDLRWops*)psrc);
				return ret;
			}
		}

		/// <summary>
		/// Load a WEBP animation directly.<br/>
		/// If you know you definitely have a WEBP image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_RWops<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadWEBPAnimation_RW")]
		[return: NativeName(NativeNameType.Type, "IMG_Animation*")]
		internal static IMGAnimation* IMGLoadWEBPAnimationRWNative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, IMGAnimation*>)vt[58])(src);
			#else
			return (IMGAnimation*)((delegate* unmanaged[Cdecl]<nint, nint>)vt[58])((nint)src);
			#endif
		}

		/// <summary>
		/// Load a WEBP animation directly.<br/>
		/// If you know you definitely have a WEBP image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_RWops<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadWEBPAnimation_RW")]
		[return: NativeName(NativeNameType.Type, "IMG_Animation*")]
		public static IMGAnimation* IMGLoadWEBPAnimationRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src)
		{
			IMGAnimation* ret = IMGLoadWEBPAnimationRWNative(src);
			return ret;
		}

		/// <summary>
		/// Load a WEBP animation directly.<br/>
		/// If you know you definitely have a WEBP image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_RWops<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadWEBPAnimation_RW")]
		[return: NativeName(NativeNameType.Type, "IMG_Animation*")]
		public static IMGAnimation* IMGLoadWEBPAnimationRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops src)
		{
			fixed (SDLRWops* psrc = &src)
			{
				IMGAnimation* ret = IMGLoadWEBPAnimationRWNative((SDLRWops*)psrc);
				return ret;
			}
		}

	}
}
