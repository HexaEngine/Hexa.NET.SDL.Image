// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;
using Hexa.NET.SDL2;

namespace Hexa.NET.SDL2.Image
{
	public unsafe partial class SDLImage
	{
		/// <summary>
		/// This function gets the version of the dynamically linked SDL_image library.<br/>
		/// it should NOT be used to fill a version structure, instead you should use<br/>
		/// the SDL_IMAGE_VERSION() macro.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_Linked_Version")]
		[return: NativeName(NativeNameType.Type, "SDL_version const *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLVersion* LinkedVersionNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLVersion*>)funcTable[0])();
			#else
			return (SDLVersion*)((delegate* unmanaged[Cdecl]<nint>)funcTable[0])();
			#endif
		}

		/// <summary>
		/// This function gets the version of the dynamically linked SDL_image library.<br/>
		/// it should NOT be used to fill a version structure, instead you should use<br/>
		/// the SDL_IMAGE_VERSION() macro.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_Linked_Version")]
		[return: NativeName(NativeNameType.Type, "SDL_version const *")]
		public static SDLVersion* LinkedVersion()
		{
			SDLVersion* ret = LinkedVersionNative();
			return ret;
		}

		/// <summary>
		/// Initialize SDL_image.<br/>
		/// This function loads dynamic libraries that SDL_image needs, and prepares<br/>
		/// them for use. This must be the first function you call in SDL_image, and if<br/>
		/// it fails you should not continue with the library.<br/>
		/// Flags should be one or more flags from IMG_InitFlags OR'd together. It<br/>
		/// returns the flags successfully initialized, or 0 on failure.<br/>
		/// Currently, these flags are:<br/>
		/// - `IMG_INIT_JPG`<br/>
		/// - `IMG_INIT_PNG`<br/>
		/// - `IMG_INIT_TIF`<br/>
		/// - `IMG_INIT_WEBP`<br/>
		/// - `IMG_INIT_JXL`<br/>
		/// - `IMG_INIT_AVIF`<br/>
		/// More flags may be added in a future SDL_image release.<br/>
		/// This function may need to load external shared libraries to support various<br/>
		/// codecs, which means this function can fail to initialize that support on an<br/>
		/// otherwise-reasonable system if the library isn't available; this is not<br/>
		/// just a question of exceptional circumstances like running out of memory at<br/>
		/// startup!<br/>
		/// Note that you may call this function more than once to initialize with<br/>
		/// additional flags. The return value will reflect both new flags that<br/>
		/// successfully initialized, and also include flags that had previously been<br/>
		/// initialized as well.<br/>
		/// As this will return previously-initialized flags, it's legal to call this<br/>
		/// with zero (no flags set). This is a safe no-op that can be used to query<br/>
		/// the current initialization state without changing it at all.<br/>
		/// Since this returns previously-initialized flags as well as new ones, and<br/>
		/// you can call this with zero, you should not check for a zero return value<br/>
		/// to determine an error condition. Instead, you should check to make sure all<br/>
		/// the flags you require are set in the return value. If you have a game with<br/>
		/// data in a specific format, this might be a fatal error. If you're a generic<br/>
		/// image displaying app, perhaps you are fine with only having JPG and PNG<br/>
		/// support and can live without WEBP, even if you request support for<br/>
		/// everything.<br/>
		/// Unlike other SDL satellite libraries, calls to IMG_Init do not stack; a<br/>
		/// single call to IMG_Quit() will deinitialize everything and does not have to<br/>
		/// be paired with a matching IMG_Init call. For that reason, it's considered<br/>
		/// best practices to have a single IMG_Init and IMG_Quit call in your program.<br/>
		/// While this isn't required, be aware of the risks of deviating from that<br/>
		/// behavior.<br/>
		/// After initializing SDL_image, the app may begin to load images into<br/>
		/// SDL_Surfaces or SDL_Textures.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_Init")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int InitNative([NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "int")] int flags)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, int>)funcTable[1])(flags);
			#else
			return (int)((delegate* unmanaged[Cdecl]<int, int>)funcTable[1])(flags);
			#endif
		}

		/// <summary>
		/// Initialize SDL_image.<br/>
		/// This function loads dynamic libraries that SDL_image needs, and prepares<br/>
		/// them for use. This must be the first function you call in SDL_image, and if<br/>
		/// it fails you should not continue with the library.<br/>
		/// Flags should be one or more flags from IMG_InitFlags OR'd together. It<br/>
		/// returns the flags successfully initialized, or 0 on failure.<br/>
		/// Currently, these flags are:<br/>
		/// - `IMG_INIT_JPG`<br/>
		/// - `IMG_INIT_PNG`<br/>
		/// - `IMG_INIT_TIF`<br/>
		/// - `IMG_INIT_WEBP`<br/>
		/// - `IMG_INIT_JXL`<br/>
		/// - `IMG_INIT_AVIF`<br/>
		/// More flags may be added in a future SDL_image release.<br/>
		/// This function may need to load external shared libraries to support various<br/>
		/// codecs, which means this function can fail to initialize that support on an<br/>
		/// otherwise-reasonable system if the library isn't available; this is not<br/>
		/// just a question of exceptional circumstances like running out of memory at<br/>
		/// startup!<br/>
		/// Note that you may call this function more than once to initialize with<br/>
		/// additional flags. The return value will reflect both new flags that<br/>
		/// successfully initialized, and also include flags that had previously been<br/>
		/// initialized as well.<br/>
		/// As this will return previously-initialized flags, it's legal to call this<br/>
		/// with zero (no flags set). This is a safe no-op that can be used to query<br/>
		/// the current initialization state without changing it at all.<br/>
		/// Since this returns previously-initialized flags as well as new ones, and<br/>
		/// you can call this with zero, you should not check for a zero return value<br/>
		/// to determine an error condition. Instead, you should check to make sure all<br/>
		/// the flags you require are set in the return value. If you have a game with<br/>
		/// data in a specific format, this might be a fatal error. If you're a generic<br/>
		/// image displaying app, perhaps you are fine with only having JPG and PNG<br/>
		/// support and can live without WEBP, even if you request support for<br/>
		/// everything.<br/>
		/// Unlike other SDL satellite libraries, calls to IMG_Init do not stack; a<br/>
		/// single call to IMG_Quit() will deinitialize everything and does not have to<br/>
		/// be paired with a matching IMG_Init call. For that reason, it's considered<br/>
		/// best practices to have a single IMG_Init and IMG_Quit call in your program.<br/>
		/// While this isn't required, be aware of the risks of deviating from that<br/>
		/// behavior.<br/>
		/// After initializing SDL_image, the app may begin to load images into<br/>
		/// SDL_Surfaces or SDL_Textures.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_Init")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Init([NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "int")] int flags)
		{
			int ret = InitNative(flags);
			return ret;
		}

		/// <summary>
		/// Deinitialize SDL_image.<br/>
		/// This should be the last function you call in SDL_image, after freeing all<br/>
		/// other resources. This will unload any shared libraries it is using for<br/>
		/// various codecs.<br/>
		/// After this call, a call to IMG_Init(0) will return 0 (no codecs loaded).<br/>
		/// You can safely call IMG_Init() to reload various codec support after this<br/>
		/// call.<br/>
		/// Unlike other SDL satellite libraries, calls to IMG_Init do not stack; a<br/>
		/// single call to IMG_Quit() will deinitialize everything and does not have to<br/>
		/// be paired with a matching IMG_Init call. For that reason, it's considered<br/>
		/// best practices to have a single IMG_Init and IMG_Quit call in your program.<br/>
		/// While this isn't required, be aware of the risks of deviating from that<br/>
		/// behavior.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_Quit")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void QuitNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[2])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[2])();
			#endif
		}

		/// <summary>
		/// Deinitialize SDL_image.<br/>
		/// This should be the last function you call in SDL_image, after freeing all<br/>
		/// other resources. This will unload any shared libraries it is using for<br/>
		/// various codecs.<br/>
		/// After this call, a call to IMG_Init(0) will return 0 (no codecs loaded).<br/>
		/// You can safely call IMG_Init() to reload various codec support after this<br/>
		/// call.<br/>
		/// Unlike other SDL satellite libraries, calls to IMG_Init do not stack; a<br/>
		/// single call to IMG_Quit() will deinitialize everything and does not have to<br/>
		/// be paired with a matching IMG_Init call. For that reason, it's considered<br/>
		/// best practices to have a single IMG_Init and IMG_Quit call in your program.<br/>
		/// While this isn't required, be aware of the risks of deviating from that<br/>
		/// behavior.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_Quit")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Quit()
		{
			QuitNative();
		}

		/// <summary>
		/// Load an image from an SDL data source into a software surface.<br/>
		/// An SDL_Surface is a buffer of pixels in memory accessible by the CPU. Use<br/>
		/// this if you plan to hand the data to something else or manipulate it<br/>
		/// further in code.<br/>
		/// There are no guarantees about what format the new SDL_Surface data will be;<br/>
		/// in many cases, SDL_image will attempt to supply a surface that exactly<br/>
		/// matches the provided image, but in others it might have to convert (either<br/>
		/// because the image is in a format that SDL doesn't directly support or<br/>
		/// because it's compressed data that could reasonably uncompress to various<br/>
		/// formats and SDL_image had to pick one). You can inspect an SDL_Surface for<br/>
		/// its specifics, and use SDL_ConvertSurface to then migrate to any supported<br/>
		/// format.<br/>
		/// If the image format supports a transparent pixel, SDL will set the colorkey<br/>
		/// for the surface. You can enable RLE acceleration on the surface afterwards<br/>
		/// by calling: SDL_SetColorKey(image, SDL_RLEACCEL, image->format->colorkey);<br/>
		/// If `freesrc` is non-zero, the RWops will be closed before returning,<br/>
		/// whether this function succeeds or not. SDL_image reads everything it needs<br/>
		/// from the RWops during this call in any case.<br/>
		/// Even though this function accepts a file type, SDL_image may still try<br/>
		/// other decoders that are capable of detecting file type from the contents of<br/>
		/// the image data, but may rely on the caller-provided type string for formats<br/>
		/// that it cannot autodetect. If `type` is NULL, SDL_image will rely solely on<br/>
		/// its ability to guess the format.<br/>
		/// There is a separate function to read files from disk without having to deal<br/>
		/// with SDL_RWops: `IMG_Load("filename.jpg")` will call this function and<br/>
		/// manage those details for you, determining the file type from the filename's<br/>
		/// extension.<br/>
		/// There is also IMG_Load_RW(), which is equivalent to this function except<br/>
		/// that it will rely on SDL_image to determine what type of data it is<br/>
		/// loading, much like passing a NULL for type.<br/>
		/// If you are using SDL's 2D rendering API, there is an equivalent call to<br/>
		/// load images directly into an SDL_Texture for use by the GPU without using a<br/>
		/// software surface: call IMG_LoadTextureTyped_RW() instead.<br/>
		/// When done with the returned surface, the app should dispose of it with a<br/>
		/// call to SDL_FreeSurface().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadTyped_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLSurface* LoadTypedRWNative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] SDLRWops* src, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "char const *")] byte* type)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, int, byte*, SDLSurface*>)funcTable[3])(src, freesrc, type);
			#else
			return (SDLSurface*)((delegate* unmanaged[Cdecl]<nint, int, nint, nint>)funcTable[3])((nint)src, freesrc, (nint)type);
			#endif
		}

		/// <summary>
		/// Load an image from an SDL data source into a software surface.<br/>
		/// An SDL_Surface is a buffer of pixels in memory accessible by the CPU. Use<br/>
		/// this if you plan to hand the data to something else or manipulate it<br/>
		/// further in code.<br/>
		/// There are no guarantees about what format the new SDL_Surface data will be;<br/>
		/// in many cases, SDL_image will attempt to supply a surface that exactly<br/>
		/// matches the provided image, but in others it might have to convert (either<br/>
		/// because the image is in a format that SDL doesn't directly support or<br/>
		/// because it's compressed data that could reasonably uncompress to various<br/>
		/// formats and SDL_image had to pick one). You can inspect an SDL_Surface for<br/>
		/// its specifics, and use SDL_ConvertSurface to then migrate to any supported<br/>
		/// format.<br/>
		/// If the image format supports a transparent pixel, SDL will set the colorkey<br/>
		/// for the surface. You can enable RLE acceleration on the surface afterwards<br/>
		/// by calling: SDL_SetColorKey(image, SDL_RLEACCEL, image->format->colorkey);<br/>
		/// If `freesrc` is non-zero, the RWops will be closed before returning,<br/>
		/// whether this function succeeds or not. SDL_image reads everything it needs<br/>
		/// from the RWops during this call in any case.<br/>
		/// Even though this function accepts a file type, SDL_image may still try<br/>
		/// other decoders that are capable of detecting file type from the contents of<br/>
		/// the image data, but may rely on the caller-provided type string for formats<br/>
		/// that it cannot autodetect. If `type` is NULL, SDL_image will rely solely on<br/>
		/// its ability to guess the format.<br/>
		/// There is a separate function to read files from disk without having to deal<br/>
		/// with SDL_RWops: `IMG_Load("filename.jpg")` will call this function and<br/>
		/// manage those details for you, determining the file type from the filename's<br/>
		/// extension.<br/>
		/// There is also IMG_Load_RW(), which is equivalent to this function except<br/>
		/// that it will rely on SDL_image to determine what type of data it is<br/>
		/// loading, much like passing a NULL for type.<br/>
		/// If you are using SDL's 2D rendering API, there is an equivalent call to<br/>
		/// load images directly into an SDL_Texture for use by the GPU without using a<br/>
		/// software surface: call IMG_LoadTextureTyped_RW() instead.<br/>
		/// When done with the returned surface, the app should dispose of it with a<br/>
		/// call to SDL_FreeSurface().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadTyped_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurface* LoadTypedRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] SDLRWops* src, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "char const *")] byte* type)
		{
			SDLSurface* ret = LoadTypedRWNative(src, freesrc, type);
			return ret;
		}

		/// <summary>
		/// Load an image from an SDL data source into a software surface.<br/>
		/// An SDL_Surface is a buffer of pixels in memory accessible by the CPU. Use<br/>
		/// this if you plan to hand the data to something else or manipulate it<br/>
		/// further in code.<br/>
		/// There are no guarantees about what format the new SDL_Surface data will be;<br/>
		/// in many cases, SDL_image will attempt to supply a surface that exactly<br/>
		/// matches the provided image, but in others it might have to convert (either<br/>
		/// because the image is in a format that SDL doesn't directly support or<br/>
		/// because it's compressed data that could reasonably uncompress to various<br/>
		/// formats and SDL_image had to pick one). You can inspect an SDL_Surface for<br/>
		/// its specifics, and use SDL_ConvertSurface to then migrate to any supported<br/>
		/// format.<br/>
		/// If the image format supports a transparent pixel, SDL will set the colorkey<br/>
		/// for the surface. You can enable RLE acceleration on the surface afterwards<br/>
		/// by calling: SDL_SetColorKey(image, SDL_RLEACCEL, image->format->colorkey);<br/>
		/// If `freesrc` is non-zero, the RWops will be closed before returning,<br/>
		/// whether this function succeeds or not. SDL_image reads everything it needs<br/>
		/// from the RWops during this call in any case.<br/>
		/// Even though this function accepts a file type, SDL_image may still try<br/>
		/// other decoders that are capable of detecting file type from the contents of<br/>
		/// the image data, but may rely on the caller-provided type string for formats<br/>
		/// that it cannot autodetect. If `type` is NULL, SDL_image will rely solely on<br/>
		/// its ability to guess the format.<br/>
		/// There is a separate function to read files from disk without having to deal<br/>
		/// with SDL_RWops: `IMG_Load("filename.jpg")` will call this function and<br/>
		/// manage those details for you, determining the file type from the filename's<br/>
		/// extension.<br/>
		/// There is also IMG_Load_RW(), which is equivalent to this function except<br/>
		/// that it will rely on SDL_image to determine what type of data it is<br/>
		/// loading, much like passing a NULL for type.<br/>
		/// If you are using SDL's 2D rendering API, there is an equivalent call to<br/>
		/// load images directly into an SDL_Texture for use by the GPU without using a<br/>
		/// software surface: call IMG_LoadTextureTyped_RW() instead.<br/>
		/// When done with the returned surface, the app should dispose of it with a<br/>
		/// call to SDL_FreeSurface().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadTyped_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurface* LoadTypedRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] ref SDLRWops src, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "char const *")] byte* type)
		{
			fixed (SDLRWops* psrc = &src)
			{
				SDLSurface* ret = LoadTypedRWNative((SDLRWops*)psrc, freesrc, type);
				return ret;
			}
		}

		/// <summary>
		/// Load an image from an SDL data source into a software surface.<br/>
		/// An SDL_Surface is a buffer of pixels in memory accessible by the CPU. Use<br/>
		/// this if you plan to hand the data to something else or manipulate it<br/>
		/// further in code.<br/>
		/// There are no guarantees about what format the new SDL_Surface data will be;<br/>
		/// in many cases, SDL_image will attempt to supply a surface that exactly<br/>
		/// matches the provided image, but in others it might have to convert (either<br/>
		/// because the image is in a format that SDL doesn't directly support or<br/>
		/// because it's compressed data that could reasonably uncompress to various<br/>
		/// formats and SDL_image had to pick one). You can inspect an SDL_Surface for<br/>
		/// its specifics, and use SDL_ConvertSurface to then migrate to any supported<br/>
		/// format.<br/>
		/// If the image format supports a transparent pixel, SDL will set the colorkey<br/>
		/// for the surface. You can enable RLE acceleration on the surface afterwards<br/>
		/// by calling: SDL_SetColorKey(image, SDL_RLEACCEL, image->format->colorkey);<br/>
		/// If `freesrc` is non-zero, the RWops will be closed before returning,<br/>
		/// whether this function succeeds or not. SDL_image reads everything it needs<br/>
		/// from the RWops during this call in any case.<br/>
		/// Even though this function accepts a file type, SDL_image may still try<br/>
		/// other decoders that are capable of detecting file type from the contents of<br/>
		/// the image data, but may rely on the caller-provided type string for formats<br/>
		/// that it cannot autodetect. If `type` is NULL, SDL_image will rely solely on<br/>
		/// its ability to guess the format.<br/>
		/// There is a separate function to read files from disk without having to deal<br/>
		/// with SDL_RWops: `IMG_Load("filename.jpg")` will call this function and<br/>
		/// manage those details for you, determining the file type from the filename's<br/>
		/// extension.<br/>
		/// There is also IMG_Load_RW(), which is equivalent to this function except<br/>
		/// that it will rely on SDL_image to determine what type of data it is<br/>
		/// loading, much like passing a NULL for type.<br/>
		/// If you are using SDL's 2D rendering API, there is an equivalent call to<br/>
		/// load images directly into an SDL_Texture for use by the GPU without using a<br/>
		/// software surface: call IMG_LoadTextureTyped_RW() instead.<br/>
		/// When done with the returned surface, the app should dispose of it with a<br/>
		/// call to SDL_FreeSurface().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadTyped_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurface* LoadTypedRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] SDLRWops* src, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "char const *")] ref byte type)
		{
			fixed (byte* ptype = &type)
			{
				SDLSurface* ret = LoadTypedRWNative(src, freesrc, (byte*)ptype);
				return ret;
			}
		}

		/// <summary>
		/// Load an image from an SDL data source into a software surface.<br/>
		/// An SDL_Surface is a buffer of pixels in memory accessible by the CPU. Use<br/>
		/// this if you plan to hand the data to something else or manipulate it<br/>
		/// further in code.<br/>
		/// There are no guarantees about what format the new SDL_Surface data will be;<br/>
		/// in many cases, SDL_image will attempt to supply a surface that exactly<br/>
		/// matches the provided image, but in others it might have to convert (either<br/>
		/// because the image is in a format that SDL doesn't directly support or<br/>
		/// because it's compressed data that could reasonably uncompress to various<br/>
		/// formats and SDL_image had to pick one). You can inspect an SDL_Surface for<br/>
		/// its specifics, and use SDL_ConvertSurface to then migrate to any supported<br/>
		/// format.<br/>
		/// If the image format supports a transparent pixel, SDL will set the colorkey<br/>
		/// for the surface. You can enable RLE acceleration on the surface afterwards<br/>
		/// by calling: SDL_SetColorKey(image, SDL_RLEACCEL, image->format->colorkey);<br/>
		/// If `freesrc` is non-zero, the RWops will be closed before returning,<br/>
		/// whether this function succeeds or not. SDL_image reads everything it needs<br/>
		/// from the RWops during this call in any case.<br/>
		/// Even though this function accepts a file type, SDL_image may still try<br/>
		/// other decoders that are capable of detecting file type from the contents of<br/>
		/// the image data, but may rely on the caller-provided type string for formats<br/>
		/// that it cannot autodetect. If `type` is NULL, SDL_image will rely solely on<br/>
		/// its ability to guess the format.<br/>
		/// There is a separate function to read files from disk without having to deal<br/>
		/// with SDL_RWops: `IMG_Load("filename.jpg")` will call this function and<br/>
		/// manage those details for you, determining the file type from the filename's<br/>
		/// extension.<br/>
		/// There is also IMG_Load_RW(), which is equivalent to this function except<br/>
		/// that it will rely on SDL_image to determine what type of data it is<br/>
		/// loading, much like passing a NULL for type.<br/>
		/// If you are using SDL's 2D rendering API, there is an equivalent call to<br/>
		/// load images directly into an SDL_Texture for use by the GPU without using a<br/>
		/// software surface: call IMG_LoadTextureTyped_RW() instead.<br/>
		/// When done with the returned surface, the app should dispose of it with a<br/>
		/// call to SDL_FreeSurface().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadTyped_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurface* LoadTypedRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] SDLRWops* src, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> type)
		{
			fixed (byte* ptype = type)
			{
				SDLSurface* ret = LoadTypedRWNative(src, freesrc, (byte*)ptype);
				return ret;
			}
		}

		/// <summary>
		/// Load an image from an SDL data source into a software surface.<br/>
		/// An SDL_Surface is a buffer of pixels in memory accessible by the CPU. Use<br/>
		/// this if you plan to hand the data to something else or manipulate it<br/>
		/// further in code.<br/>
		/// There are no guarantees about what format the new SDL_Surface data will be;<br/>
		/// in many cases, SDL_image will attempt to supply a surface that exactly<br/>
		/// matches the provided image, but in others it might have to convert (either<br/>
		/// because the image is in a format that SDL doesn't directly support or<br/>
		/// because it's compressed data that could reasonably uncompress to various<br/>
		/// formats and SDL_image had to pick one). You can inspect an SDL_Surface for<br/>
		/// its specifics, and use SDL_ConvertSurface to then migrate to any supported<br/>
		/// format.<br/>
		/// If the image format supports a transparent pixel, SDL will set the colorkey<br/>
		/// for the surface. You can enable RLE acceleration on the surface afterwards<br/>
		/// by calling: SDL_SetColorKey(image, SDL_RLEACCEL, image->format->colorkey);<br/>
		/// If `freesrc` is non-zero, the RWops will be closed before returning,<br/>
		/// whether this function succeeds or not. SDL_image reads everything it needs<br/>
		/// from the RWops during this call in any case.<br/>
		/// Even though this function accepts a file type, SDL_image may still try<br/>
		/// other decoders that are capable of detecting file type from the contents of<br/>
		/// the image data, but may rely on the caller-provided type string for formats<br/>
		/// that it cannot autodetect. If `type` is NULL, SDL_image will rely solely on<br/>
		/// its ability to guess the format.<br/>
		/// There is a separate function to read files from disk without having to deal<br/>
		/// with SDL_RWops: `IMG_Load("filename.jpg")` will call this function and<br/>
		/// manage those details for you, determining the file type from the filename's<br/>
		/// extension.<br/>
		/// There is also IMG_Load_RW(), which is equivalent to this function except<br/>
		/// that it will rely on SDL_image to determine what type of data it is<br/>
		/// loading, much like passing a NULL for type.<br/>
		/// If you are using SDL's 2D rendering API, there is an equivalent call to<br/>
		/// load images directly into an SDL_Texture for use by the GPU without using a<br/>
		/// software surface: call IMG_LoadTextureTyped_RW() instead.<br/>
		/// When done with the returned surface, the app should dispose of it with a<br/>
		/// call to SDL_FreeSurface().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadTyped_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurface* LoadTypedRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] SDLRWops* src, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "char const *")] string type)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (type != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(type);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(type, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLSurface* ret = LoadTypedRWNative(src, freesrc, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Load an image from an SDL data source into a software surface.<br/>
		/// An SDL_Surface is a buffer of pixels in memory accessible by the CPU. Use<br/>
		/// this if you plan to hand the data to something else or manipulate it<br/>
		/// further in code.<br/>
		/// There are no guarantees about what format the new SDL_Surface data will be;<br/>
		/// in many cases, SDL_image will attempt to supply a surface that exactly<br/>
		/// matches the provided image, but in others it might have to convert (either<br/>
		/// because the image is in a format that SDL doesn't directly support or<br/>
		/// because it's compressed data that could reasonably uncompress to various<br/>
		/// formats and SDL_image had to pick one). You can inspect an SDL_Surface for<br/>
		/// its specifics, and use SDL_ConvertSurface to then migrate to any supported<br/>
		/// format.<br/>
		/// If the image format supports a transparent pixel, SDL will set the colorkey<br/>
		/// for the surface. You can enable RLE acceleration on the surface afterwards<br/>
		/// by calling: SDL_SetColorKey(image, SDL_RLEACCEL, image->format->colorkey);<br/>
		/// If `freesrc` is non-zero, the RWops will be closed before returning,<br/>
		/// whether this function succeeds or not. SDL_image reads everything it needs<br/>
		/// from the RWops during this call in any case.<br/>
		/// Even though this function accepts a file type, SDL_image may still try<br/>
		/// other decoders that are capable of detecting file type from the contents of<br/>
		/// the image data, but may rely on the caller-provided type string for formats<br/>
		/// that it cannot autodetect. If `type` is NULL, SDL_image will rely solely on<br/>
		/// its ability to guess the format.<br/>
		/// There is a separate function to read files from disk without having to deal<br/>
		/// with SDL_RWops: `IMG_Load("filename.jpg")` will call this function and<br/>
		/// manage those details for you, determining the file type from the filename's<br/>
		/// extension.<br/>
		/// There is also IMG_Load_RW(), which is equivalent to this function except<br/>
		/// that it will rely on SDL_image to determine what type of data it is<br/>
		/// loading, much like passing a NULL for type.<br/>
		/// If you are using SDL's 2D rendering API, there is an equivalent call to<br/>
		/// load images directly into an SDL_Texture for use by the GPU without using a<br/>
		/// software surface: call IMG_LoadTextureTyped_RW() instead.<br/>
		/// When done with the returned surface, the app should dispose of it with a<br/>
		/// call to SDL_FreeSurface().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadTyped_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurface* LoadTypedRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] ref SDLRWops src, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "char const *")] ref byte type)
		{
			fixed (SDLRWops* psrc = &src)
			{
				fixed (byte* ptype = &type)
				{
					SDLSurface* ret = LoadTypedRWNative((SDLRWops*)psrc, freesrc, (byte*)ptype);
					return ret;
				}
			}
		}

		/// <summary>
		/// Load an image from an SDL data source into a software surface.<br/>
		/// An SDL_Surface is a buffer of pixels in memory accessible by the CPU. Use<br/>
		/// this if you plan to hand the data to something else or manipulate it<br/>
		/// further in code.<br/>
		/// There are no guarantees about what format the new SDL_Surface data will be;<br/>
		/// in many cases, SDL_image will attempt to supply a surface that exactly<br/>
		/// matches the provided image, but in others it might have to convert (either<br/>
		/// because the image is in a format that SDL doesn't directly support or<br/>
		/// because it's compressed data that could reasonably uncompress to various<br/>
		/// formats and SDL_image had to pick one). You can inspect an SDL_Surface for<br/>
		/// its specifics, and use SDL_ConvertSurface to then migrate to any supported<br/>
		/// format.<br/>
		/// If the image format supports a transparent pixel, SDL will set the colorkey<br/>
		/// for the surface. You can enable RLE acceleration on the surface afterwards<br/>
		/// by calling: SDL_SetColorKey(image, SDL_RLEACCEL, image->format->colorkey);<br/>
		/// If `freesrc` is non-zero, the RWops will be closed before returning,<br/>
		/// whether this function succeeds or not. SDL_image reads everything it needs<br/>
		/// from the RWops during this call in any case.<br/>
		/// Even though this function accepts a file type, SDL_image may still try<br/>
		/// other decoders that are capable of detecting file type from the contents of<br/>
		/// the image data, but may rely on the caller-provided type string for formats<br/>
		/// that it cannot autodetect. If `type` is NULL, SDL_image will rely solely on<br/>
		/// its ability to guess the format.<br/>
		/// There is a separate function to read files from disk without having to deal<br/>
		/// with SDL_RWops: `IMG_Load("filename.jpg")` will call this function and<br/>
		/// manage those details for you, determining the file type from the filename's<br/>
		/// extension.<br/>
		/// There is also IMG_Load_RW(), which is equivalent to this function except<br/>
		/// that it will rely on SDL_image to determine what type of data it is<br/>
		/// loading, much like passing a NULL for type.<br/>
		/// If you are using SDL's 2D rendering API, there is an equivalent call to<br/>
		/// load images directly into an SDL_Texture for use by the GPU without using a<br/>
		/// software surface: call IMG_LoadTextureTyped_RW() instead.<br/>
		/// When done with the returned surface, the app should dispose of it with a<br/>
		/// call to SDL_FreeSurface().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadTyped_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurface* LoadTypedRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] ref SDLRWops src, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> type)
		{
			fixed (SDLRWops* psrc = &src)
			{
				fixed (byte* ptype = type)
				{
					SDLSurface* ret = LoadTypedRWNative((SDLRWops*)psrc, freesrc, (byte*)ptype);
					return ret;
				}
			}
		}

		/// <summary>
		/// Load an image from an SDL data source into a software surface.<br/>
		/// An SDL_Surface is a buffer of pixels in memory accessible by the CPU. Use<br/>
		/// this if you plan to hand the data to something else or manipulate it<br/>
		/// further in code.<br/>
		/// There are no guarantees about what format the new SDL_Surface data will be;<br/>
		/// in many cases, SDL_image will attempt to supply a surface that exactly<br/>
		/// matches the provided image, but in others it might have to convert (either<br/>
		/// because the image is in a format that SDL doesn't directly support or<br/>
		/// because it's compressed data that could reasonably uncompress to various<br/>
		/// formats and SDL_image had to pick one). You can inspect an SDL_Surface for<br/>
		/// its specifics, and use SDL_ConvertSurface to then migrate to any supported<br/>
		/// format.<br/>
		/// If the image format supports a transparent pixel, SDL will set the colorkey<br/>
		/// for the surface. You can enable RLE acceleration on the surface afterwards<br/>
		/// by calling: SDL_SetColorKey(image, SDL_RLEACCEL, image->format->colorkey);<br/>
		/// If `freesrc` is non-zero, the RWops will be closed before returning,<br/>
		/// whether this function succeeds or not. SDL_image reads everything it needs<br/>
		/// from the RWops during this call in any case.<br/>
		/// Even though this function accepts a file type, SDL_image may still try<br/>
		/// other decoders that are capable of detecting file type from the contents of<br/>
		/// the image data, but may rely on the caller-provided type string for formats<br/>
		/// that it cannot autodetect. If `type` is NULL, SDL_image will rely solely on<br/>
		/// its ability to guess the format.<br/>
		/// There is a separate function to read files from disk without having to deal<br/>
		/// with SDL_RWops: `IMG_Load("filename.jpg")` will call this function and<br/>
		/// manage those details for you, determining the file type from the filename's<br/>
		/// extension.<br/>
		/// There is also IMG_Load_RW(), which is equivalent to this function except<br/>
		/// that it will rely on SDL_image to determine what type of data it is<br/>
		/// loading, much like passing a NULL for type.<br/>
		/// If you are using SDL's 2D rendering API, there is an equivalent call to<br/>
		/// load images directly into an SDL_Texture for use by the GPU without using a<br/>
		/// software surface: call IMG_LoadTextureTyped_RW() instead.<br/>
		/// When done with the returned surface, the app should dispose of it with a<br/>
		/// call to SDL_FreeSurface().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadTyped_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurface* LoadTypedRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] ref SDLRWops src, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "char const *")] string type)
		{
			fixed (SDLRWops* psrc = &src)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (type != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(type);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(type, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				SDLSurface* ret = LoadTypedRWNative((SDLRWops*)psrc, freesrc, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// Load an image from a filesystem path into a software surface.<br/>
		/// An SDL_Surface is a buffer of pixels in memory accessible by the CPU. Use<br/>
		/// this if you plan to hand the data to something else or manipulate it<br/>
		/// further in code.<br/>
		/// There are no guarantees about what format the new SDL_Surface data will be;<br/>
		/// in many cases, SDL_image will attempt to supply a surface that exactly<br/>
		/// matches the provided image, but in others it might have to convert (either<br/>
		/// because the image is in a format that SDL doesn't directly support or<br/>
		/// because it's compressed data that could reasonably uncompress to various<br/>
		/// formats and SDL_image had to pick one). You can inspect an SDL_Surface for<br/>
		/// its specifics, and use SDL_ConvertSurface to then migrate to any supported<br/>
		/// format.<br/>
		/// If the image format supports a transparent pixel, SDL will set the colorkey<br/>
		/// for the surface. You can enable RLE acceleration on the surface afterwards<br/>
		/// by calling: SDL_SetColorKey(image, SDL_RLEACCEL, image->format->colorkey);<br/>
		/// There is a separate function to read files from an SDL_RWops, if you need<br/>
		/// an i/o abstraction to provide data from anywhere instead of a simple<br/>
		/// filesystem read; that function is IMG_Load_RW().<br/>
		/// If you are using SDL's 2D rendering API, there is an equivalent call to<br/>
		/// load images directly into an SDL_Texture for use by the GPU without using a<br/>
		/// software surface: call IMG_LoadTexture() instead.<br/>
		/// When done with the returned surface, the app should dispose of it with a<br/>
		/// call to SDL_FreeSurface().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_Load")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLSurface* LoadNative([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] byte* file)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, SDLSurface*>)funcTable[4])(file);
			#else
			return (SDLSurface*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[4])((nint)file);
			#endif
		}

		/// <summary>
		/// Load an image from a filesystem path into a software surface.<br/>
		/// An SDL_Surface is a buffer of pixels in memory accessible by the CPU. Use<br/>
		/// this if you plan to hand the data to something else or manipulate it<br/>
		/// further in code.<br/>
		/// There are no guarantees about what format the new SDL_Surface data will be;<br/>
		/// in many cases, SDL_image will attempt to supply a surface that exactly<br/>
		/// matches the provided image, but in others it might have to convert (either<br/>
		/// because the image is in a format that SDL doesn't directly support or<br/>
		/// because it's compressed data that could reasonably uncompress to various<br/>
		/// formats and SDL_image had to pick one). You can inspect an SDL_Surface for<br/>
		/// its specifics, and use SDL_ConvertSurface to then migrate to any supported<br/>
		/// format.<br/>
		/// If the image format supports a transparent pixel, SDL will set the colorkey<br/>
		/// for the surface. You can enable RLE acceleration on the surface afterwards<br/>
		/// by calling: SDL_SetColorKey(image, SDL_RLEACCEL, image->format->colorkey);<br/>
		/// There is a separate function to read files from an SDL_RWops, if you need<br/>
		/// an i/o abstraction to provide data from anywhere instead of a simple<br/>
		/// filesystem read; that function is IMG_Load_RW().<br/>
		/// If you are using SDL's 2D rendering API, there is an equivalent call to<br/>
		/// load images directly into an SDL_Texture for use by the GPU without using a<br/>
		/// software surface: call IMG_LoadTexture() instead.<br/>
		/// When done with the returned surface, the app should dispose of it with a<br/>
		/// call to SDL_FreeSurface().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_Load")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurface* Load([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] byte* file)
		{
			SDLSurface* ret = LoadNative(file);
			return ret;
		}

		/// <summary>
		/// Load an image from a filesystem path into a software surface.<br/>
		/// An SDL_Surface is a buffer of pixels in memory accessible by the CPU. Use<br/>
		/// this if you plan to hand the data to something else or manipulate it<br/>
		/// further in code.<br/>
		/// There are no guarantees about what format the new SDL_Surface data will be;<br/>
		/// in many cases, SDL_image will attempt to supply a surface that exactly<br/>
		/// matches the provided image, but in others it might have to convert (either<br/>
		/// because the image is in a format that SDL doesn't directly support or<br/>
		/// because it's compressed data that could reasonably uncompress to various<br/>
		/// formats and SDL_image had to pick one). You can inspect an SDL_Surface for<br/>
		/// its specifics, and use SDL_ConvertSurface to then migrate to any supported<br/>
		/// format.<br/>
		/// If the image format supports a transparent pixel, SDL will set the colorkey<br/>
		/// for the surface. You can enable RLE acceleration on the surface afterwards<br/>
		/// by calling: SDL_SetColorKey(image, SDL_RLEACCEL, image->format->colorkey);<br/>
		/// There is a separate function to read files from an SDL_RWops, if you need<br/>
		/// an i/o abstraction to provide data from anywhere instead of a simple<br/>
		/// filesystem read; that function is IMG_Load_RW().<br/>
		/// If you are using SDL's 2D rendering API, there is an equivalent call to<br/>
		/// load images directly into an SDL_Texture for use by the GPU without using a<br/>
		/// software surface: call IMG_LoadTexture() instead.<br/>
		/// When done with the returned surface, the app should dispose of it with a<br/>
		/// call to SDL_FreeSurface().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_Load")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurface* Load([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] ref byte file)
		{
			fixed (byte* pfile = &file)
			{
				SDLSurface* ret = LoadNative((byte*)pfile);
				return ret;
			}
		}

		/// <summary>
		/// Load an image from a filesystem path into a software surface.<br/>
		/// An SDL_Surface is a buffer of pixels in memory accessible by the CPU. Use<br/>
		/// this if you plan to hand the data to something else or manipulate it<br/>
		/// further in code.<br/>
		/// There are no guarantees about what format the new SDL_Surface data will be;<br/>
		/// in many cases, SDL_image will attempt to supply a surface that exactly<br/>
		/// matches the provided image, but in others it might have to convert (either<br/>
		/// because the image is in a format that SDL doesn't directly support or<br/>
		/// because it's compressed data that could reasonably uncompress to various<br/>
		/// formats and SDL_image had to pick one). You can inspect an SDL_Surface for<br/>
		/// its specifics, and use SDL_ConvertSurface to then migrate to any supported<br/>
		/// format.<br/>
		/// If the image format supports a transparent pixel, SDL will set the colorkey<br/>
		/// for the surface. You can enable RLE acceleration on the surface afterwards<br/>
		/// by calling: SDL_SetColorKey(image, SDL_RLEACCEL, image->format->colorkey);<br/>
		/// There is a separate function to read files from an SDL_RWops, if you need<br/>
		/// an i/o abstraction to provide data from anywhere instead of a simple<br/>
		/// filesystem read; that function is IMG_Load_RW().<br/>
		/// If you are using SDL's 2D rendering API, there is an equivalent call to<br/>
		/// load images directly into an SDL_Texture for use by the GPU without using a<br/>
		/// software surface: call IMG_LoadTexture() instead.<br/>
		/// When done with the returned surface, the app should dispose of it with a<br/>
		/// call to SDL_FreeSurface().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_Load")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurface* Load([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> file)
		{
			fixed (byte* pfile = file)
			{
				SDLSurface* ret = LoadNative((byte*)pfile);
				return ret;
			}
		}

		/// <summary>
		/// Load an image from a filesystem path into a software surface.<br/>
		/// An SDL_Surface is a buffer of pixels in memory accessible by the CPU. Use<br/>
		/// this if you plan to hand the data to something else or manipulate it<br/>
		/// further in code.<br/>
		/// There are no guarantees about what format the new SDL_Surface data will be;<br/>
		/// in many cases, SDL_image will attempt to supply a surface that exactly<br/>
		/// matches the provided image, but in others it might have to convert (either<br/>
		/// because the image is in a format that SDL doesn't directly support or<br/>
		/// because it's compressed data that could reasonably uncompress to various<br/>
		/// formats and SDL_image had to pick one). You can inspect an SDL_Surface for<br/>
		/// its specifics, and use SDL_ConvertSurface to then migrate to any supported<br/>
		/// format.<br/>
		/// If the image format supports a transparent pixel, SDL will set the colorkey<br/>
		/// for the surface. You can enable RLE acceleration on the surface afterwards<br/>
		/// by calling: SDL_SetColorKey(image, SDL_RLEACCEL, image->format->colorkey);<br/>
		/// There is a separate function to read files from an SDL_RWops, if you need<br/>
		/// an i/o abstraction to provide data from anywhere instead of a simple<br/>
		/// filesystem read; that function is IMG_Load_RW().<br/>
		/// If you are using SDL's 2D rendering API, there is an equivalent call to<br/>
		/// load images directly into an SDL_Texture for use by the GPU without using a<br/>
		/// software surface: call IMG_LoadTexture() instead.<br/>
		/// When done with the returned surface, the app should dispose of it with a<br/>
		/// call to SDL_FreeSurface().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_Load")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurface* Load([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] string file)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (file != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(file);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(file, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLSurface* ret = LoadNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Load an image from an SDL data source into a software surface.<br/>
		/// An SDL_Surface is a buffer of pixels in memory accessible by the CPU. Use<br/>
		/// this if you plan to hand the data to something else or manipulate it<br/>
		/// further in code.<br/>
		/// There are no guarantees about what format the new SDL_Surface data will be;<br/>
		/// in many cases, SDL_image will attempt to supply a surface that exactly<br/>
		/// matches the provided image, but in others it might have to convert (either<br/>
		/// because the image is in a format that SDL doesn't directly support or<br/>
		/// because it's compressed data that could reasonably uncompress to various<br/>
		/// formats and SDL_image had to pick one). You can inspect an SDL_Surface for<br/>
		/// its specifics, and use SDL_ConvertSurface to then migrate to any supported<br/>
		/// format.<br/>
		/// If the image format supports a transparent pixel, SDL will set the colorkey<br/>
		/// for the surface. You can enable RLE acceleration on the surface afterwards<br/>
		/// by calling: SDL_SetColorKey(image, SDL_RLEACCEL, image->format->colorkey);<br/>
		/// If `freesrc` is non-zero, the RWops will be closed before returning,<br/>
		/// whether this function succeeds or not. SDL_image reads everything it needs<br/>
		/// from the RWops during this call in any case.<br/>
		/// There is a separate function to read files from disk without having to deal<br/>
		/// with SDL_RWops: `IMG_Load("filename.jpg")` will call this function and<br/>
		/// manage those details for you, determining the file type from the filename's<br/>
		/// extension.<br/>
		/// There is also IMG_LoadTyped_RW(), which is equivalent to this function<br/>
		/// except a file extension (like "BMP", "JPG", etc) can be specified, in case<br/>
		/// SDL_image cannot autodetect the file format.<br/>
		/// If you are using SDL's 2D rendering API, there is an equivalent call to<br/>
		/// load images directly into an SDL_Texture for use by the GPU without using a<br/>
		/// software surface: call IMG_LoadTexture_RW() instead.<br/>
		/// When done with the returned surface, the app should dispose of it with a<br/>
		/// call to SDL_FreeSurface().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_Load_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLSurface* LoadRWNative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] SDLRWops* src, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, int, SDLSurface*>)funcTable[5])(src, freesrc);
			#else
			return (SDLSurface*)((delegate* unmanaged[Cdecl]<nint, int, nint>)funcTable[5])((nint)src, freesrc);
			#endif
		}

		/// <summary>
		/// Load an image from an SDL data source into a software surface.<br/>
		/// An SDL_Surface is a buffer of pixels in memory accessible by the CPU. Use<br/>
		/// this if you plan to hand the data to something else or manipulate it<br/>
		/// further in code.<br/>
		/// There are no guarantees about what format the new SDL_Surface data will be;<br/>
		/// in many cases, SDL_image will attempt to supply a surface that exactly<br/>
		/// matches the provided image, but in others it might have to convert (either<br/>
		/// because the image is in a format that SDL doesn't directly support or<br/>
		/// because it's compressed data that could reasonably uncompress to various<br/>
		/// formats and SDL_image had to pick one). You can inspect an SDL_Surface for<br/>
		/// its specifics, and use SDL_ConvertSurface to then migrate to any supported<br/>
		/// format.<br/>
		/// If the image format supports a transparent pixel, SDL will set the colorkey<br/>
		/// for the surface. You can enable RLE acceleration on the surface afterwards<br/>
		/// by calling: SDL_SetColorKey(image, SDL_RLEACCEL, image->format->colorkey);<br/>
		/// If `freesrc` is non-zero, the RWops will be closed before returning,<br/>
		/// whether this function succeeds or not. SDL_image reads everything it needs<br/>
		/// from the RWops during this call in any case.<br/>
		/// There is a separate function to read files from disk without having to deal<br/>
		/// with SDL_RWops: `IMG_Load("filename.jpg")` will call this function and<br/>
		/// manage those details for you, determining the file type from the filename's<br/>
		/// extension.<br/>
		/// There is also IMG_LoadTyped_RW(), which is equivalent to this function<br/>
		/// except a file extension (like "BMP", "JPG", etc) can be specified, in case<br/>
		/// SDL_image cannot autodetect the file format.<br/>
		/// If you are using SDL's 2D rendering API, there is an equivalent call to<br/>
		/// load images directly into an SDL_Texture for use by the GPU without using a<br/>
		/// software surface: call IMG_LoadTexture_RW() instead.<br/>
		/// When done with the returned surface, the app should dispose of it with a<br/>
		/// call to SDL_FreeSurface().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_Load_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurface* LoadRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] SDLRWops* src, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc)
		{
			SDLSurface* ret = LoadRWNative(src, freesrc);
			return ret;
		}

		/// <summary>
		/// Load an image from an SDL data source into a software surface.<br/>
		/// An SDL_Surface is a buffer of pixels in memory accessible by the CPU. Use<br/>
		/// this if you plan to hand the data to something else or manipulate it<br/>
		/// further in code.<br/>
		/// There are no guarantees about what format the new SDL_Surface data will be;<br/>
		/// in many cases, SDL_image will attempt to supply a surface that exactly<br/>
		/// matches the provided image, but in others it might have to convert (either<br/>
		/// because the image is in a format that SDL doesn't directly support or<br/>
		/// because it's compressed data that could reasonably uncompress to various<br/>
		/// formats and SDL_image had to pick one). You can inspect an SDL_Surface for<br/>
		/// its specifics, and use SDL_ConvertSurface to then migrate to any supported<br/>
		/// format.<br/>
		/// If the image format supports a transparent pixel, SDL will set the colorkey<br/>
		/// for the surface. You can enable RLE acceleration on the surface afterwards<br/>
		/// by calling: SDL_SetColorKey(image, SDL_RLEACCEL, image->format->colorkey);<br/>
		/// If `freesrc` is non-zero, the RWops will be closed before returning,<br/>
		/// whether this function succeeds or not. SDL_image reads everything it needs<br/>
		/// from the RWops during this call in any case.<br/>
		/// There is a separate function to read files from disk without having to deal<br/>
		/// with SDL_RWops: `IMG_Load("filename.jpg")` will call this function and<br/>
		/// manage those details for you, determining the file type from the filename's<br/>
		/// extension.<br/>
		/// There is also IMG_LoadTyped_RW(), which is equivalent to this function<br/>
		/// except a file extension (like "BMP", "JPG", etc) can be specified, in case<br/>
		/// SDL_image cannot autodetect the file format.<br/>
		/// If you are using SDL's 2D rendering API, there is an equivalent call to<br/>
		/// load images directly into an SDL_Texture for use by the GPU without using a<br/>
		/// software surface: call IMG_LoadTexture_RW() instead.<br/>
		/// When done with the returned surface, the app should dispose of it with a<br/>
		/// call to SDL_FreeSurface().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_Load_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurface* LoadRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] ref SDLRWops src, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc)
		{
			fixed (SDLRWops* psrc = &src)
			{
				SDLSurface* ret = LoadRWNative((SDLRWops*)psrc, freesrc);
				return ret;
			}
		}

		/// <summary>
		/// Load an image from a filesystem path into a GPU texture.<br/>
		/// An SDL_Texture represents an image in GPU memory, usable by SDL's 2D Render<br/>
		/// API. This can be significantly more efficient than using a CPU-bound<br/>
		/// SDL_Surface if you don't need to manipulate the image directly after<br/>
		/// loading it.<br/>
		/// If the loaded image has transparency or a colorkey, a texture with an alpha<br/>
		/// channel will be created. Otherwise, SDL_image will attempt to create an<br/>
		/// SDL_Texture in the most format that most reasonably represents the image<br/>
		/// data (but in many cases, this will just end up being 32-bit RGB or 32-bit<br/>
		/// RGBA).<br/>
		/// There is a separate function to read files from an SDL_RWops, if you need<br/>
		/// an i/o abstraction to provide data from anywhere instead of a simple<br/>
		/// filesystem read; that function is IMG_LoadTexture_RW().<br/>
		/// If you would rather decode an image to an SDL_Surface (a buffer of pixels<br/>
		/// in CPU memory), call IMG_Load() instead.<br/>
		/// When done with the returned texture, the app should dispose of it with a<br/>
		/// call to SDL_DestroyTexture().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadTexture")]
		[return: NativeName(NativeNameType.Type, "SDL_Texture *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLTexture* LoadTextureNative([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer *")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] byte* file)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRenderer*, byte*, SDLTexture*>)funcTable[6])(renderer, file);
			#else
			return (SDLTexture*)((delegate* unmanaged[Cdecl]<nint, nint, nint>)funcTable[6])((nint)renderer, (nint)file);
			#endif
		}

		/// <summary>
		/// Load an image from a filesystem path into a GPU texture.<br/>
		/// An SDL_Texture represents an image in GPU memory, usable by SDL's 2D Render<br/>
		/// API. This can be significantly more efficient than using a CPU-bound<br/>
		/// SDL_Surface if you don't need to manipulate the image directly after<br/>
		/// loading it.<br/>
		/// If the loaded image has transparency or a colorkey, a texture with an alpha<br/>
		/// channel will be created. Otherwise, SDL_image will attempt to create an<br/>
		/// SDL_Texture in the most format that most reasonably represents the image<br/>
		/// data (but in many cases, this will just end up being 32-bit RGB or 32-bit<br/>
		/// RGBA).<br/>
		/// There is a separate function to read files from an SDL_RWops, if you need<br/>
		/// an i/o abstraction to provide data from anywhere instead of a simple<br/>
		/// filesystem read; that function is IMG_LoadTexture_RW().<br/>
		/// If you would rather decode an image to an SDL_Surface (a buffer of pixels<br/>
		/// in CPU memory), call IMG_Load() instead.<br/>
		/// When done with the returned texture, the app should dispose of it with a<br/>
		/// call to SDL_DestroyTexture().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadTexture")]
		[return: NativeName(NativeNameType.Type, "SDL_Texture *")]
		public static SDLTexture* LoadTexture([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer *")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] byte* file)
		{
			SDLTexture* ret = LoadTextureNative(renderer, file);
			return ret;
		}

		/// <summary>
		/// Load an image from a filesystem path into a GPU texture.<br/>
		/// An SDL_Texture represents an image in GPU memory, usable by SDL's 2D Render<br/>
		/// API. This can be significantly more efficient than using a CPU-bound<br/>
		/// SDL_Surface if you don't need to manipulate the image directly after<br/>
		/// loading it.<br/>
		/// If the loaded image has transparency or a colorkey, a texture with an alpha<br/>
		/// channel will be created. Otherwise, SDL_image will attempt to create an<br/>
		/// SDL_Texture in the most format that most reasonably represents the image<br/>
		/// data (but in many cases, this will just end up being 32-bit RGB or 32-bit<br/>
		/// RGBA).<br/>
		/// There is a separate function to read files from an SDL_RWops, if you need<br/>
		/// an i/o abstraction to provide data from anywhere instead of a simple<br/>
		/// filesystem read; that function is IMG_LoadTexture_RW().<br/>
		/// If you would rather decode an image to an SDL_Surface (a buffer of pixels<br/>
		/// in CPU memory), call IMG_Load() instead.<br/>
		/// When done with the returned texture, the app should dispose of it with a<br/>
		/// call to SDL_DestroyTexture().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadTexture")]
		[return: NativeName(NativeNameType.Type, "SDL_Texture *")]
		public static SDLTexture* LoadTexture([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer *")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] byte* file)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				SDLTexture* ret = LoadTextureNative((SDLRenderer*)prenderer, file);
				return ret;
			}
		}

		/// <summary>
		/// Load an image from a filesystem path into a GPU texture.<br/>
		/// An SDL_Texture represents an image in GPU memory, usable by SDL's 2D Render<br/>
		/// API. This can be significantly more efficient than using a CPU-bound<br/>
		/// SDL_Surface if you don't need to manipulate the image directly after<br/>
		/// loading it.<br/>
		/// If the loaded image has transparency or a colorkey, a texture with an alpha<br/>
		/// channel will be created. Otherwise, SDL_image will attempt to create an<br/>
		/// SDL_Texture in the most format that most reasonably represents the image<br/>
		/// data (but in many cases, this will just end up being 32-bit RGB or 32-bit<br/>
		/// RGBA).<br/>
		/// There is a separate function to read files from an SDL_RWops, if you need<br/>
		/// an i/o abstraction to provide data from anywhere instead of a simple<br/>
		/// filesystem read; that function is IMG_LoadTexture_RW().<br/>
		/// If you would rather decode an image to an SDL_Surface (a buffer of pixels<br/>
		/// in CPU memory), call IMG_Load() instead.<br/>
		/// When done with the returned texture, the app should dispose of it with a<br/>
		/// call to SDL_DestroyTexture().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadTexture")]
		[return: NativeName(NativeNameType.Type, "SDL_Texture *")]
		public static SDLTexture* LoadTexture([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer *")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] ref byte file)
		{
			fixed (byte* pfile = &file)
			{
				SDLTexture* ret = LoadTextureNative(renderer, (byte*)pfile);
				return ret;
			}
		}

		/// <summary>
		/// Load an image from a filesystem path into a GPU texture.<br/>
		/// An SDL_Texture represents an image in GPU memory, usable by SDL's 2D Render<br/>
		/// API. This can be significantly more efficient than using a CPU-bound<br/>
		/// SDL_Surface if you don't need to manipulate the image directly after<br/>
		/// loading it.<br/>
		/// If the loaded image has transparency or a colorkey, a texture with an alpha<br/>
		/// channel will be created. Otherwise, SDL_image will attempt to create an<br/>
		/// SDL_Texture in the most format that most reasonably represents the image<br/>
		/// data (but in many cases, this will just end up being 32-bit RGB or 32-bit<br/>
		/// RGBA).<br/>
		/// There is a separate function to read files from an SDL_RWops, if you need<br/>
		/// an i/o abstraction to provide data from anywhere instead of a simple<br/>
		/// filesystem read; that function is IMG_LoadTexture_RW().<br/>
		/// If you would rather decode an image to an SDL_Surface (a buffer of pixels<br/>
		/// in CPU memory), call IMG_Load() instead.<br/>
		/// When done with the returned texture, the app should dispose of it with a<br/>
		/// call to SDL_DestroyTexture().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadTexture")]
		[return: NativeName(NativeNameType.Type, "SDL_Texture *")]
		public static SDLTexture* LoadTexture([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer *")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> file)
		{
			fixed (byte* pfile = file)
			{
				SDLTexture* ret = LoadTextureNative(renderer, (byte*)pfile);
				return ret;
			}
		}

		/// <summary>
		/// Load an image from a filesystem path into a GPU texture.<br/>
		/// An SDL_Texture represents an image in GPU memory, usable by SDL's 2D Render<br/>
		/// API. This can be significantly more efficient than using a CPU-bound<br/>
		/// SDL_Surface if you don't need to manipulate the image directly after<br/>
		/// loading it.<br/>
		/// If the loaded image has transparency or a colorkey, a texture with an alpha<br/>
		/// channel will be created. Otherwise, SDL_image will attempt to create an<br/>
		/// SDL_Texture in the most format that most reasonably represents the image<br/>
		/// data (but in many cases, this will just end up being 32-bit RGB or 32-bit<br/>
		/// RGBA).<br/>
		/// There is a separate function to read files from an SDL_RWops, if you need<br/>
		/// an i/o abstraction to provide data from anywhere instead of a simple<br/>
		/// filesystem read; that function is IMG_LoadTexture_RW().<br/>
		/// If you would rather decode an image to an SDL_Surface (a buffer of pixels<br/>
		/// in CPU memory), call IMG_Load() instead.<br/>
		/// When done with the returned texture, the app should dispose of it with a<br/>
		/// call to SDL_DestroyTexture().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadTexture")]
		[return: NativeName(NativeNameType.Type, "SDL_Texture *")]
		public static SDLTexture* LoadTexture([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer *")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] string file)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (file != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(file);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(file, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLTexture* ret = LoadTextureNative(renderer, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Load an image from a filesystem path into a GPU texture.<br/>
		/// An SDL_Texture represents an image in GPU memory, usable by SDL's 2D Render<br/>
		/// API. This can be significantly more efficient than using a CPU-bound<br/>
		/// SDL_Surface if you don't need to manipulate the image directly after<br/>
		/// loading it.<br/>
		/// If the loaded image has transparency or a colorkey, a texture with an alpha<br/>
		/// channel will be created. Otherwise, SDL_image will attempt to create an<br/>
		/// SDL_Texture in the most format that most reasonably represents the image<br/>
		/// data (but in many cases, this will just end up being 32-bit RGB or 32-bit<br/>
		/// RGBA).<br/>
		/// There is a separate function to read files from an SDL_RWops, if you need<br/>
		/// an i/o abstraction to provide data from anywhere instead of a simple<br/>
		/// filesystem read; that function is IMG_LoadTexture_RW().<br/>
		/// If you would rather decode an image to an SDL_Surface (a buffer of pixels<br/>
		/// in CPU memory), call IMG_Load() instead.<br/>
		/// When done with the returned texture, the app should dispose of it with a<br/>
		/// call to SDL_DestroyTexture().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadTexture")]
		[return: NativeName(NativeNameType.Type, "SDL_Texture *")]
		public static SDLTexture* LoadTexture([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer *")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] ref byte file)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (byte* pfile = &file)
				{
					SDLTexture* ret = LoadTextureNative((SDLRenderer*)prenderer, (byte*)pfile);
					return ret;
				}
			}
		}

		/// <summary>
		/// Load an image from a filesystem path into a GPU texture.<br/>
		/// An SDL_Texture represents an image in GPU memory, usable by SDL's 2D Render<br/>
		/// API. This can be significantly more efficient than using a CPU-bound<br/>
		/// SDL_Surface if you don't need to manipulate the image directly after<br/>
		/// loading it.<br/>
		/// If the loaded image has transparency or a colorkey, a texture with an alpha<br/>
		/// channel will be created. Otherwise, SDL_image will attempt to create an<br/>
		/// SDL_Texture in the most format that most reasonably represents the image<br/>
		/// data (but in many cases, this will just end up being 32-bit RGB or 32-bit<br/>
		/// RGBA).<br/>
		/// There is a separate function to read files from an SDL_RWops, if you need<br/>
		/// an i/o abstraction to provide data from anywhere instead of a simple<br/>
		/// filesystem read; that function is IMG_LoadTexture_RW().<br/>
		/// If you would rather decode an image to an SDL_Surface (a buffer of pixels<br/>
		/// in CPU memory), call IMG_Load() instead.<br/>
		/// When done with the returned texture, the app should dispose of it with a<br/>
		/// call to SDL_DestroyTexture().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadTexture")]
		[return: NativeName(NativeNameType.Type, "SDL_Texture *")]
		public static SDLTexture* LoadTexture([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer *")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> file)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (byte* pfile = file)
				{
					SDLTexture* ret = LoadTextureNative((SDLRenderer*)prenderer, (byte*)pfile);
					return ret;
				}
			}
		}

		/// <summary>
		/// Load an image from a filesystem path into a GPU texture.<br/>
		/// An SDL_Texture represents an image in GPU memory, usable by SDL's 2D Render<br/>
		/// API. This can be significantly more efficient than using a CPU-bound<br/>
		/// SDL_Surface if you don't need to manipulate the image directly after<br/>
		/// loading it.<br/>
		/// If the loaded image has transparency or a colorkey, a texture with an alpha<br/>
		/// channel will be created. Otherwise, SDL_image will attempt to create an<br/>
		/// SDL_Texture in the most format that most reasonably represents the image<br/>
		/// data (but in many cases, this will just end up being 32-bit RGB or 32-bit<br/>
		/// RGBA).<br/>
		/// There is a separate function to read files from an SDL_RWops, if you need<br/>
		/// an i/o abstraction to provide data from anywhere instead of a simple<br/>
		/// filesystem read; that function is IMG_LoadTexture_RW().<br/>
		/// If you would rather decode an image to an SDL_Surface (a buffer of pixels<br/>
		/// in CPU memory), call IMG_Load() instead.<br/>
		/// When done with the returned texture, the app should dispose of it with a<br/>
		/// call to SDL_DestroyTexture().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadTexture")]
		[return: NativeName(NativeNameType.Type, "SDL_Texture *")]
		public static SDLTexture* LoadTexture([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer *")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] string file)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (file != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(file);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(file, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				SDLTexture* ret = LoadTextureNative((SDLRenderer*)prenderer, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// Load an image from an SDL data source into a GPU texture.<br/>
		/// An SDL_Texture represents an image in GPU memory, usable by SDL's 2D Render<br/>
		/// API. This can be significantly more efficient than using a CPU-bound<br/>
		/// SDL_Surface if you don't need to manipulate the image directly after<br/>
		/// loading it.<br/>
		/// If the loaded image has transparency or a colorkey, a texture with an alpha<br/>
		/// channel will be created. Otherwise, SDL_image will attempt to create an<br/>
		/// SDL_Texture in the most format that most reasonably represents the image<br/>
		/// data (but in many cases, this will just end up being 32-bit RGB or 32-bit<br/>
		/// RGBA).<br/>
		/// If `freesrc` is non-zero, the RWops will be closed before returning,<br/>
		/// whether this function succeeds or not. SDL_image reads everything it needs<br/>
		/// from the RWops during this call in any case.<br/>
		/// There is a separate function to read files from disk without having to deal<br/>
		/// with SDL_RWops: `IMG_LoadTexture(renderer, "filename.jpg")` will call this<br/>
		/// function and manage those details for you, determining the file type from<br/>
		/// the filename's extension.<br/>
		/// There is also IMG_LoadTextureTyped_RW(), which is equivalent to this<br/>
		/// function except a file extension (like "BMP", "JPG", etc) can be specified,<br/>
		/// in case SDL_image cannot autodetect the file format.<br/>
		/// If you would rather decode an image to an SDL_Surface (a buffer of pixels<br/>
		/// in CPU memory), call IMG_Load() instead.<br/>
		/// When done with the returned texture, the app should dispose of it with a<br/>
		/// call to SDL_DestroyTexture().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadTexture_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Texture *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLTexture* LoadTextureRWNative([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer *")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] SDLRWops* src, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRenderer*, SDLRWops*, int, SDLTexture*>)funcTable[7])(renderer, src, freesrc);
			#else
			return (SDLTexture*)((delegate* unmanaged[Cdecl]<nint, nint, int, nint>)funcTable[7])((nint)renderer, (nint)src, freesrc);
			#endif
		}

		/// <summary>
		/// Load an image from an SDL data source into a GPU texture.<br/>
		/// An SDL_Texture represents an image in GPU memory, usable by SDL's 2D Render<br/>
		/// API. This can be significantly more efficient than using a CPU-bound<br/>
		/// SDL_Surface if you don't need to manipulate the image directly after<br/>
		/// loading it.<br/>
		/// If the loaded image has transparency or a colorkey, a texture with an alpha<br/>
		/// channel will be created. Otherwise, SDL_image will attempt to create an<br/>
		/// SDL_Texture in the most format that most reasonably represents the image<br/>
		/// data (but in many cases, this will just end up being 32-bit RGB or 32-bit<br/>
		/// RGBA).<br/>
		/// If `freesrc` is non-zero, the RWops will be closed before returning,<br/>
		/// whether this function succeeds or not. SDL_image reads everything it needs<br/>
		/// from the RWops during this call in any case.<br/>
		/// There is a separate function to read files from disk without having to deal<br/>
		/// with SDL_RWops: `IMG_LoadTexture(renderer, "filename.jpg")` will call this<br/>
		/// function and manage those details for you, determining the file type from<br/>
		/// the filename's extension.<br/>
		/// There is also IMG_LoadTextureTyped_RW(), which is equivalent to this<br/>
		/// function except a file extension (like "BMP", "JPG", etc) can be specified,<br/>
		/// in case SDL_image cannot autodetect the file format.<br/>
		/// If you would rather decode an image to an SDL_Surface (a buffer of pixels<br/>
		/// in CPU memory), call IMG_Load() instead.<br/>
		/// When done with the returned texture, the app should dispose of it with a<br/>
		/// call to SDL_DestroyTexture().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadTexture_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Texture *")]
		public static SDLTexture* LoadTextureRW([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer *")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] SDLRWops* src, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc)
		{
			SDLTexture* ret = LoadTextureRWNative(renderer, src, freesrc);
			return ret;
		}

		/// <summary>
		/// Load an image from an SDL data source into a GPU texture.<br/>
		/// An SDL_Texture represents an image in GPU memory, usable by SDL's 2D Render<br/>
		/// API. This can be significantly more efficient than using a CPU-bound<br/>
		/// SDL_Surface if you don't need to manipulate the image directly after<br/>
		/// loading it.<br/>
		/// If the loaded image has transparency or a colorkey, a texture with an alpha<br/>
		/// channel will be created. Otherwise, SDL_image will attempt to create an<br/>
		/// SDL_Texture in the most format that most reasonably represents the image<br/>
		/// data (but in many cases, this will just end up being 32-bit RGB or 32-bit<br/>
		/// RGBA).<br/>
		/// If `freesrc` is non-zero, the RWops will be closed before returning,<br/>
		/// whether this function succeeds or not. SDL_image reads everything it needs<br/>
		/// from the RWops during this call in any case.<br/>
		/// There is a separate function to read files from disk without having to deal<br/>
		/// with SDL_RWops: `IMG_LoadTexture(renderer, "filename.jpg")` will call this<br/>
		/// function and manage those details for you, determining the file type from<br/>
		/// the filename's extension.<br/>
		/// There is also IMG_LoadTextureTyped_RW(), which is equivalent to this<br/>
		/// function except a file extension (like "BMP", "JPG", etc) can be specified,<br/>
		/// in case SDL_image cannot autodetect the file format.<br/>
		/// If you would rather decode an image to an SDL_Surface (a buffer of pixels<br/>
		/// in CPU memory), call IMG_Load() instead.<br/>
		/// When done with the returned texture, the app should dispose of it with a<br/>
		/// call to SDL_DestroyTexture().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadTexture_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Texture *")]
		public static SDLTexture* LoadTextureRW([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer *")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] SDLRWops* src, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				SDLTexture* ret = LoadTextureRWNative((SDLRenderer*)prenderer, src, freesrc);
				return ret;
			}
		}

		/// <summary>
		/// Load an image from an SDL data source into a GPU texture.<br/>
		/// An SDL_Texture represents an image in GPU memory, usable by SDL's 2D Render<br/>
		/// API. This can be significantly more efficient than using a CPU-bound<br/>
		/// SDL_Surface if you don't need to manipulate the image directly after<br/>
		/// loading it.<br/>
		/// If the loaded image has transparency or a colorkey, a texture with an alpha<br/>
		/// channel will be created. Otherwise, SDL_image will attempt to create an<br/>
		/// SDL_Texture in the most format that most reasonably represents the image<br/>
		/// data (but in many cases, this will just end up being 32-bit RGB or 32-bit<br/>
		/// RGBA).<br/>
		/// If `freesrc` is non-zero, the RWops will be closed before returning,<br/>
		/// whether this function succeeds or not. SDL_image reads everything it needs<br/>
		/// from the RWops during this call in any case.<br/>
		/// There is a separate function to read files from disk without having to deal<br/>
		/// with SDL_RWops: `IMG_LoadTexture(renderer, "filename.jpg")` will call this<br/>
		/// function and manage those details for you, determining the file type from<br/>
		/// the filename's extension.<br/>
		/// There is also IMG_LoadTextureTyped_RW(), which is equivalent to this<br/>
		/// function except a file extension (like "BMP", "JPG", etc) can be specified,<br/>
		/// in case SDL_image cannot autodetect the file format.<br/>
		/// If you would rather decode an image to an SDL_Surface (a buffer of pixels<br/>
		/// in CPU memory), call IMG_Load() instead.<br/>
		/// When done with the returned texture, the app should dispose of it with a<br/>
		/// call to SDL_DestroyTexture().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadTexture_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Texture *")]
		public static SDLTexture* LoadTextureRW([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer *")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] ref SDLRWops src, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc)
		{
			fixed (SDLRWops* psrc = &src)
			{
				SDLTexture* ret = LoadTextureRWNative(renderer, (SDLRWops*)psrc, freesrc);
				return ret;
			}
		}

		/// <summary>
		/// Load an image from an SDL data source into a GPU texture.<br/>
		/// An SDL_Texture represents an image in GPU memory, usable by SDL's 2D Render<br/>
		/// API. This can be significantly more efficient than using a CPU-bound<br/>
		/// SDL_Surface if you don't need to manipulate the image directly after<br/>
		/// loading it.<br/>
		/// If the loaded image has transparency or a colorkey, a texture with an alpha<br/>
		/// channel will be created. Otherwise, SDL_image will attempt to create an<br/>
		/// SDL_Texture in the most format that most reasonably represents the image<br/>
		/// data (but in many cases, this will just end up being 32-bit RGB or 32-bit<br/>
		/// RGBA).<br/>
		/// If `freesrc` is non-zero, the RWops will be closed before returning,<br/>
		/// whether this function succeeds or not. SDL_image reads everything it needs<br/>
		/// from the RWops during this call in any case.<br/>
		/// There is a separate function to read files from disk without having to deal<br/>
		/// with SDL_RWops: `IMG_LoadTexture(renderer, "filename.jpg")` will call this<br/>
		/// function and manage those details for you, determining the file type from<br/>
		/// the filename's extension.<br/>
		/// There is also IMG_LoadTextureTyped_RW(), which is equivalent to this<br/>
		/// function except a file extension (like "BMP", "JPG", etc) can be specified,<br/>
		/// in case SDL_image cannot autodetect the file format.<br/>
		/// If you would rather decode an image to an SDL_Surface (a buffer of pixels<br/>
		/// in CPU memory), call IMG_Load() instead.<br/>
		/// When done with the returned texture, the app should dispose of it with a<br/>
		/// call to SDL_DestroyTexture().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadTexture_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Texture *")]
		public static SDLTexture* LoadTextureRW([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer *")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] ref SDLRWops src, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLRWops* psrc = &src)
				{
					SDLTexture* ret = LoadTextureRWNative((SDLRenderer*)prenderer, (SDLRWops*)psrc, freesrc);
					return ret;
				}
			}
		}

		/// <summary>
		/// Load an image from an SDL data source into a GPU texture.<br/>
		/// An SDL_Texture represents an image in GPU memory, usable by SDL's 2D Render<br/>
		/// API. This can be significantly more efficient than using a CPU-bound<br/>
		/// SDL_Surface if you don't need to manipulate the image directly after<br/>
		/// loading it.<br/>
		/// If the loaded image has transparency or a colorkey, a texture with an alpha<br/>
		/// channel will be created. Otherwise, SDL_image will attempt to create an<br/>
		/// SDL_Texture in the most format that most reasonably represents the image<br/>
		/// data (but in many cases, this will just end up being 32-bit RGB or 32-bit<br/>
		/// RGBA).<br/>
		/// If `freesrc` is non-zero, the RWops will be closed before returning,<br/>
		/// whether this function succeeds or not. SDL_image reads everything it needs<br/>
		/// from the RWops during this call in any case.<br/>
		/// Even though this function accepts a file type, SDL_image may still try<br/>
		/// other decoders that are capable of detecting file type from the contents of<br/>
		/// the image data, but may rely on the caller-provided type string for formats<br/>
		/// that it cannot autodetect. If `type` is NULL, SDL_image will rely solely on<br/>
		/// its ability to guess the format.<br/>
		/// There is a separate function to read files from disk without having to deal<br/>
		/// with SDL_RWops: `IMG_LoadTexture("filename.jpg")` will call this function<br/>
		/// and manage those details for you, determining the file type from the<br/>
		/// filename's extension.<br/>
		/// There is also IMG_LoadTexture_RW(), which is equivalent to this function<br/>
		/// except that it will rely on SDL_image to determine what type of data it is<br/>
		/// loading, much like passing a NULL for type.<br/>
		/// If you would rather decode an image to an SDL_Surface (a buffer of pixels<br/>
		/// in CPU memory), call IMG_LoadTyped_RW() instead.<br/>
		/// When done with the returned texture, the app should dispose of it with a<br/>
		/// call to SDL_DestroyTexture().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadTextureTyped_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Texture *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLTexture* LoadTextureTypedRWNative([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer *")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] SDLRWops* src, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "char const *")] byte* type)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRenderer*, SDLRWops*, int, byte*, SDLTexture*>)funcTable[8])(renderer, src, freesrc, type);
			#else
			return (SDLTexture*)((delegate* unmanaged[Cdecl]<nint, nint, int, nint, nint>)funcTable[8])((nint)renderer, (nint)src, freesrc, (nint)type);
			#endif
		}

		/// <summary>
		/// Load an image from an SDL data source into a GPU texture.<br/>
		/// An SDL_Texture represents an image in GPU memory, usable by SDL's 2D Render<br/>
		/// API. This can be significantly more efficient than using a CPU-bound<br/>
		/// SDL_Surface if you don't need to manipulate the image directly after<br/>
		/// loading it.<br/>
		/// If the loaded image has transparency or a colorkey, a texture with an alpha<br/>
		/// channel will be created. Otherwise, SDL_image will attempt to create an<br/>
		/// SDL_Texture in the most format that most reasonably represents the image<br/>
		/// data (but in many cases, this will just end up being 32-bit RGB or 32-bit<br/>
		/// RGBA).<br/>
		/// If `freesrc` is non-zero, the RWops will be closed before returning,<br/>
		/// whether this function succeeds or not. SDL_image reads everything it needs<br/>
		/// from the RWops during this call in any case.<br/>
		/// Even though this function accepts a file type, SDL_image may still try<br/>
		/// other decoders that are capable of detecting file type from the contents of<br/>
		/// the image data, but may rely on the caller-provided type string for formats<br/>
		/// that it cannot autodetect. If `type` is NULL, SDL_image will rely solely on<br/>
		/// its ability to guess the format.<br/>
		/// There is a separate function to read files from disk without having to deal<br/>
		/// with SDL_RWops: `IMG_LoadTexture("filename.jpg")` will call this function<br/>
		/// and manage those details for you, determining the file type from the<br/>
		/// filename's extension.<br/>
		/// There is also IMG_LoadTexture_RW(), which is equivalent to this function<br/>
		/// except that it will rely on SDL_image to determine what type of data it is<br/>
		/// loading, much like passing a NULL for type.<br/>
		/// If you would rather decode an image to an SDL_Surface (a buffer of pixels<br/>
		/// in CPU memory), call IMG_LoadTyped_RW() instead.<br/>
		/// When done with the returned texture, the app should dispose of it with a<br/>
		/// call to SDL_DestroyTexture().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadTextureTyped_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Texture *")]
		public static SDLTexture* LoadTextureTypedRW([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer *")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] SDLRWops* src, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "char const *")] byte* type)
		{
			SDLTexture* ret = LoadTextureTypedRWNative(renderer, src, freesrc, type);
			return ret;
		}

		/// <summary>
		/// Load an image from an SDL data source into a GPU texture.<br/>
		/// An SDL_Texture represents an image in GPU memory, usable by SDL's 2D Render<br/>
		/// API. This can be significantly more efficient than using a CPU-bound<br/>
		/// SDL_Surface if you don't need to manipulate the image directly after<br/>
		/// loading it.<br/>
		/// If the loaded image has transparency or a colorkey, a texture with an alpha<br/>
		/// channel will be created. Otherwise, SDL_image will attempt to create an<br/>
		/// SDL_Texture in the most format that most reasonably represents the image<br/>
		/// data (but in many cases, this will just end up being 32-bit RGB or 32-bit<br/>
		/// RGBA).<br/>
		/// If `freesrc` is non-zero, the RWops will be closed before returning,<br/>
		/// whether this function succeeds or not. SDL_image reads everything it needs<br/>
		/// from the RWops during this call in any case.<br/>
		/// Even though this function accepts a file type, SDL_image may still try<br/>
		/// other decoders that are capable of detecting file type from the contents of<br/>
		/// the image data, but may rely on the caller-provided type string for formats<br/>
		/// that it cannot autodetect. If `type` is NULL, SDL_image will rely solely on<br/>
		/// its ability to guess the format.<br/>
		/// There is a separate function to read files from disk without having to deal<br/>
		/// with SDL_RWops: `IMG_LoadTexture("filename.jpg")` will call this function<br/>
		/// and manage those details for you, determining the file type from the<br/>
		/// filename's extension.<br/>
		/// There is also IMG_LoadTexture_RW(), which is equivalent to this function<br/>
		/// except that it will rely on SDL_image to determine what type of data it is<br/>
		/// loading, much like passing a NULL for type.<br/>
		/// If you would rather decode an image to an SDL_Surface (a buffer of pixels<br/>
		/// in CPU memory), call IMG_LoadTyped_RW() instead.<br/>
		/// When done with the returned texture, the app should dispose of it with a<br/>
		/// call to SDL_DestroyTexture().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadTextureTyped_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Texture *")]
		public static SDLTexture* LoadTextureTypedRW([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer *")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] SDLRWops* src, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "char const *")] byte* type)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				SDLTexture* ret = LoadTextureTypedRWNative((SDLRenderer*)prenderer, src, freesrc, type);
				return ret;
			}
		}

		/// <summary>
		/// Load an image from an SDL data source into a GPU texture.<br/>
		/// An SDL_Texture represents an image in GPU memory, usable by SDL's 2D Render<br/>
		/// API. This can be significantly more efficient than using a CPU-bound<br/>
		/// SDL_Surface if you don't need to manipulate the image directly after<br/>
		/// loading it.<br/>
		/// If the loaded image has transparency or a colorkey, a texture with an alpha<br/>
		/// channel will be created. Otherwise, SDL_image will attempt to create an<br/>
		/// SDL_Texture in the most format that most reasonably represents the image<br/>
		/// data (but in many cases, this will just end up being 32-bit RGB or 32-bit<br/>
		/// RGBA).<br/>
		/// If `freesrc` is non-zero, the RWops will be closed before returning,<br/>
		/// whether this function succeeds or not. SDL_image reads everything it needs<br/>
		/// from the RWops during this call in any case.<br/>
		/// Even though this function accepts a file type, SDL_image may still try<br/>
		/// other decoders that are capable of detecting file type from the contents of<br/>
		/// the image data, but may rely on the caller-provided type string for formats<br/>
		/// that it cannot autodetect. If `type` is NULL, SDL_image will rely solely on<br/>
		/// its ability to guess the format.<br/>
		/// There is a separate function to read files from disk without having to deal<br/>
		/// with SDL_RWops: `IMG_LoadTexture("filename.jpg")` will call this function<br/>
		/// and manage those details for you, determining the file type from the<br/>
		/// filename's extension.<br/>
		/// There is also IMG_LoadTexture_RW(), which is equivalent to this function<br/>
		/// except that it will rely on SDL_image to determine what type of data it is<br/>
		/// loading, much like passing a NULL for type.<br/>
		/// If you would rather decode an image to an SDL_Surface (a buffer of pixels<br/>
		/// in CPU memory), call IMG_LoadTyped_RW() instead.<br/>
		/// When done with the returned texture, the app should dispose of it with a<br/>
		/// call to SDL_DestroyTexture().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadTextureTyped_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Texture *")]
		public static SDLTexture* LoadTextureTypedRW([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer *")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] ref SDLRWops src, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "char const *")] byte* type)
		{
			fixed (SDLRWops* psrc = &src)
			{
				SDLTexture* ret = LoadTextureTypedRWNative(renderer, (SDLRWops*)psrc, freesrc, type);
				return ret;
			}
		}

		/// <summary>
		/// Load an image from an SDL data source into a GPU texture.<br/>
		/// An SDL_Texture represents an image in GPU memory, usable by SDL's 2D Render<br/>
		/// API. This can be significantly more efficient than using a CPU-bound<br/>
		/// SDL_Surface if you don't need to manipulate the image directly after<br/>
		/// loading it.<br/>
		/// If the loaded image has transparency or a colorkey, a texture with an alpha<br/>
		/// channel will be created. Otherwise, SDL_image will attempt to create an<br/>
		/// SDL_Texture in the most format that most reasonably represents the image<br/>
		/// data (but in many cases, this will just end up being 32-bit RGB or 32-bit<br/>
		/// RGBA).<br/>
		/// If `freesrc` is non-zero, the RWops will be closed before returning,<br/>
		/// whether this function succeeds or not. SDL_image reads everything it needs<br/>
		/// from the RWops during this call in any case.<br/>
		/// Even though this function accepts a file type, SDL_image may still try<br/>
		/// other decoders that are capable of detecting file type from the contents of<br/>
		/// the image data, but may rely on the caller-provided type string for formats<br/>
		/// that it cannot autodetect. If `type` is NULL, SDL_image will rely solely on<br/>
		/// its ability to guess the format.<br/>
		/// There is a separate function to read files from disk without having to deal<br/>
		/// with SDL_RWops: `IMG_LoadTexture("filename.jpg")` will call this function<br/>
		/// and manage those details for you, determining the file type from the<br/>
		/// filename's extension.<br/>
		/// There is also IMG_LoadTexture_RW(), which is equivalent to this function<br/>
		/// except that it will rely on SDL_image to determine what type of data it is<br/>
		/// loading, much like passing a NULL for type.<br/>
		/// If you would rather decode an image to an SDL_Surface (a buffer of pixels<br/>
		/// in CPU memory), call IMG_LoadTyped_RW() instead.<br/>
		/// When done with the returned texture, the app should dispose of it with a<br/>
		/// call to SDL_DestroyTexture().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadTextureTyped_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Texture *")]
		public static SDLTexture* LoadTextureTypedRW([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer *")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] ref SDLRWops src, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "char const *")] byte* type)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLRWops* psrc = &src)
				{
					SDLTexture* ret = LoadTextureTypedRWNative((SDLRenderer*)prenderer, (SDLRWops*)psrc, freesrc, type);
					return ret;
				}
			}
		}

		/// <summary>
		/// Load an image from an SDL data source into a GPU texture.<br/>
		/// An SDL_Texture represents an image in GPU memory, usable by SDL's 2D Render<br/>
		/// API. This can be significantly more efficient than using a CPU-bound<br/>
		/// SDL_Surface if you don't need to manipulate the image directly after<br/>
		/// loading it.<br/>
		/// If the loaded image has transparency or a colorkey, a texture with an alpha<br/>
		/// channel will be created. Otherwise, SDL_image will attempt to create an<br/>
		/// SDL_Texture in the most format that most reasonably represents the image<br/>
		/// data (but in many cases, this will just end up being 32-bit RGB or 32-bit<br/>
		/// RGBA).<br/>
		/// If `freesrc` is non-zero, the RWops will be closed before returning,<br/>
		/// whether this function succeeds or not. SDL_image reads everything it needs<br/>
		/// from the RWops during this call in any case.<br/>
		/// Even though this function accepts a file type, SDL_image may still try<br/>
		/// other decoders that are capable of detecting file type from the contents of<br/>
		/// the image data, but may rely on the caller-provided type string for formats<br/>
		/// that it cannot autodetect. If `type` is NULL, SDL_image will rely solely on<br/>
		/// its ability to guess the format.<br/>
		/// There is a separate function to read files from disk without having to deal<br/>
		/// with SDL_RWops: `IMG_LoadTexture("filename.jpg")` will call this function<br/>
		/// and manage those details for you, determining the file type from the<br/>
		/// filename's extension.<br/>
		/// There is also IMG_LoadTexture_RW(), which is equivalent to this function<br/>
		/// except that it will rely on SDL_image to determine what type of data it is<br/>
		/// loading, much like passing a NULL for type.<br/>
		/// If you would rather decode an image to an SDL_Surface (a buffer of pixels<br/>
		/// in CPU memory), call IMG_LoadTyped_RW() instead.<br/>
		/// When done with the returned texture, the app should dispose of it with a<br/>
		/// call to SDL_DestroyTexture().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadTextureTyped_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Texture *")]
		public static SDLTexture* LoadTextureTypedRW([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer *")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] SDLRWops* src, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "char const *")] ref byte type)
		{
			fixed (byte* ptype = &type)
			{
				SDLTexture* ret = LoadTextureTypedRWNative(renderer, src, freesrc, (byte*)ptype);
				return ret;
			}
		}

		/// <summary>
		/// Load an image from an SDL data source into a GPU texture.<br/>
		/// An SDL_Texture represents an image in GPU memory, usable by SDL's 2D Render<br/>
		/// API. This can be significantly more efficient than using a CPU-bound<br/>
		/// SDL_Surface if you don't need to manipulate the image directly after<br/>
		/// loading it.<br/>
		/// If the loaded image has transparency or a colorkey, a texture with an alpha<br/>
		/// channel will be created. Otherwise, SDL_image will attempt to create an<br/>
		/// SDL_Texture in the most format that most reasonably represents the image<br/>
		/// data (but in many cases, this will just end up being 32-bit RGB or 32-bit<br/>
		/// RGBA).<br/>
		/// If `freesrc` is non-zero, the RWops will be closed before returning,<br/>
		/// whether this function succeeds or not. SDL_image reads everything it needs<br/>
		/// from the RWops during this call in any case.<br/>
		/// Even though this function accepts a file type, SDL_image may still try<br/>
		/// other decoders that are capable of detecting file type from the contents of<br/>
		/// the image data, but may rely on the caller-provided type string for formats<br/>
		/// that it cannot autodetect. If `type` is NULL, SDL_image will rely solely on<br/>
		/// its ability to guess the format.<br/>
		/// There is a separate function to read files from disk without having to deal<br/>
		/// with SDL_RWops: `IMG_LoadTexture("filename.jpg")` will call this function<br/>
		/// and manage those details for you, determining the file type from the<br/>
		/// filename's extension.<br/>
		/// There is also IMG_LoadTexture_RW(), which is equivalent to this function<br/>
		/// except that it will rely on SDL_image to determine what type of data it is<br/>
		/// loading, much like passing a NULL for type.<br/>
		/// If you would rather decode an image to an SDL_Surface (a buffer of pixels<br/>
		/// in CPU memory), call IMG_LoadTyped_RW() instead.<br/>
		/// When done with the returned texture, the app should dispose of it with a<br/>
		/// call to SDL_DestroyTexture().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadTextureTyped_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Texture *")]
		public static SDLTexture* LoadTextureTypedRW([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer *")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] SDLRWops* src, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> type)
		{
			fixed (byte* ptype = type)
			{
				SDLTexture* ret = LoadTextureTypedRWNative(renderer, src, freesrc, (byte*)ptype);
				return ret;
			}
		}

		/// <summary>
		/// Load an image from an SDL data source into a GPU texture.<br/>
		/// An SDL_Texture represents an image in GPU memory, usable by SDL's 2D Render<br/>
		/// API. This can be significantly more efficient than using a CPU-bound<br/>
		/// SDL_Surface if you don't need to manipulate the image directly after<br/>
		/// loading it.<br/>
		/// If the loaded image has transparency or a colorkey, a texture with an alpha<br/>
		/// channel will be created. Otherwise, SDL_image will attempt to create an<br/>
		/// SDL_Texture in the most format that most reasonably represents the image<br/>
		/// data (but in many cases, this will just end up being 32-bit RGB or 32-bit<br/>
		/// RGBA).<br/>
		/// If `freesrc` is non-zero, the RWops will be closed before returning,<br/>
		/// whether this function succeeds or not. SDL_image reads everything it needs<br/>
		/// from the RWops during this call in any case.<br/>
		/// Even though this function accepts a file type, SDL_image may still try<br/>
		/// other decoders that are capable of detecting file type from the contents of<br/>
		/// the image data, but may rely on the caller-provided type string for formats<br/>
		/// that it cannot autodetect. If `type` is NULL, SDL_image will rely solely on<br/>
		/// its ability to guess the format.<br/>
		/// There is a separate function to read files from disk without having to deal<br/>
		/// with SDL_RWops: `IMG_LoadTexture("filename.jpg")` will call this function<br/>
		/// and manage those details for you, determining the file type from the<br/>
		/// filename's extension.<br/>
		/// There is also IMG_LoadTexture_RW(), which is equivalent to this function<br/>
		/// except that it will rely on SDL_image to determine what type of data it is<br/>
		/// loading, much like passing a NULL for type.<br/>
		/// If you would rather decode an image to an SDL_Surface (a buffer of pixels<br/>
		/// in CPU memory), call IMG_LoadTyped_RW() instead.<br/>
		/// When done with the returned texture, the app should dispose of it with a<br/>
		/// call to SDL_DestroyTexture().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadTextureTyped_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Texture *")]
		public static SDLTexture* LoadTextureTypedRW([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer *")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] SDLRWops* src, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "char const *")] string type)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (type != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(type);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(type, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLTexture* ret = LoadTextureTypedRWNative(renderer, src, freesrc, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Load an image from an SDL data source into a GPU texture.<br/>
		/// An SDL_Texture represents an image in GPU memory, usable by SDL's 2D Render<br/>
		/// API. This can be significantly more efficient than using a CPU-bound<br/>
		/// SDL_Surface if you don't need to manipulate the image directly after<br/>
		/// loading it.<br/>
		/// If the loaded image has transparency or a colorkey, a texture with an alpha<br/>
		/// channel will be created. Otherwise, SDL_image will attempt to create an<br/>
		/// SDL_Texture in the most format that most reasonably represents the image<br/>
		/// data (but in many cases, this will just end up being 32-bit RGB or 32-bit<br/>
		/// RGBA).<br/>
		/// If `freesrc` is non-zero, the RWops will be closed before returning,<br/>
		/// whether this function succeeds or not. SDL_image reads everything it needs<br/>
		/// from the RWops during this call in any case.<br/>
		/// Even though this function accepts a file type, SDL_image may still try<br/>
		/// other decoders that are capable of detecting file type from the contents of<br/>
		/// the image data, but may rely on the caller-provided type string for formats<br/>
		/// that it cannot autodetect. If `type` is NULL, SDL_image will rely solely on<br/>
		/// its ability to guess the format.<br/>
		/// There is a separate function to read files from disk without having to deal<br/>
		/// with SDL_RWops: `IMG_LoadTexture("filename.jpg")` will call this function<br/>
		/// and manage those details for you, determining the file type from the<br/>
		/// filename's extension.<br/>
		/// There is also IMG_LoadTexture_RW(), which is equivalent to this function<br/>
		/// except that it will rely on SDL_image to determine what type of data it is<br/>
		/// loading, much like passing a NULL for type.<br/>
		/// If you would rather decode an image to an SDL_Surface (a buffer of pixels<br/>
		/// in CPU memory), call IMG_LoadTyped_RW() instead.<br/>
		/// When done with the returned texture, the app should dispose of it with a<br/>
		/// call to SDL_DestroyTexture().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadTextureTyped_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Texture *")]
		public static SDLTexture* LoadTextureTypedRW([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer *")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] SDLRWops* src, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "char const *")] ref byte type)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (byte* ptype = &type)
				{
					SDLTexture* ret = LoadTextureTypedRWNative((SDLRenderer*)prenderer, src, freesrc, (byte*)ptype);
					return ret;
				}
			}
		}

		/// <summary>
		/// Load an image from an SDL data source into a GPU texture.<br/>
		/// An SDL_Texture represents an image in GPU memory, usable by SDL's 2D Render<br/>
		/// API. This can be significantly more efficient than using a CPU-bound<br/>
		/// SDL_Surface if you don't need to manipulate the image directly after<br/>
		/// loading it.<br/>
		/// If the loaded image has transparency or a colorkey, a texture with an alpha<br/>
		/// channel will be created. Otherwise, SDL_image will attempt to create an<br/>
		/// SDL_Texture in the most format that most reasonably represents the image<br/>
		/// data (but in many cases, this will just end up being 32-bit RGB or 32-bit<br/>
		/// RGBA).<br/>
		/// If `freesrc` is non-zero, the RWops will be closed before returning,<br/>
		/// whether this function succeeds or not. SDL_image reads everything it needs<br/>
		/// from the RWops during this call in any case.<br/>
		/// Even though this function accepts a file type, SDL_image may still try<br/>
		/// other decoders that are capable of detecting file type from the contents of<br/>
		/// the image data, but may rely on the caller-provided type string for formats<br/>
		/// that it cannot autodetect. If `type` is NULL, SDL_image will rely solely on<br/>
		/// its ability to guess the format.<br/>
		/// There is a separate function to read files from disk without having to deal<br/>
		/// with SDL_RWops: `IMG_LoadTexture("filename.jpg")` will call this function<br/>
		/// and manage those details for you, determining the file type from the<br/>
		/// filename's extension.<br/>
		/// There is also IMG_LoadTexture_RW(), which is equivalent to this function<br/>
		/// except that it will rely on SDL_image to determine what type of data it is<br/>
		/// loading, much like passing a NULL for type.<br/>
		/// If you would rather decode an image to an SDL_Surface (a buffer of pixels<br/>
		/// in CPU memory), call IMG_LoadTyped_RW() instead.<br/>
		/// When done with the returned texture, the app should dispose of it with a<br/>
		/// call to SDL_DestroyTexture().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadTextureTyped_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Texture *")]
		public static SDLTexture* LoadTextureTypedRW([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer *")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] SDLRWops* src, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> type)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (byte* ptype = type)
				{
					SDLTexture* ret = LoadTextureTypedRWNative((SDLRenderer*)prenderer, src, freesrc, (byte*)ptype);
					return ret;
				}
			}
		}

		/// <summary>
		/// Load an image from an SDL data source into a GPU texture.<br/>
		/// An SDL_Texture represents an image in GPU memory, usable by SDL's 2D Render<br/>
		/// API. This can be significantly more efficient than using a CPU-bound<br/>
		/// SDL_Surface if you don't need to manipulate the image directly after<br/>
		/// loading it.<br/>
		/// If the loaded image has transparency or a colorkey, a texture with an alpha<br/>
		/// channel will be created. Otherwise, SDL_image will attempt to create an<br/>
		/// SDL_Texture in the most format that most reasonably represents the image<br/>
		/// data (but in many cases, this will just end up being 32-bit RGB or 32-bit<br/>
		/// RGBA).<br/>
		/// If `freesrc` is non-zero, the RWops will be closed before returning,<br/>
		/// whether this function succeeds or not. SDL_image reads everything it needs<br/>
		/// from the RWops during this call in any case.<br/>
		/// Even though this function accepts a file type, SDL_image may still try<br/>
		/// other decoders that are capable of detecting file type from the contents of<br/>
		/// the image data, but may rely on the caller-provided type string for formats<br/>
		/// that it cannot autodetect. If `type` is NULL, SDL_image will rely solely on<br/>
		/// its ability to guess the format.<br/>
		/// There is a separate function to read files from disk without having to deal<br/>
		/// with SDL_RWops: `IMG_LoadTexture("filename.jpg")` will call this function<br/>
		/// and manage those details for you, determining the file type from the<br/>
		/// filename's extension.<br/>
		/// There is also IMG_LoadTexture_RW(), which is equivalent to this function<br/>
		/// except that it will rely on SDL_image to determine what type of data it is<br/>
		/// loading, much like passing a NULL for type.<br/>
		/// If you would rather decode an image to an SDL_Surface (a buffer of pixels<br/>
		/// in CPU memory), call IMG_LoadTyped_RW() instead.<br/>
		/// When done with the returned texture, the app should dispose of it with a<br/>
		/// call to SDL_DestroyTexture().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadTextureTyped_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Texture *")]
		public static SDLTexture* LoadTextureTypedRW([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer *")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] SDLRWops* src, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "char const *")] string type)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (type != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(type);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(type, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				SDLTexture* ret = LoadTextureTypedRWNative((SDLRenderer*)prenderer, src, freesrc, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// Load an image from an SDL data source into a GPU texture.<br/>
		/// An SDL_Texture represents an image in GPU memory, usable by SDL's 2D Render<br/>
		/// API. This can be significantly more efficient than using a CPU-bound<br/>
		/// SDL_Surface if you don't need to manipulate the image directly after<br/>
		/// loading it.<br/>
		/// If the loaded image has transparency or a colorkey, a texture with an alpha<br/>
		/// channel will be created. Otherwise, SDL_image will attempt to create an<br/>
		/// SDL_Texture in the most format that most reasonably represents the image<br/>
		/// data (but in many cases, this will just end up being 32-bit RGB or 32-bit<br/>
		/// RGBA).<br/>
		/// If `freesrc` is non-zero, the RWops will be closed before returning,<br/>
		/// whether this function succeeds or not. SDL_image reads everything it needs<br/>
		/// from the RWops during this call in any case.<br/>
		/// Even though this function accepts a file type, SDL_image may still try<br/>
		/// other decoders that are capable of detecting file type from the contents of<br/>
		/// the image data, but may rely on the caller-provided type string for formats<br/>
		/// that it cannot autodetect. If `type` is NULL, SDL_image will rely solely on<br/>
		/// its ability to guess the format.<br/>
		/// There is a separate function to read files from disk without having to deal<br/>
		/// with SDL_RWops: `IMG_LoadTexture("filename.jpg")` will call this function<br/>
		/// and manage those details for you, determining the file type from the<br/>
		/// filename's extension.<br/>
		/// There is also IMG_LoadTexture_RW(), which is equivalent to this function<br/>
		/// except that it will rely on SDL_image to determine what type of data it is<br/>
		/// loading, much like passing a NULL for type.<br/>
		/// If you would rather decode an image to an SDL_Surface (a buffer of pixels<br/>
		/// in CPU memory), call IMG_LoadTyped_RW() instead.<br/>
		/// When done with the returned texture, the app should dispose of it with a<br/>
		/// call to SDL_DestroyTexture().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadTextureTyped_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Texture *")]
		public static SDLTexture* LoadTextureTypedRW([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer *")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] ref SDLRWops src, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "char const *")] ref byte type)
		{
			fixed (SDLRWops* psrc = &src)
			{
				fixed (byte* ptype = &type)
				{
					SDLTexture* ret = LoadTextureTypedRWNative(renderer, (SDLRWops*)psrc, freesrc, (byte*)ptype);
					return ret;
				}
			}
		}

		/// <summary>
		/// Load an image from an SDL data source into a GPU texture.<br/>
		/// An SDL_Texture represents an image in GPU memory, usable by SDL's 2D Render<br/>
		/// API. This can be significantly more efficient than using a CPU-bound<br/>
		/// SDL_Surface if you don't need to manipulate the image directly after<br/>
		/// loading it.<br/>
		/// If the loaded image has transparency or a colorkey, a texture with an alpha<br/>
		/// channel will be created. Otherwise, SDL_image will attempt to create an<br/>
		/// SDL_Texture in the most format that most reasonably represents the image<br/>
		/// data (but in many cases, this will just end up being 32-bit RGB or 32-bit<br/>
		/// RGBA).<br/>
		/// If `freesrc` is non-zero, the RWops will be closed before returning,<br/>
		/// whether this function succeeds or not. SDL_image reads everything it needs<br/>
		/// from the RWops during this call in any case.<br/>
		/// Even though this function accepts a file type, SDL_image may still try<br/>
		/// other decoders that are capable of detecting file type from the contents of<br/>
		/// the image data, but may rely on the caller-provided type string for formats<br/>
		/// that it cannot autodetect. If `type` is NULL, SDL_image will rely solely on<br/>
		/// its ability to guess the format.<br/>
		/// There is a separate function to read files from disk without having to deal<br/>
		/// with SDL_RWops: `IMG_LoadTexture("filename.jpg")` will call this function<br/>
		/// and manage those details for you, determining the file type from the<br/>
		/// filename's extension.<br/>
		/// There is also IMG_LoadTexture_RW(), which is equivalent to this function<br/>
		/// except that it will rely on SDL_image to determine what type of data it is<br/>
		/// loading, much like passing a NULL for type.<br/>
		/// If you would rather decode an image to an SDL_Surface (a buffer of pixels<br/>
		/// in CPU memory), call IMG_LoadTyped_RW() instead.<br/>
		/// When done with the returned texture, the app should dispose of it with a<br/>
		/// call to SDL_DestroyTexture().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadTextureTyped_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Texture *")]
		public static SDLTexture* LoadTextureTypedRW([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer *")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] ref SDLRWops src, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> type)
		{
			fixed (SDLRWops* psrc = &src)
			{
				fixed (byte* ptype = type)
				{
					SDLTexture* ret = LoadTextureTypedRWNative(renderer, (SDLRWops*)psrc, freesrc, (byte*)ptype);
					return ret;
				}
			}
		}

		/// <summary>
		/// Load an image from an SDL data source into a GPU texture.<br/>
		/// An SDL_Texture represents an image in GPU memory, usable by SDL's 2D Render<br/>
		/// API. This can be significantly more efficient than using a CPU-bound<br/>
		/// SDL_Surface if you don't need to manipulate the image directly after<br/>
		/// loading it.<br/>
		/// If the loaded image has transparency or a colorkey, a texture with an alpha<br/>
		/// channel will be created. Otherwise, SDL_image will attempt to create an<br/>
		/// SDL_Texture in the most format that most reasonably represents the image<br/>
		/// data (but in many cases, this will just end up being 32-bit RGB or 32-bit<br/>
		/// RGBA).<br/>
		/// If `freesrc` is non-zero, the RWops will be closed before returning,<br/>
		/// whether this function succeeds or not. SDL_image reads everything it needs<br/>
		/// from the RWops during this call in any case.<br/>
		/// Even though this function accepts a file type, SDL_image may still try<br/>
		/// other decoders that are capable of detecting file type from the contents of<br/>
		/// the image data, but may rely on the caller-provided type string for formats<br/>
		/// that it cannot autodetect. If `type` is NULL, SDL_image will rely solely on<br/>
		/// its ability to guess the format.<br/>
		/// There is a separate function to read files from disk without having to deal<br/>
		/// with SDL_RWops: `IMG_LoadTexture("filename.jpg")` will call this function<br/>
		/// and manage those details for you, determining the file type from the<br/>
		/// filename's extension.<br/>
		/// There is also IMG_LoadTexture_RW(), which is equivalent to this function<br/>
		/// except that it will rely on SDL_image to determine what type of data it is<br/>
		/// loading, much like passing a NULL for type.<br/>
		/// If you would rather decode an image to an SDL_Surface (a buffer of pixels<br/>
		/// in CPU memory), call IMG_LoadTyped_RW() instead.<br/>
		/// When done with the returned texture, the app should dispose of it with a<br/>
		/// call to SDL_DestroyTexture().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadTextureTyped_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Texture *")]
		public static SDLTexture* LoadTextureTypedRW([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer *")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] ref SDLRWops src, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "char const *")] string type)
		{
			fixed (SDLRWops* psrc = &src)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (type != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(type);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(type, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				SDLTexture* ret = LoadTextureTypedRWNative(renderer, (SDLRWops*)psrc, freesrc, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// Load an image from an SDL data source into a GPU texture.<br/>
		/// An SDL_Texture represents an image in GPU memory, usable by SDL's 2D Render<br/>
		/// API. This can be significantly more efficient than using a CPU-bound<br/>
		/// SDL_Surface if you don't need to manipulate the image directly after<br/>
		/// loading it.<br/>
		/// If the loaded image has transparency or a colorkey, a texture with an alpha<br/>
		/// channel will be created. Otherwise, SDL_image will attempt to create an<br/>
		/// SDL_Texture in the most format that most reasonably represents the image<br/>
		/// data (but in many cases, this will just end up being 32-bit RGB or 32-bit<br/>
		/// RGBA).<br/>
		/// If `freesrc` is non-zero, the RWops will be closed before returning,<br/>
		/// whether this function succeeds or not. SDL_image reads everything it needs<br/>
		/// from the RWops during this call in any case.<br/>
		/// Even though this function accepts a file type, SDL_image may still try<br/>
		/// other decoders that are capable of detecting file type from the contents of<br/>
		/// the image data, but may rely on the caller-provided type string for formats<br/>
		/// that it cannot autodetect. If `type` is NULL, SDL_image will rely solely on<br/>
		/// its ability to guess the format.<br/>
		/// There is a separate function to read files from disk without having to deal<br/>
		/// with SDL_RWops: `IMG_LoadTexture("filename.jpg")` will call this function<br/>
		/// and manage those details for you, determining the file type from the<br/>
		/// filename's extension.<br/>
		/// There is also IMG_LoadTexture_RW(), which is equivalent to this function<br/>
		/// except that it will rely on SDL_image to determine what type of data it is<br/>
		/// loading, much like passing a NULL for type.<br/>
		/// If you would rather decode an image to an SDL_Surface (a buffer of pixels<br/>
		/// in CPU memory), call IMG_LoadTyped_RW() instead.<br/>
		/// When done with the returned texture, the app should dispose of it with a<br/>
		/// call to SDL_DestroyTexture().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadTextureTyped_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Texture *")]
		public static SDLTexture* LoadTextureTypedRW([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer *")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] ref SDLRWops src, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "char const *")] ref byte type)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLRWops* psrc = &src)
				{
					fixed (byte* ptype = &type)
					{
						SDLTexture* ret = LoadTextureTypedRWNative((SDLRenderer*)prenderer, (SDLRWops*)psrc, freesrc, (byte*)ptype);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Load an image from an SDL data source into a GPU texture.<br/>
		/// An SDL_Texture represents an image in GPU memory, usable by SDL's 2D Render<br/>
		/// API. This can be significantly more efficient than using a CPU-bound<br/>
		/// SDL_Surface if you don't need to manipulate the image directly after<br/>
		/// loading it.<br/>
		/// If the loaded image has transparency or a colorkey, a texture with an alpha<br/>
		/// channel will be created. Otherwise, SDL_image will attempt to create an<br/>
		/// SDL_Texture in the most format that most reasonably represents the image<br/>
		/// data (but in many cases, this will just end up being 32-bit RGB or 32-bit<br/>
		/// RGBA).<br/>
		/// If `freesrc` is non-zero, the RWops will be closed before returning,<br/>
		/// whether this function succeeds or not. SDL_image reads everything it needs<br/>
		/// from the RWops during this call in any case.<br/>
		/// Even though this function accepts a file type, SDL_image may still try<br/>
		/// other decoders that are capable of detecting file type from the contents of<br/>
		/// the image data, but may rely on the caller-provided type string for formats<br/>
		/// that it cannot autodetect. If `type` is NULL, SDL_image will rely solely on<br/>
		/// its ability to guess the format.<br/>
		/// There is a separate function to read files from disk without having to deal<br/>
		/// with SDL_RWops: `IMG_LoadTexture("filename.jpg")` will call this function<br/>
		/// and manage those details for you, determining the file type from the<br/>
		/// filename's extension.<br/>
		/// There is also IMG_LoadTexture_RW(), which is equivalent to this function<br/>
		/// except that it will rely on SDL_image to determine what type of data it is<br/>
		/// loading, much like passing a NULL for type.<br/>
		/// If you would rather decode an image to an SDL_Surface (a buffer of pixels<br/>
		/// in CPU memory), call IMG_LoadTyped_RW() instead.<br/>
		/// When done with the returned texture, the app should dispose of it with a<br/>
		/// call to SDL_DestroyTexture().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadTextureTyped_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Texture *")]
		public static SDLTexture* LoadTextureTypedRW([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer *")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] ref SDLRWops src, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> type)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLRWops* psrc = &src)
				{
					fixed (byte* ptype = type)
					{
						SDLTexture* ret = LoadTextureTypedRWNative((SDLRenderer*)prenderer, (SDLRWops*)psrc, freesrc, (byte*)ptype);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Load an image from an SDL data source into a GPU texture.<br/>
		/// An SDL_Texture represents an image in GPU memory, usable by SDL's 2D Render<br/>
		/// API. This can be significantly more efficient than using a CPU-bound<br/>
		/// SDL_Surface if you don't need to manipulate the image directly after<br/>
		/// loading it.<br/>
		/// If the loaded image has transparency or a colorkey, a texture with an alpha<br/>
		/// channel will be created. Otherwise, SDL_image will attempt to create an<br/>
		/// SDL_Texture in the most format that most reasonably represents the image<br/>
		/// data (but in many cases, this will just end up being 32-bit RGB or 32-bit<br/>
		/// RGBA).<br/>
		/// If `freesrc` is non-zero, the RWops will be closed before returning,<br/>
		/// whether this function succeeds or not. SDL_image reads everything it needs<br/>
		/// from the RWops during this call in any case.<br/>
		/// Even though this function accepts a file type, SDL_image may still try<br/>
		/// other decoders that are capable of detecting file type from the contents of<br/>
		/// the image data, but may rely on the caller-provided type string for formats<br/>
		/// that it cannot autodetect. If `type` is NULL, SDL_image will rely solely on<br/>
		/// its ability to guess the format.<br/>
		/// There is a separate function to read files from disk without having to deal<br/>
		/// with SDL_RWops: `IMG_LoadTexture("filename.jpg")` will call this function<br/>
		/// and manage those details for you, determining the file type from the<br/>
		/// filename's extension.<br/>
		/// There is also IMG_LoadTexture_RW(), which is equivalent to this function<br/>
		/// except that it will rely on SDL_image to determine what type of data it is<br/>
		/// loading, much like passing a NULL for type.<br/>
		/// If you would rather decode an image to an SDL_Surface (a buffer of pixels<br/>
		/// in CPU memory), call IMG_LoadTyped_RW() instead.<br/>
		/// When done with the returned texture, the app should dispose of it with a<br/>
		/// call to SDL_DestroyTexture().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadTextureTyped_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Texture *")]
		public static SDLTexture* LoadTextureTypedRW([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer *")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] ref SDLRWops src, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "char const *")] string type)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLRWops* psrc = &src)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (type != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(type);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(type, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					SDLTexture* ret = LoadTextureTypedRWNative((SDLRenderer*)prenderer, (SDLRWops*)psrc, freesrc, pStr0);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		/// <summary>
		/// Detect AVIF image data on a readable/seekable SDL_RWops.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_RWops (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek the RWops back to where it<br/>
		/// started when this function was called, but it will not report any errors in<br/>
		/// doing so, but assuming seeking works, this means you can immediately use<br/>
		/// this with a different IMG_isTYPE function, or load the image without<br/>
		/// further seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isAVIF")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int IsAVIFNative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] SDLRWops* src)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, int>)funcTable[9])(src);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[9])((nint)src);
			#endif
		}

		/// <summary>
		/// Detect AVIF image data on a readable/seekable SDL_RWops.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_RWops (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek the RWops back to where it<br/>
		/// started when this function was called, but it will not report any errors in<br/>
		/// doing so, but assuming seeking works, this means you can immediately use<br/>
		/// this with a different IMG_isTYPE function, or load the image without<br/>
		/// further seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isAVIF")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int IsAVIF([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] SDLRWops* src)
		{
			int ret = IsAVIFNative(src);
			return ret;
		}

		/// <summary>
		/// Detect AVIF image data on a readable/seekable SDL_RWops.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_RWops (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek the RWops back to where it<br/>
		/// started when this function was called, but it will not report any errors in<br/>
		/// doing so, but assuming seeking works, this means you can immediately use<br/>
		/// this with a different IMG_isTYPE function, or load the image without<br/>
		/// further seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isAVIF")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int IsAVIF([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] ref SDLRWops src)
		{
			fixed (SDLRWops* psrc = &src)
			{
				int ret = IsAVIFNative((SDLRWops*)psrc);
				return ret;
			}
		}

		/// <summary>
		/// Detect ICO image data on a readable/seekable SDL_RWops.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_RWops (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek the RWops back to where it<br/>
		/// started when this function was called, but it will not report any errors in<br/>
		/// doing so, but assuming seeking works, this means you can immediately use<br/>
		/// this with a different IMG_isTYPE function, or load the image without<br/>
		/// further seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isICO")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int IsICONative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] SDLRWops* src)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, int>)funcTable[10])(src);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[10])((nint)src);
			#endif
		}

		/// <summary>
		/// Detect ICO image data on a readable/seekable SDL_RWops.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_RWops (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek the RWops back to where it<br/>
		/// started when this function was called, but it will not report any errors in<br/>
		/// doing so, but assuming seeking works, this means you can immediately use<br/>
		/// this with a different IMG_isTYPE function, or load the image without<br/>
		/// further seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isICO")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int IsICO([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] SDLRWops* src)
		{
			int ret = IsICONative(src);
			return ret;
		}

		/// <summary>
		/// Detect ICO image data on a readable/seekable SDL_RWops.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_RWops (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek the RWops back to where it<br/>
		/// started when this function was called, but it will not report any errors in<br/>
		/// doing so, but assuming seeking works, this means you can immediately use<br/>
		/// this with a different IMG_isTYPE function, or load the image without<br/>
		/// further seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isICO")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int IsICO([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] ref SDLRWops src)
		{
			fixed (SDLRWops* psrc = &src)
			{
				int ret = IsICONative((SDLRWops*)psrc);
				return ret;
			}
		}

		/// <summary>
		/// Detect CUR image data on a readable/seekable SDL_RWops.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_RWops (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek the RWops back to where it<br/>
		/// started when this function was called, but it will not report any errors in<br/>
		/// doing so, but assuming seeking works, this means you can immediately use<br/>
		/// this with a different IMG_isTYPE function, or load the image without<br/>
		/// further seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isCUR")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int IsCURNative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] SDLRWops* src)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, int>)funcTable[11])(src);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[11])((nint)src);
			#endif
		}

		/// <summary>
		/// Detect CUR image data on a readable/seekable SDL_RWops.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_RWops (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek the RWops back to where it<br/>
		/// started when this function was called, but it will not report any errors in<br/>
		/// doing so, but assuming seeking works, this means you can immediately use<br/>
		/// this with a different IMG_isTYPE function, or load the image without<br/>
		/// further seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isCUR")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int IsCUR([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] SDLRWops* src)
		{
			int ret = IsCURNative(src);
			return ret;
		}

		/// <summary>
		/// Detect CUR image data on a readable/seekable SDL_RWops.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_RWops (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek the RWops back to where it<br/>
		/// started when this function was called, but it will not report any errors in<br/>
		/// doing so, but assuming seeking works, this means you can immediately use<br/>
		/// this with a different IMG_isTYPE function, or load the image without<br/>
		/// further seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isCUR")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int IsCUR([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] ref SDLRWops src)
		{
			fixed (SDLRWops* psrc = &src)
			{
				int ret = IsCURNative((SDLRWops*)psrc);
				return ret;
			}
		}

		/// <summary>
		/// Detect BMP image data on a readable/seekable SDL_RWops.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_RWops (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek the RWops back to where it<br/>
		/// started when this function was called, but it will not report any errors in<br/>
		/// doing so, but assuming seeking works, this means you can immediately use<br/>
		/// this with a different IMG_isTYPE function, or load the image without<br/>
		/// further seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isBMP")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int IsBMPNative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] SDLRWops* src)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, int>)funcTable[12])(src);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[12])((nint)src);
			#endif
		}

		/// <summary>
		/// Detect BMP image data on a readable/seekable SDL_RWops.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_RWops (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek the RWops back to where it<br/>
		/// started when this function was called, but it will not report any errors in<br/>
		/// doing so, but assuming seeking works, this means you can immediately use<br/>
		/// this with a different IMG_isTYPE function, or load the image without<br/>
		/// further seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isBMP")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int IsBMP([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] SDLRWops* src)
		{
			int ret = IsBMPNative(src);
			return ret;
		}

		/// <summary>
		/// Detect BMP image data on a readable/seekable SDL_RWops.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_RWops (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek the RWops back to where it<br/>
		/// started when this function was called, but it will not report any errors in<br/>
		/// doing so, but assuming seeking works, this means you can immediately use<br/>
		/// this with a different IMG_isTYPE function, or load the image without<br/>
		/// further seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isBMP")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int IsBMP([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] ref SDLRWops src)
		{
			fixed (SDLRWops* psrc = &src)
			{
				int ret = IsBMPNative((SDLRWops*)psrc);
				return ret;
			}
		}

		/// <summary>
		/// Detect GIF image data on a readable/seekable SDL_RWops.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_RWops (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek the RWops back to where it<br/>
		/// started when this function was called, but it will not report any errors in<br/>
		/// doing so, but assuming seeking works, this means you can immediately use<br/>
		/// this with a different IMG_isTYPE function, or load the image without<br/>
		/// further seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isGIF")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int IsGIFNative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] SDLRWops* src)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, int>)funcTable[13])(src);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[13])((nint)src);
			#endif
		}

		/// <summary>
		/// Detect GIF image data on a readable/seekable SDL_RWops.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_RWops (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek the RWops back to where it<br/>
		/// started when this function was called, but it will not report any errors in<br/>
		/// doing so, but assuming seeking works, this means you can immediately use<br/>
		/// this with a different IMG_isTYPE function, or load the image without<br/>
		/// further seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isGIF")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int IsGIF([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] SDLRWops* src)
		{
			int ret = IsGIFNative(src);
			return ret;
		}

		/// <summary>
		/// Detect GIF image data on a readable/seekable SDL_RWops.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_RWops (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek the RWops back to where it<br/>
		/// started when this function was called, but it will not report any errors in<br/>
		/// doing so, but assuming seeking works, this means you can immediately use<br/>
		/// this with a different IMG_isTYPE function, or load the image without<br/>
		/// further seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isGIF")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int IsGIF([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] ref SDLRWops src)
		{
			fixed (SDLRWops* psrc = &src)
			{
				int ret = IsGIFNative((SDLRWops*)psrc);
				return ret;
			}
		}

		/// <summary>
		/// Detect JPG image data on a readable/seekable SDL_RWops.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_RWops (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek the RWops back to where it<br/>
		/// started when this function was called, but it will not report any errors in<br/>
		/// doing so, but assuming seeking works, this means you can immediately use<br/>
		/// this with a different IMG_isTYPE function, or load the image without<br/>
		/// further seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isJPG")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int IsJPGNative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] SDLRWops* src)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, int>)funcTable[14])(src);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[14])((nint)src);
			#endif
		}

		/// <summary>
		/// Detect JPG image data on a readable/seekable SDL_RWops.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_RWops (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek the RWops back to where it<br/>
		/// started when this function was called, but it will not report any errors in<br/>
		/// doing so, but assuming seeking works, this means you can immediately use<br/>
		/// this with a different IMG_isTYPE function, or load the image without<br/>
		/// further seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isJPG")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int IsJPG([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] SDLRWops* src)
		{
			int ret = IsJPGNative(src);
			return ret;
		}

		/// <summary>
		/// Detect JPG image data on a readable/seekable SDL_RWops.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_RWops (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek the RWops back to where it<br/>
		/// started when this function was called, but it will not report any errors in<br/>
		/// doing so, but assuming seeking works, this means you can immediately use<br/>
		/// this with a different IMG_isTYPE function, or load the image without<br/>
		/// further seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isJPG")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int IsJPG([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] ref SDLRWops src)
		{
			fixed (SDLRWops* psrc = &src)
			{
				int ret = IsJPGNative((SDLRWops*)psrc);
				return ret;
			}
		}

		/// <summary>
		/// Detect JXL image data on a readable/seekable SDL_RWops.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_RWops (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek the RWops back to where it<br/>
		/// started when this function was called, but it will not report any errors in<br/>
		/// doing so, but assuming seeking works, this means you can immediately use<br/>
		/// this with a different IMG_isTYPE function, or load the image without<br/>
		/// further seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isJXL")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int IsJXLNative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] SDLRWops* src)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, int>)funcTable[15])(src);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[15])((nint)src);
			#endif
		}

		/// <summary>
		/// Detect JXL image data on a readable/seekable SDL_RWops.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_RWops (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek the RWops back to where it<br/>
		/// started when this function was called, but it will not report any errors in<br/>
		/// doing so, but assuming seeking works, this means you can immediately use<br/>
		/// this with a different IMG_isTYPE function, or load the image without<br/>
		/// further seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isJXL")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int IsJXL([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] SDLRWops* src)
		{
			int ret = IsJXLNative(src);
			return ret;
		}

		/// <summary>
		/// Detect JXL image data on a readable/seekable SDL_RWops.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_RWops (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek the RWops back to where it<br/>
		/// started when this function was called, but it will not report any errors in<br/>
		/// doing so, but assuming seeking works, this means you can immediately use<br/>
		/// this with a different IMG_isTYPE function, or load the image without<br/>
		/// further seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isJXL")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int IsJXL([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] ref SDLRWops src)
		{
			fixed (SDLRWops* psrc = &src)
			{
				int ret = IsJXLNative((SDLRWops*)psrc);
				return ret;
			}
		}

		/// <summary>
		/// Detect LBM image data on a readable/seekable SDL_RWops.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_RWops (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek the RWops back to where it<br/>
		/// started when this function was called, but it will not report any errors in<br/>
		/// doing so, but assuming seeking works, this means you can immediately use<br/>
		/// this with a different IMG_isTYPE function, or load the image without<br/>
		/// further seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isLBM")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int IsLBMNative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] SDLRWops* src)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, int>)funcTable[16])(src);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[16])((nint)src);
			#endif
		}

		/// <summary>
		/// Detect LBM image data on a readable/seekable SDL_RWops.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_RWops (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek the RWops back to where it<br/>
		/// started when this function was called, but it will not report any errors in<br/>
		/// doing so, but assuming seeking works, this means you can immediately use<br/>
		/// this with a different IMG_isTYPE function, or load the image without<br/>
		/// further seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isLBM")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int IsLBM([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] SDLRWops* src)
		{
			int ret = IsLBMNative(src);
			return ret;
		}

		/// <summary>
		/// Detect LBM image data on a readable/seekable SDL_RWops.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_RWops (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek the RWops back to where it<br/>
		/// started when this function was called, but it will not report any errors in<br/>
		/// doing so, but assuming seeking works, this means you can immediately use<br/>
		/// this with a different IMG_isTYPE function, or load the image without<br/>
		/// further seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isLBM")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int IsLBM([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] ref SDLRWops src)
		{
			fixed (SDLRWops* psrc = &src)
			{
				int ret = IsLBMNative((SDLRWops*)psrc);
				return ret;
			}
		}

		/// <summary>
		/// Detect PCX image data on a readable/seekable SDL_RWops.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_RWops (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek the RWops back to where it<br/>
		/// started when this function was called, but it will not report any errors in<br/>
		/// doing so, but assuming seeking works, this means you can immediately use<br/>
		/// this with a different IMG_isTYPE function, or load the image without<br/>
		/// further seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isPCX")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int IsPCXNative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] SDLRWops* src)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, int>)funcTable[17])(src);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[17])((nint)src);
			#endif
		}

		/// <summary>
		/// Detect PCX image data on a readable/seekable SDL_RWops.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_RWops (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek the RWops back to where it<br/>
		/// started when this function was called, but it will not report any errors in<br/>
		/// doing so, but assuming seeking works, this means you can immediately use<br/>
		/// this with a different IMG_isTYPE function, or load the image without<br/>
		/// further seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isPCX")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int IsPCX([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] SDLRWops* src)
		{
			int ret = IsPCXNative(src);
			return ret;
		}

		/// <summary>
		/// Detect PCX image data on a readable/seekable SDL_RWops.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_RWops (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek the RWops back to where it<br/>
		/// started when this function was called, but it will not report any errors in<br/>
		/// doing so, but assuming seeking works, this means you can immediately use<br/>
		/// this with a different IMG_isTYPE function, or load the image without<br/>
		/// further seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isPCX")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int IsPCX([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] ref SDLRWops src)
		{
			fixed (SDLRWops* psrc = &src)
			{
				int ret = IsPCXNative((SDLRWops*)psrc);
				return ret;
			}
		}

		/// <summary>
		/// Detect PNG image data on a readable/seekable SDL_RWops.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_RWops (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek the RWops back to where it<br/>
		/// started when this function was called, but it will not report any errors in<br/>
		/// doing so, but assuming seeking works, this means you can immediately use<br/>
		/// this with a different IMG_isTYPE function, or load the image without<br/>
		/// further seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isPNG")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int IsPNGNative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] SDLRWops* src)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, int>)funcTable[18])(src);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[18])((nint)src);
			#endif
		}

		/// <summary>
		/// Detect PNG image data on a readable/seekable SDL_RWops.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_RWops (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek the RWops back to where it<br/>
		/// started when this function was called, but it will not report any errors in<br/>
		/// doing so, but assuming seeking works, this means you can immediately use<br/>
		/// this with a different IMG_isTYPE function, or load the image without<br/>
		/// further seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isPNG")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int IsPNG([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] SDLRWops* src)
		{
			int ret = IsPNGNative(src);
			return ret;
		}

		/// <summary>
		/// Detect PNG image data on a readable/seekable SDL_RWops.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_RWops (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek the RWops back to where it<br/>
		/// started when this function was called, but it will not report any errors in<br/>
		/// doing so, but assuming seeking works, this means you can immediately use<br/>
		/// this with a different IMG_isTYPE function, or load the image without<br/>
		/// further seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isPNG")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int IsPNG([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] ref SDLRWops src)
		{
			fixed (SDLRWops* psrc = &src)
			{
				int ret = IsPNGNative((SDLRWops*)psrc);
				return ret;
			}
		}

		/// <summary>
		/// Detect PNM image data on a readable/seekable SDL_RWops.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_RWops (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek the RWops back to where it<br/>
		/// started when this function was called, but it will not report any errors in<br/>
		/// doing so, but assuming seeking works, this means you can immediately use<br/>
		/// this with a different IMG_isTYPE function, or load the image without<br/>
		/// further seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isPNM")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int IsPNMNative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] SDLRWops* src)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, int>)funcTable[19])(src);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[19])((nint)src);
			#endif
		}

		/// <summary>
		/// Detect PNM image data on a readable/seekable SDL_RWops.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_RWops (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek the RWops back to where it<br/>
		/// started when this function was called, but it will not report any errors in<br/>
		/// doing so, but assuming seeking works, this means you can immediately use<br/>
		/// this with a different IMG_isTYPE function, or load the image without<br/>
		/// further seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isPNM")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int IsPNM([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] SDLRWops* src)
		{
			int ret = IsPNMNative(src);
			return ret;
		}

		/// <summary>
		/// Detect PNM image data on a readable/seekable SDL_RWops.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_RWops (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek the RWops back to where it<br/>
		/// started when this function was called, but it will not report any errors in<br/>
		/// doing so, but assuming seeking works, this means you can immediately use<br/>
		/// this with a different IMG_isTYPE function, or load the image without<br/>
		/// further seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isPNM")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int IsPNM([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] ref SDLRWops src)
		{
			fixed (SDLRWops* psrc = &src)
			{
				int ret = IsPNMNative((SDLRWops*)psrc);
				return ret;
			}
		}

		/// <summary>
		/// Detect SVG image data on a readable/seekable SDL_RWops.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_RWops (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek the RWops back to where it<br/>
		/// started when this function was called, but it will not report any errors in<br/>
		/// doing so, but assuming seeking works, this means you can immediately use<br/>
		/// this with a different IMG_isTYPE function, or load the image without<br/>
		/// further seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isSVG")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int IsSVGNative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] SDLRWops* src)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, int>)funcTable[20])(src);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[20])((nint)src);
			#endif
		}

		/// <summary>
		/// Detect SVG image data on a readable/seekable SDL_RWops.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_RWops (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek the RWops back to where it<br/>
		/// started when this function was called, but it will not report any errors in<br/>
		/// doing so, but assuming seeking works, this means you can immediately use<br/>
		/// this with a different IMG_isTYPE function, or load the image without<br/>
		/// further seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isSVG")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int IsSVG([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] SDLRWops* src)
		{
			int ret = IsSVGNative(src);
			return ret;
		}

		/// <summary>
		/// Detect SVG image data on a readable/seekable SDL_RWops.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_RWops (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek the RWops back to where it<br/>
		/// started when this function was called, but it will not report any errors in<br/>
		/// doing so, but assuming seeking works, this means you can immediately use<br/>
		/// this with a different IMG_isTYPE function, or load the image without<br/>
		/// further seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isSVG")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int IsSVG([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] ref SDLRWops src)
		{
			fixed (SDLRWops* psrc = &src)
			{
				int ret = IsSVGNative((SDLRWops*)psrc);
				return ret;
			}
		}

		/// <summary>
		/// Detect QOI image data on a readable/seekable SDL_RWops.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_RWops (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek the RWops back to where it<br/>
		/// started when this function was called, but it will not report any errors in<br/>
		/// doing so, but assuming seeking works, this means you can immediately use<br/>
		/// this with a different IMG_isTYPE function, or load the image without<br/>
		/// further seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isQOI")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int IsQOINative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] SDLRWops* src)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, int>)funcTable[21])(src);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[21])((nint)src);
			#endif
		}

		/// <summary>
		/// Detect QOI image data on a readable/seekable SDL_RWops.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_RWops (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek the RWops back to where it<br/>
		/// started when this function was called, but it will not report any errors in<br/>
		/// doing so, but assuming seeking works, this means you can immediately use<br/>
		/// this with a different IMG_isTYPE function, or load the image without<br/>
		/// further seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isQOI")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int IsQOI([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] SDLRWops* src)
		{
			int ret = IsQOINative(src);
			return ret;
		}

		/// <summary>
		/// Detect QOI image data on a readable/seekable SDL_RWops.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_RWops (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek the RWops back to where it<br/>
		/// started when this function was called, but it will not report any errors in<br/>
		/// doing so, but assuming seeking works, this means you can immediately use<br/>
		/// this with a different IMG_isTYPE function, or load the image without<br/>
		/// further seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isQOI")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int IsQOI([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] ref SDLRWops src)
		{
			fixed (SDLRWops* psrc = &src)
			{
				int ret = IsQOINative((SDLRWops*)psrc);
				return ret;
			}
		}

		/// <summary>
		/// Detect TIFF image data on a readable/seekable SDL_RWops.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_RWops (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek the RWops back to where it<br/>
		/// started when this function was called, but it will not report any errors in<br/>
		/// doing so, but assuming seeking works, this means you can immediately use<br/>
		/// this with a different IMG_isTYPE function, or load the image without<br/>
		/// further seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isTIF")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int IsTIFNative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] SDLRWops* src)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, int>)funcTable[22])(src);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[22])((nint)src);
			#endif
		}

		/// <summary>
		/// Detect TIFF image data on a readable/seekable SDL_RWops.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_RWops (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek the RWops back to where it<br/>
		/// started when this function was called, but it will not report any errors in<br/>
		/// doing so, but assuming seeking works, this means you can immediately use<br/>
		/// this with a different IMG_isTYPE function, or load the image without<br/>
		/// further seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isTIF")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int IsTIF([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] SDLRWops* src)
		{
			int ret = IsTIFNative(src);
			return ret;
		}

		/// <summary>
		/// Detect TIFF image data on a readable/seekable SDL_RWops.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_RWops (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek the RWops back to where it<br/>
		/// started when this function was called, but it will not report any errors in<br/>
		/// doing so, but assuming seeking works, this means you can immediately use<br/>
		/// this with a different IMG_isTYPE function, or load the image without<br/>
		/// further seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isTIF")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int IsTIF([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] ref SDLRWops src)
		{
			fixed (SDLRWops* psrc = &src)
			{
				int ret = IsTIFNative((SDLRWops*)psrc);
				return ret;
			}
		}

		/// <summary>
		/// Detect XCF image data on a readable/seekable SDL_RWops.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_RWops (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek the RWops back to where it<br/>
		/// started when this function was called, but it will not report any errors in<br/>
		/// doing so, but assuming seeking works, this means you can immediately use<br/>
		/// this with a different IMG_isTYPE function, or load the image without<br/>
		/// further seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isXCF")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int IsXCFNative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] SDLRWops* src)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, int>)funcTable[23])(src);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[23])((nint)src);
			#endif
		}

		/// <summary>
		/// Detect XCF image data on a readable/seekable SDL_RWops.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_RWops (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek the RWops back to where it<br/>
		/// started when this function was called, but it will not report any errors in<br/>
		/// doing so, but assuming seeking works, this means you can immediately use<br/>
		/// this with a different IMG_isTYPE function, or load the image without<br/>
		/// further seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isXCF")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int IsXCF([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] SDLRWops* src)
		{
			int ret = IsXCFNative(src);
			return ret;
		}

		/// <summary>
		/// Detect XCF image data on a readable/seekable SDL_RWops.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_RWops (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek the RWops back to where it<br/>
		/// started when this function was called, but it will not report any errors in<br/>
		/// doing so, but assuming seeking works, this means you can immediately use<br/>
		/// this with a different IMG_isTYPE function, or load the image without<br/>
		/// further seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isXCF")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int IsXCF([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] ref SDLRWops src)
		{
			fixed (SDLRWops* psrc = &src)
			{
				int ret = IsXCFNative((SDLRWops*)psrc);
				return ret;
			}
		}

		/// <summary>
		/// Detect XPM image data on a readable/seekable SDL_RWops.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_RWops (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek the RWops back to where it<br/>
		/// started when this function was called, but it will not report any errors in<br/>
		/// doing so, but assuming seeking works, this means you can immediately use<br/>
		/// this with a different IMG_isTYPE function, or load the image without<br/>
		/// further seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isXPM")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int IsXPMNative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] SDLRWops* src)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, int>)funcTable[24])(src);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[24])((nint)src);
			#endif
		}

		/// <summary>
		/// Detect XPM image data on a readable/seekable SDL_RWops.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_RWops (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek the RWops back to where it<br/>
		/// started when this function was called, but it will not report any errors in<br/>
		/// doing so, but assuming seeking works, this means you can immediately use<br/>
		/// this with a different IMG_isTYPE function, or load the image without<br/>
		/// further seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isXPM")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int IsXPM([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] SDLRWops* src)
		{
			int ret = IsXPMNative(src);
			return ret;
		}

		/// <summary>
		/// Detect XPM image data on a readable/seekable SDL_RWops.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_RWops (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek the RWops back to where it<br/>
		/// started when this function was called, but it will not report any errors in<br/>
		/// doing so, but assuming seeking works, this means you can immediately use<br/>
		/// this with a different IMG_isTYPE function, or load the image without<br/>
		/// further seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isXPM")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int IsXPM([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] ref SDLRWops src)
		{
			fixed (SDLRWops* psrc = &src)
			{
				int ret = IsXPMNative((SDLRWops*)psrc);
				return ret;
			}
		}

		/// <summary>
		/// Detect XV image data on a readable/seekable SDL_RWops.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_RWops (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek the RWops back to where it<br/>
		/// started when this function was called, but it will not report any errors in<br/>
		/// doing so, but assuming seeking works, this means you can immediately use<br/>
		/// this with a different IMG_isTYPE function, or load the image without<br/>
		/// further seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isXV")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int IsXVNative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] SDLRWops* src)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, int>)funcTable[25])(src);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[25])((nint)src);
			#endif
		}

		/// <summary>
		/// Detect XV image data on a readable/seekable SDL_RWops.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_RWops (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek the RWops back to where it<br/>
		/// started when this function was called, but it will not report any errors in<br/>
		/// doing so, but assuming seeking works, this means you can immediately use<br/>
		/// this with a different IMG_isTYPE function, or load the image without<br/>
		/// further seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isXV")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int IsXV([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] SDLRWops* src)
		{
			int ret = IsXVNative(src);
			return ret;
		}

		/// <summary>
		/// Detect XV image data on a readable/seekable SDL_RWops.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_RWops (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek the RWops back to where it<br/>
		/// started when this function was called, but it will not report any errors in<br/>
		/// doing so, but assuming seeking works, this means you can immediately use<br/>
		/// this with a different IMG_isTYPE function, or load the image without<br/>
		/// further seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isXV")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int IsXV([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] ref SDLRWops src)
		{
			fixed (SDLRWops* psrc = &src)
			{
				int ret = IsXVNative((SDLRWops*)psrc);
				return ret;
			}
		}

		/// <summary>
		/// Detect WEBP image data on a readable/seekable SDL_RWops.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_RWops (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek the RWops back to where it<br/>
		/// started when this function was called, but it will not report any errors in<br/>
		/// doing so, but assuming seeking works, this means you can immediately use<br/>
		/// this with a different IMG_isTYPE function, or load the image without<br/>
		/// further seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isWEBP")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int IsWEBPNative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] SDLRWops* src)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, int>)funcTable[26])(src);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[26])((nint)src);
			#endif
		}

		/// <summary>
		/// Detect WEBP image data on a readable/seekable SDL_RWops.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_RWops (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek the RWops back to where it<br/>
		/// started when this function was called, but it will not report any errors in<br/>
		/// doing so, but assuming seeking works, this means you can immediately use<br/>
		/// this with a different IMG_isTYPE function, or load the image without<br/>
		/// further seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isWEBP")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int IsWEBP([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] SDLRWops* src)
		{
			int ret = IsWEBPNative(src);
			return ret;
		}

		/// <summary>
		/// Detect WEBP image data on a readable/seekable SDL_RWops.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_RWops (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek the RWops back to where it<br/>
		/// started when this function was called, but it will not report any errors in<br/>
		/// doing so, but assuming seeking works, this means you can immediately use<br/>
		/// this with a different IMG_isTYPE function, or load the image without<br/>
		/// further seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isWEBP")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int IsWEBP([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] ref SDLRWops src)
		{
			fixed (SDLRWops* psrc = &src)
			{
				int ret = IsWEBPNative((SDLRWops*)psrc);
				return ret;
			}
		}

		/// <summary>
		/// Load a AVIF image directly.<br/>
		/// If you know you definitely have a AVIF image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_RWops<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadAVIF_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLSurface* LoadAVIFRWNative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] SDLRWops* src)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, SDLSurface*>)funcTable[27])(src);
			#else
			return (SDLSurface*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[27])((nint)src);
			#endif
		}

		/// <summary>
		/// Load a AVIF image directly.<br/>
		/// If you know you definitely have a AVIF image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_RWops<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadAVIF_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurface* LoadAVIFRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] SDLRWops* src)
		{
			SDLSurface* ret = LoadAVIFRWNative(src);
			return ret;
		}

		/// <summary>
		/// Load a AVIF image directly.<br/>
		/// If you know you definitely have a AVIF image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_RWops<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadAVIF_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurface* LoadAVIFRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] ref SDLRWops src)
		{
			fixed (SDLRWops* psrc = &src)
			{
				SDLSurface* ret = LoadAVIFRWNative((SDLRWops*)psrc);
				return ret;
			}
		}

		/// <summary>
		/// Load a ICO image directly.<br/>
		/// If you know you definitely have a ICO image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_RWops<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadICO_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLSurface* LoadICORWNative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] SDLRWops* src)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, SDLSurface*>)funcTable[28])(src);
			#else
			return (SDLSurface*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[28])((nint)src);
			#endif
		}

		/// <summary>
		/// Load a ICO image directly.<br/>
		/// If you know you definitely have a ICO image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_RWops<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadICO_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurface* LoadICORW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] SDLRWops* src)
		{
			SDLSurface* ret = LoadICORWNative(src);
			return ret;
		}

		/// <summary>
		/// Load a ICO image directly.<br/>
		/// If you know you definitely have a ICO image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_RWops<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadICO_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurface* LoadICORW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] ref SDLRWops src)
		{
			fixed (SDLRWops* psrc = &src)
			{
				SDLSurface* ret = LoadICORWNative((SDLRWops*)psrc);
				return ret;
			}
		}

		/// <summary>
		/// Load a CUR image directly.<br/>
		/// If you know you definitely have a CUR image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_RWops<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadCUR_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLSurface* LoadCURRWNative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] SDLRWops* src)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, SDLSurface*>)funcTable[29])(src);
			#else
			return (SDLSurface*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[29])((nint)src);
			#endif
		}

		/// <summary>
		/// Load a CUR image directly.<br/>
		/// If you know you definitely have a CUR image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_RWops<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadCUR_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurface* LoadCURRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] SDLRWops* src)
		{
			SDLSurface* ret = LoadCURRWNative(src);
			return ret;
		}

		/// <summary>
		/// Load a CUR image directly.<br/>
		/// If you know you definitely have a CUR image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_RWops<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadCUR_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurface* LoadCURRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] ref SDLRWops src)
		{
			fixed (SDLRWops* psrc = &src)
			{
				SDLSurface* ret = LoadCURRWNative((SDLRWops*)psrc);
				return ret;
			}
		}

		/// <summary>
		/// Load a BMP image directly.<br/>
		/// If you know you definitely have a BMP image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_RWops<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadBMP_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLSurface* LoadBMPRWNative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] SDLRWops* src)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, SDLSurface*>)funcTable[30])(src);
			#else
			return (SDLSurface*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[30])((nint)src);
			#endif
		}

		/// <summary>
		/// Load a BMP image directly.<br/>
		/// If you know you definitely have a BMP image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_RWops<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadBMP_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurface* LoadBMPRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] SDLRWops* src)
		{
			SDLSurface* ret = LoadBMPRWNative(src);
			return ret;
		}

		/// <summary>
		/// Load a BMP image directly.<br/>
		/// If you know you definitely have a BMP image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_RWops<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadBMP_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurface* LoadBMPRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] ref SDLRWops src)
		{
			fixed (SDLRWops* psrc = &src)
			{
				SDLSurface* ret = LoadBMPRWNative((SDLRWops*)psrc);
				return ret;
			}
		}

		/// <summary>
		/// Load a GIF image directly.<br/>
		/// If you know you definitely have a GIF image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_RWops<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadGIF_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLSurface* LoadGIFRWNative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] SDLRWops* src)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, SDLSurface*>)funcTable[31])(src);
			#else
			return (SDLSurface*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[31])((nint)src);
			#endif
		}

		/// <summary>
		/// Load a GIF image directly.<br/>
		/// If you know you definitely have a GIF image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_RWops<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadGIF_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurface* LoadGIFRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] SDLRWops* src)
		{
			SDLSurface* ret = LoadGIFRWNative(src);
			return ret;
		}

		/// <summary>
		/// Load a GIF image directly.<br/>
		/// If you know you definitely have a GIF image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_RWops<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadGIF_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurface* LoadGIFRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] ref SDLRWops src)
		{
			fixed (SDLRWops* psrc = &src)
			{
				SDLSurface* ret = LoadGIFRWNative((SDLRWops*)psrc);
				return ret;
			}
		}

		/// <summary>
		/// Load a JPG image directly.<br/>
		/// If you know you definitely have a JPG image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_RWops<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadJPG_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLSurface* LoadJPGRWNative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] SDLRWops* src)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, SDLSurface*>)funcTable[32])(src);
			#else
			return (SDLSurface*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[32])((nint)src);
			#endif
		}

		/// <summary>
		/// Load a JPG image directly.<br/>
		/// If you know you definitely have a JPG image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_RWops<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadJPG_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurface* LoadJPGRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] SDLRWops* src)
		{
			SDLSurface* ret = LoadJPGRWNative(src);
			return ret;
		}

		/// <summary>
		/// Load a JPG image directly.<br/>
		/// If you know you definitely have a JPG image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_RWops<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadJPG_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurface* LoadJPGRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] ref SDLRWops src)
		{
			fixed (SDLRWops* psrc = &src)
			{
				SDLSurface* ret = LoadJPGRWNative((SDLRWops*)psrc);
				return ret;
			}
		}

		/// <summary>
		/// Load a JXL image directly.<br/>
		/// If you know you definitely have a JXL image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_RWops<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadJXL_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLSurface* LoadJXLRWNative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] SDLRWops* src)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, SDLSurface*>)funcTable[33])(src);
			#else
			return (SDLSurface*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[33])((nint)src);
			#endif
		}

		/// <summary>
		/// Load a JXL image directly.<br/>
		/// If you know you definitely have a JXL image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_RWops<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadJXL_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurface* LoadJXLRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] SDLRWops* src)
		{
			SDLSurface* ret = LoadJXLRWNative(src);
			return ret;
		}

		/// <summary>
		/// Load a JXL image directly.<br/>
		/// If you know you definitely have a JXL image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_RWops<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadJXL_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurface* LoadJXLRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] ref SDLRWops src)
		{
			fixed (SDLRWops* psrc = &src)
			{
				SDLSurface* ret = LoadJXLRWNative((SDLRWops*)psrc);
				return ret;
			}
		}

		/// <summary>
		/// Load a LBM image directly.<br/>
		/// If you know you definitely have a LBM image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_RWops<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadLBM_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLSurface* LoadLBMRWNative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] SDLRWops* src)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, SDLSurface*>)funcTable[34])(src);
			#else
			return (SDLSurface*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[34])((nint)src);
			#endif
		}

		/// <summary>
		/// Load a LBM image directly.<br/>
		/// If you know you definitely have a LBM image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_RWops<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadLBM_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurface* LoadLBMRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] SDLRWops* src)
		{
			SDLSurface* ret = LoadLBMRWNative(src);
			return ret;
		}

		/// <summary>
		/// Load a LBM image directly.<br/>
		/// If you know you definitely have a LBM image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_RWops<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadLBM_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurface* LoadLBMRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] ref SDLRWops src)
		{
			fixed (SDLRWops* psrc = &src)
			{
				SDLSurface* ret = LoadLBMRWNative((SDLRWops*)psrc);
				return ret;
			}
		}

		/// <summary>
		/// Load a PCX image directly.<br/>
		/// If you know you definitely have a PCX image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_RWops<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadPCX_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLSurface* LoadPCXRWNative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] SDLRWops* src)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, SDLSurface*>)funcTable[35])(src);
			#else
			return (SDLSurface*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[35])((nint)src);
			#endif
		}

		/// <summary>
		/// Load a PCX image directly.<br/>
		/// If you know you definitely have a PCX image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_RWops<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadPCX_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurface* LoadPCXRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] SDLRWops* src)
		{
			SDLSurface* ret = LoadPCXRWNative(src);
			return ret;
		}

		/// <summary>
		/// Load a PCX image directly.<br/>
		/// If you know you definitely have a PCX image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_RWops<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadPCX_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurface* LoadPCXRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] ref SDLRWops src)
		{
			fixed (SDLRWops* psrc = &src)
			{
				SDLSurface* ret = LoadPCXRWNative((SDLRWops*)psrc);
				return ret;
			}
		}

		/// <summary>
		/// Load a PNG image directly.<br/>
		/// If you know you definitely have a PNG image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_RWops<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadPNG_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLSurface* LoadPNGRWNative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] SDLRWops* src)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, SDLSurface*>)funcTable[36])(src);
			#else
			return (SDLSurface*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[36])((nint)src);
			#endif
		}

		/// <summary>
		/// Load a PNG image directly.<br/>
		/// If you know you definitely have a PNG image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_RWops<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadPNG_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurface* LoadPNGRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] SDLRWops* src)
		{
			SDLSurface* ret = LoadPNGRWNative(src);
			return ret;
		}

		/// <summary>
		/// Load a PNG image directly.<br/>
		/// If you know you definitely have a PNG image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_RWops<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadPNG_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurface* LoadPNGRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] ref SDLRWops src)
		{
			fixed (SDLRWops* psrc = &src)
			{
				SDLSurface* ret = LoadPNGRWNative((SDLRWops*)psrc);
				return ret;
			}
		}

		/// <summary>
		/// Load a PNM image directly.<br/>
		/// If you know you definitely have a PNM image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_RWops<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadPNM_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLSurface* LoadPNMRWNative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] SDLRWops* src)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, SDLSurface*>)funcTable[37])(src);
			#else
			return (SDLSurface*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[37])((nint)src);
			#endif
		}

		/// <summary>
		/// Load a PNM image directly.<br/>
		/// If you know you definitely have a PNM image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_RWops<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadPNM_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurface* LoadPNMRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] SDLRWops* src)
		{
			SDLSurface* ret = LoadPNMRWNative(src);
			return ret;
		}

		/// <summary>
		/// Load a PNM image directly.<br/>
		/// If you know you definitely have a PNM image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_RWops<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadPNM_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurface* LoadPNMRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] ref SDLRWops src)
		{
			fixed (SDLRWops* psrc = &src)
			{
				SDLSurface* ret = LoadPNMRWNative((SDLRWops*)psrc);
				return ret;
			}
		}

		/// <summary>
		/// Load a SVG image directly.<br/>
		/// If you know you definitely have a SVG image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_RWops<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadSVG_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLSurface* LoadSVGRWNative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] SDLRWops* src)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, SDLSurface*>)funcTable[38])(src);
			#else
			return (SDLSurface*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[38])((nint)src);
			#endif
		}

		/// <summary>
		/// Load a SVG image directly.<br/>
		/// If you know you definitely have a SVG image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_RWops<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadSVG_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurface* LoadSVGRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] SDLRWops* src)
		{
			SDLSurface* ret = LoadSVGRWNative(src);
			return ret;
		}

		/// <summary>
		/// Load a SVG image directly.<br/>
		/// If you know you definitely have a SVG image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_RWops<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadSVG_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurface* LoadSVGRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] ref SDLRWops src)
		{
			fixed (SDLRWops* psrc = &src)
			{
				SDLSurface* ret = LoadSVGRWNative((SDLRWops*)psrc);
				return ret;
			}
		}

		/// <summary>
		/// Load a QOI image directly.<br/>
		/// If you know you definitely have a QOI image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_RWops<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadQOI_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLSurface* LoadQOIRWNative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] SDLRWops* src)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, SDLSurface*>)funcTable[39])(src);
			#else
			return (SDLSurface*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[39])((nint)src);
			#endif
		}

		/// <summary>
		/// Load a QOI image directly.<br/>
		/// If you know you definitely have a QOI image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_RWops<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadQOI_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurface* LoadQOIRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] SDLRWops* src)
		{
			SDLSurface* ret = LoadQOIRWNative(src);
			return ret;
		}

		/// <summary>
		/// Load a QOI image directly.<br/>
		/// If you know you definitely have a QOI image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_RWops<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadQOI_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurface* LoadQOIRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] ref SDLRWops src)
		{
			fixed (SDLRWops* psrc = &src)
			{
				SDLSurface* ret = LoadQOIRWNative((SDLRWops*)psrc);
				return ret;
			}
		}

		/// <summary>
		/// Load a TGA image directly.<br/>
		/// If you know you definitely have a TGA image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_RWops<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadTGA_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLSurface* LoadTGARWNative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] SDLRWops* src)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, SDLSurface*>)funcTable[40])(src);
			#else
			return (SDLSurface*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[40])((nint)src);
			#endif
		}

		/// <summary>
		/// Load a TGA image directly.<br/>
		/// If you know you definitely have a TGA image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_RWops<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadTGA_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurface* LoadTGARW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] SDLRWops* src)
		{
			SDLSurface* ret = LoadTGARWNative(src);
			return ret;
		}

		/// <summary>
		/// Load a TGA image directly.<br/>
		/// If you know you definitely have a TGA image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_RWops<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadTGA_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurface* LoadTGARW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] ref SDLRWops src)
		{
			fixed (SDLRWops* psrc = &src)
			{
				SDLSurface* ret = LoadTGARWNative((SDLRWops*)psrc);
				return ret;
			}
		}

		/// <summary>
		/// Load a TIFF image directly.<br/>
		/// If you know you definitely have a TIFF image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_RWops<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadTIF_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLSurface* LoadTIFRWNative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] SDLRWops* src)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, SDLSurface*>)funcTable[41])(src);
			#else
			return (SDLSurface*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[41])((nint)src);
			#endif
		}

		/// <summary>
		/// Load a TIFF image directly.<br/>
		/// If you know you definitely have a TIFF image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_RWops<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadTIF_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurface* LoadTIFRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] SDLRWops* src)
		{
			SDLSurface* ret = LoadTIFRWNative(src);
			return ret;
		}

		/// <summary>
		/// Load a TIFF image directly.<br/>
		/// If you know you definitely have a TIFF image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_RWops<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadTIF_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurface* LoadTIFRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] ref SDLRWops src)
		{
			fixed (SDLRWops* psrc = &src)
			{
				SDLSurface* ret = LoadTIFRWNative((SDLRWops*)psrc);
				return ret;
			}
		}

		/// <summary>
		/// Load a XCF image directly.<br/>
		/// If you know you definitely have a XCF image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_RWops<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadXCF_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLSurface* LoadXCFRWNative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] SDLRWops* src)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, SDLSurface*>)funcTable[42])(src);
			#else
			return (SDLSurface*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[42])((nint)src);
			#endif
		}

		/// <summary>
		/// Load a XCF image directly.<br/>
		/// If you know you definitely have a XCF image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_RWops<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadXCF_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurface* LoadXCFRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] SDLRWops* src)
		{
			SDLSurface* ret = LoadXCFRWNative(src);
			return ret;
		}

		/// <summary>
		/// Load a XCF image directly.<br/>
		/// If you know you definitely have a XCF image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_RWops<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadXCF_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurface* LoadXCFRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] ref SDLRWops src)
		{
			fixed (SDLRWops* psrc = &src)
			{
				SDLSurface* ret = LoadXCFRWNative((SDLRWops*)psrc);
				return ret;
			}
		}

		/// <summary>
		/// Load a XPM image directly.<br/>
		/// If you know you definitely have a XPM image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_RWops<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadXPM_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLSurface* LoadXPMRWNative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] SDLRWops* src)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, SDLSurface*>)funcTable[43])(src);
			#else
			return (SDLSurface*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[43])((nint)src);
			#endif
		}

		/// <summary>
		/// Load a XPM image directly.<br/>
		/// If you know you definitely have a XPM image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_RWops<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadXPM_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurface* LoadXPMRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] SDLRWops* src)
		{
			SDLSurface* ret = LoadXPMRWNative(src);
			return ret;
		}

		/// <summary>
		/// Load a XPM image directly.<br/>
		/// If you know you definitely have a XPM image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_RWops<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadXPM_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurface* LoadXPMRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] ref SDLRWops src)
		{
			fixed (SDLRWops* psrc = &src)
			{
				SDLSurface* ret = LoadXPMRWNative((SDLRWops*)psrc);
				return ret;
			}
		}

		/// <summary>
		/// Load a XV image directly.<br/>
		/// If you know you definitely have a XV image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_RWops<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadXV_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLSurface* LoadXVRWNative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops *")] SDLRWops* src)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, SDLSurface*>)funcTable[44])(src);
			#else
			return (SDLSurface*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[44])((nint)src);
			#endif
		}
	}
}
