// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;
using Hexa.NET.SDL2;

namespace Hexa.NET.SDL2.Image
{
	public unsafe partial class SDLImage
	{
		/// <summary>
		/// This function gets the version of the dynamically linked SDL_image library.<br/>
		/// it should NOT be used to fill a version structure, instead you should use<br/>
		/// the SDL_IMAGE_VERSION() macro.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_Linked_Version")]
		[return: NativeName(NativeNameType.Type, "const SDL_version*")]
		internal static SDLVersion* IMGLinkedVersionNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLVersion*>)vt[0])();
			#else
			return (SDLVersion*)((delegate* unmanaged[Cdecl]<nint>)vt[0])();
			#endif
		}

		/// <summary>
		/// This function gets the version of the dynamically linked SDL_image library.<br/>
		/// it should NOT be used to fill a version structure, instead you should use<br/>
		/// the SDL_IMAGE_VERSION() macro.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_Linked_Version")]
		[return: NativeName(NativeNameType.Type, "const SDL_version*")]
		public static SDLVersion* IMGLinkedVersion()
		{
			SDLVersion* ret = IMGLinkedVersionNative();
			return ret;
		}

		/// <summary>
		/// Initialize SDL_image.<br/>
		/// This function loads dynamic libraries that SDL_image needs, and prepares<br/>
		/// them for use. This must be the first function you call in SDL_image, and if<br/>
		/// it fails you should not continue with the library.<br/>
		/// Flags should be one or more flags from IMG_InitFlags OR'd together. It<br/>
		/// returns the flags successfully initialized, or 0 on failure.<br/>
		/// Currently, these flags are:<br/>
		/// - `IMG_INIT_JPG`<br/>
		/// - `IMG_INIT_PNG`<br/>
		/// - `IMG_INIT_TIF`<br/>
		/// - `IMG_INIT_WEBP`<br/>
		/// - `IMG_INIT_JXL`<br/>
		/// - `IMG_INIT_AVIF`<br/>
		/// More flags may be added in a future SDL_image release.<br/>
		/// This function may need to load external shared libraries to support various<br/>
		/// codecs, which means this function can fail to initialize that support on an<br/>
		/// otherwise-reasonable system if the library isn't available; this is not<br/>
		/// just a question of exceptional circumstances like running out of memory at<br/>
		/// startup!<br/>
		/// Note that you may call this function more than once to initialize with<br/>
		/// additional flags. The return value will reflect both new flags that<br/>
		/// successfully initialized, and also include flags that had previously been<br/>
		/// initialized as well.<br/>
		/// As this will return previously-initialized flags, it's legal to call this<br/>
		/// with zero (no flags set). This is a safe no-op that can be used to query<br/>
		/// the current initialization state without changing it at all.<br/>
		/// Since this returns previously-initialized flags as well as new ones, and<br/>
		/// you can call this with zero, you should not check for a zero return value<br/>
		/// to determine an error condition. Instead, you should check to make sure all<br/>
		/// the flags you require are set in the return value. If you have a game with<br/>
		/// data in a specific format, this might be a fatal error. If you're a generic<br/>
		/// image displaying app, perhaps you are fine with only having JPG and PNG<br/>
		/// support and can live without WEBP, even if you request support for<br/>
		/// everything.<br/>
		/// Unlike other SDL satellite libraries, calls to IMG_Init do not stack; a<br/>
		/// single call to IMG_Quit() will deinitialize everything and does not have to<br/>
		/// be paired with a matching IMG_Init call. For that reason, it's considered<br/>
		/// best practices to have a single IMG_Init and IMG_Quit call in your program.<br/>
		/// While this isn't required, be aware of the risks of deviating from that<br/>
		/// behavior.<br/>
		/// After initializing SDL_image, the app may begin to load images into<br/>
		/// SDL_Surfaces or SDL_Textures.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_Init")]
		[return: NativeName(NativeNameType.Type, "int")]
		internal static int IMGInitNative([NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "int")] int flags)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, int>)vt[1])(flags);
			#else
			return (int)((delegate* unmanaged[Cdecl]<int, int>)vt[1])(flags);
			#endif
		}

		/// <summary>
		/// Initialize SDL_image.<br/>
		/// This function loads dynamic libraries that SDL_image needs, and prepares<br/>
		/// them for use. This must be the first function you call in SDL_image, and if<br/>
		/// it fails you should not continue with the library.<br/>
		/// Flags should be one or more flags from IMG_InitFlags OR'd together. It<br/>
		/// returns the flags successfully initialized, or 0 on failure.<br/>
		/// Currently, these flags are:<br/>
		/// - `IMG_INIT_JPG`<br/>
		/// - `IMG_INIT_PNG`<br/>
		/// - `IMG_INIT_TIF`<br/>
		/// - `IMG_INIT_WEBP`<br/>
		/// - `IMG_INIT_JXL`<br/>
		/// - `IMG_INIT_AVIF`<br/>
		/// More flags may be added in a future SDL_image release.<br/>
		/// This function may need to load external shared libraries to support various<br/>
		/// codecs, which means this function can fail to initialize that support on an<br/>
		/// otherwise-reasonable system if the library isn't available; this is not<br/>
		/// just a question of exceptional circumstances like running out of memory at<br/>
		/// startup!<br/>
		/// Note that you may call this function more than once to initialize with<br/>
		/// additional flags. The return value will reflect both new flags that<br/>
		/// successfully initialized, and also include flags that had previously been<br/>
		/// initialized as well.<br/>
		/// As this will return previously-initialized flags, it's legal to call this<br/>
		/// with zero (no flags set). This is a safe no-op that can be used to query<br/>
		/// the current initialization state without changing it at all.<br/>
		/// Since this returns previously-initialized flags as well as new ones, and<br/>
		/// you can call this with zero, you should not check for a zero return value<br/>
		/// to determine an error condition. Instead, you should check to make sure all<br/>
		/// the flags you require are set in the return value. If you have a game with<br/>
		/// data in a specific format, this might be a fatal error. If you're a generic<br/>
		/// image displaying app, perhaps you are fine with only having JPG and PNG<br/>
		/// support and can live without WEBP, even if you request support for<br/>
		/// everything.<br/>
		/// Unlike other SDL satellite libraries, calls to IMG_Init do not stack; a<br/>
		/// single call to IMG_Quit() will deinitialize everything and does not have to<br/>
		/// be paired with a matching IMG_Init call. For that reason, it's considered<br/>
		/// best practices to have a single IMG_Init and IMG_Quit call in your program.<br/>
		/// While this isn't required, be aware of the risks of deviating from that<br/>
		/// behavior.<br/>
		/// After initializing SDL_image, the app may begin to load images into<br/>
		/// SDL_Surfaces or SDL_Textures.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_Init")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int IMGInit([NativeName(NativeNameType.Param, "flags")] [NativeName(NativeNameType.Type, "int")] int flags)
		{
			int ret = IMGInitNative(flags);
			return ret;
		}

		/// <summary>
		/// Deinitialize SDL_image.<br/>
		/// This should be the last function you call in SDL_image, after freeing all<br/>
		/// other resources. This will unload any shared libraries it is using for<br/>
		/// various codecs.<br/>
		/// After this call, a call to IMG_Init(0) will return 0 (no codecs loaded).<br/>
		/// You can safely call IMG_Init() to reload various codec support after this<br/>
		/// call.<br/>
		/// Unlike other SDL satellite libraries, calls to IMG_Init do not stack; a<br/>
		/// single call to IMG_Quit() will deinitialize everything and does not have to<br/>
		/// be paired with a matching IMG_Init call. For that reason, it's considered<br/>
		/// best practices to have a single IMG_Init and IMG_Quit call in your program.<br/>
		/// While this isn't required, be aware of the risks of deviating from that<br/>
		/// behavior.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_Quit")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void IMGQuitNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)vt[2])();
			#else
			((delegate* unmanaged[Cdecl]<void>)vt[2])();
			#endif
		}

		/// <summary>
		/// Deinitialize SDL_image.<br/>
		/// This should be the last function you call in SDL_image, after freeing all<br/>
		/// other resources. This will unload any shared libraries it is using for<br/>
		/// various codecs.<br/>
		/// After this call, a call to IMG_Init(0) will return 0 (no codecs loaded).<br/>
		/// You can safely call IMG_Init() to reload various codec support after this<br/>
		/// call.<br/>
		/// Unlike other SDL satellite libraries, calls to IMG_Init do not stack; a<br/>
		/// single call to IMG_Quit() will deinitialize everything and does not have to<br/>
		/// be paired with a matching IMG_Init call. For that reason, it's considered<br/>
		/// best practices to have a single IMG_Init and IMG_Quit call in your program.<br/>
		/// While this isn't required, be aware of the risks of deviating from that<br/>
		/// behavior.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_Quit")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void IMGQuit()
		{
			IMGQuitNative();
		}

		/// <summary>
		/// Load an image from an SDL data source into a software surface.<br/>
		/// An SDL_Surface is a buffer of pixels in memory accessible by the CPU. Use<br/>
		/// this if you plan to hand the data to something else or manipulate it<br/>
		/// further in code.<br/>
		/// There are no guarantees about what format the new SDL_Surface data will be;<br/>
		/// in many cases, SDL_image will attempt to supply a surface that exactly<br/>
		/// matches the provided image, but in others it might have to convert (either<br/>
		/// because the image is in a format that SDL doesn't directly support or<br/>
		/// because it's compressed data that could reasonably uncompress to various<br/>
		/// formats and SDL_image had to pick one). You can inspect an SDL_Surface for<br/>
		/// its specifics, and use SDL_ConvertSurface to then migrate to any supported<br/>
		/// format.<br/>
		/// If the image format supports a transparent pixel, SDL will set the colorkey<br/>
		/// for the surface. You can enable RLE acceleration on the surface afterwards<br/>
		/// by calling: SDL_SetColorKey(image, SDL_RLEACCEL, image->format->colorkey);<br/>
		/// If `freesrc` is non-zero, the RWops will be closed before returning,<br/>
		/// whether this function succeeds or not. SDL_image reads everything it needs<br/>
		/// from the RWops during this call in any case.<br/>
		/// Even though this function accepts a file type, SDL_image may still try<br/>
		/// other decoders that are capable of detecting file type from the contents of<br/>
		/// the image data, but may rely on the caller-provided type string for formats<br/>
		/// that it cannot autodetect. If `type` is NULL, SDL_image will rely solely on<br/>
		/// its ability to guess the format.<br/>
		/// There is a separate function to read files from disk without having to deal<br/>
		/// with SDL_RWops: `IMG_Load("filename.jpg")` will call this function and<br/>
		/// manage those details for you, determining the file type from the filename's<br/>
		/// extension.<br/>
		/// There is also IMG_Load_RW(), which is equivalent to this function except<br/>
		/// that it will rely on SDL_image to determine what type of data it is<br/>
		/// loading, much like passing a NULL for type.<br/>
		/// If you are using SDL's 2D rendering API, there is an equivalent call to<br/>
		/// load images directly into an SDL_Texture for use by the GPU without using a<br/>
		/// software surface: call IMG_LoadTextureTyped_RW() instead.<br/>
		/// When done with the returned surface, the app should dispose of it with a<br/>
		/// call to SDL_FreeSurface().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadTyped_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface*")]
		internal static SDLSurface* IMGLoadTypedRWNative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "const char*")] byte* type)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, int, byte*, SDLSurface*>)vt[3])(src, freesrc, type);
			#else
			return (SDLSurface*)((delegate* unmanaged[Cdecl]<nint, int, nint, nint>)vt[3])((nint)src, freesrc, (nint)type);
			#endif
		}

		/// <summary>
		/// Load an image from an SDL data source into a software surface.<br/>
		/// An SDL_Surface is a buffer of pixels in memory accessible by the CPU. Use<br/>
		/// this if you plan to hand the data to something else or manipulate it<br/>
		/// further in code.<br/>
		/// There are no guarantees about what format the new SDL_Surface data will be;<br/>
		/// in many cases, SDL_image will attempt to supply a surface that exactly<br/>
		/// matches the provided image, but in others it might have to convert (either<br/>
		/// because the image is in a format that SDL doesn't directly support or<br/>
		/// because it's compressed data that could reasonably uncompress to various<br/>
		/// formats and SDL_image had to pick one). You can inspect an SDL_Surface for<br/>
		/// its specifics, and use SDL_ConvertSurface to then migrate to any supported<br/>
		/// format.<br/>
		/// If the image format supports a transparent pixel, SDL will set the colorkey<br/>
		/// for the surface. You can enable RLE acceleration on the surface afterwards<br/>
		/// by calling: SDL_SetColorKey(image, SDL_RLEACCEL, image->format->colorkey);<br/>
		/// If `freesrc` is non-zero, the RWops will be closed before returning,<br/>
		/// whether this function succeeds or not. SDL_image reads everything it needs<br/>
		/// from the RWops during this call in any case.<br/>
		/// Even though this function accepts a file type, SDL_image may still try<br/>
		/// other decoders that are capable of detecting file type from the contents of<br/>
		/// the image data, but may rely on the caller-provided type string for formats<br/>
		/// that it cannot autodetect. If `type` is NULL, SDL_image will rely solely on<br/>
		/// its ability to guess the format.<br/>
		/// There is a separate function to read files from disk without having to deal<br/>
		/// with SDL_RWops: `IMG_Load("filename.jpg")` will call this function and<br/>
		/// manage those details for you, determining the file type from the filename's<br/>
		/// extension.<br/>
		/// There is also IMG_Load_RW(), which is equivalent to this function except<br/>
		/// that it will rely on SDL_image to determine what type of data it is<br/>
		/// loading, much like passing a NULL for type.<br/>
		/// If you are using SDL's 2D rendering API, there is an equivalent call to<br/>
		/// load images directly into an SDL_Texture for use by the GPU without using a<br/>
		/// software surface: call IMG_LoadTextureTyped_RW() instead.<br/>
		/// When done with the returned surface, the app should dispose of it with a<br/>
		/// call to SDL_FreeSurface().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadTyped_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface*")]
		public static SDLSurface* IMGLoadTypedRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "const char*")] byte* type)
		{
			SDLSurface* ret = IMGLoadTypedRWNative(src, freesrc, type);
			return ret;
		}

		/// <summary>
		/// Load an image from an SDL data source into a software surface.<br/>
		/// An SDL_Surface is a buffer of pixels in memory accessible by the CPU. Use<br/>
		/// this if you plan to hand the data to something else or manipulate it<br/>
		/// further in code.<br/>
		/// There are no guarantees about what format the new SDL_Surface data will be;<br/>
		/// in many cases, SDL_image will attempt to supply a surface that exactly<br/>
		/// matches the provided image, but in others it might have to convert (either<br/>
		/// because the image is in a format that SDL doesn't directly support or<br/>
		/// because it's compressed data that could reasonably uncompress to various<br/>
		/// formats and SDL_image had to pick one). You can inspect an SDL_Surface for<br/>
		/// its specifics, and use SDL_ConvertSurface to then migrate to any supported<br/>
		/// format.<br/>
		/// If the image format supports a transparent pixel, SDL will set the colorkey<br/>
		/// for the surface. You can enable RLE acceleration on the surface afterwards<br/>
		/// by calling: SDL_SetColorKey(image, SDL_RLEACCEL, image->format->colorkey);<br/>
		/// If `freesrc` is non-zero, the RWops will be closed before returning,<br/>
		/// whether this function succeeds or not. SDL_image reads everything it needs<br/>
		/// from the RWops during this call in any case.<br/>
		/// Even though this function accepts a file type, SDL_image may still try<br/>
		/// other decoders that are capable of detecting file type from the contents of<br/>
		/// the image data, but may rely on the caller-provided type string for formats<br/>
		/// that it cannot autodetect. If `type` is NULL, SDL_image will rely solely on<br/>
		/// its ability to guess the format.<br/>
		/// There is a separate function to read files from disk without having to deal<br/>
		/// with SDL_RWops: `IMG_Load("filename.jpg")` will call this function and<br/>
		/// manage those details for you, determining the file type from the filename's<br/>
		/// extension.<br/>
		/// There is also IMG_Load_RW(), which is equivalent to this function except<br/>
		/// that it will rely on SDL_image to determine what type of data it is<br/>
		/// loading, much like passing a NULL for type.<br/>
		/// If you are using SDL's 2D rendering API, there is an equivalent call to<br/>
		/// load images directly into an SDL_Texture for use by the GPU without using a<br/>
		/// software surface: call IMG_LoadTextureTyped_RW() instead.<br/>
		/// When done with the returned surface, the app should dispose of it with a<br/>
		/// call to SDL_FreeSurface().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadTyped_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface*")]
		public static SDLSurface* IMGLoadTypedRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops src, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "const char*")] byte* type)
		{
			fixed (SDLRWops* psrc = &src)
			{
				SDLSurface* ret = IMGLoadTypedRWNative((SDLRWops*)psrc, freesrc, type);
				return ret;
			}
		}

		/// <summary>
		/// Load an image from an SDL data source into a software surface.<br/>
		/// An SDL_Surface is a buffer of pixels in memory accessible by the CPU. Use<br/>
		/// this if you plan to hand the data to something else or manipulate it<br/>
		/// further in code.<br/>
		/// There are no guarantees about what format the new SDL_Surface data will be;<br/>
		/// in many cases, SDL_image will attempt to supply a surface that exactly<br/>
		/// matches the provided image, but in others it might have to convert (either<br/>
		/// because the image is in a format that SDL doesn't directly support or<br/>
		/// because it's compressed data that could reasonably uncompress to various<br/>
		/// formats and SDL_image had to pick one). You can inspect an SDL_Surface for<br/>
		/// its specifics, and use SDL_ConvertSurface to then migrate to any supported<br/>
		/// format.<br/>
		/// If the image format supports a transparent pixel, SDL will set the colorkey<br/>
		/// for the surface. You can enable RLE acceleration on the surface afterwards<br/>
		/// by calling: SDL_SetColorKey(image, SDL_RLEACCEL, image->format->colorkey);<br/>
		/// If `freesrc` is non-zero, the RWops will be closed before returning,<br/>
		/// whether this function succeeds or not. SDL_image reads everything it needs<br/>
		/// from the RWops during this call in any case.<br/>
		/// Even though this function accepts a file type, SDL_image may still try<br/>
		/// other decoders that are capable of detecting file type from the contents of<br/>
		/// the image data, but may rely on the caller-provided type string for formats<br/>
		/// that it cannot autodetect. If `type` is NULL, SDL_image will rely solely on<br/>
		/// its ability to guess the format.<br/>
		/// There is a separate function to read files from disk without having to deal<br/>
		/// with SDL_RWops: `IMG_Load("filename.jpg")` will call this function and<br/>
		/// manage those details for you, determining the file type from the filename's<br/>
		/// extension.<br/>
		/// There is also IMG_Load_RW(), which is equivalent to this function except<br/>
		/// that it will rely on SDL_image to determine what type of data it is<br/>
		/// loading, much like passing a NULL for type.<br/>
		/// If you are using SDL's 2D rendering API, there is an equivalent call to<br/>
		/// load images directly into an SDL_Texture for use by the GPU without using a<br/>
		/// software surface: call IMG_LoadTextureTyped_RW() instead.<br/>
		/// When done with the returned surface, the app should dispose of it with a<br/>
		/// call to SDL_FreeSurface().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadTyped_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface*")]
		public static SDLSurface* IMGLoadTypedRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "const char*")] ref byte type)
		{
			fixed (byte* ptype = &type)
			{
				SDLSurface* ret = IMGLoadTypedRWNative(src, freesrc, (byte*)ptype);
				return ret;
			}
		}

		/// <summary>
		/// Load an image from an SDL data source into a software surface.<br/>
		/// An SDL_Surface is a buffer of pixels in memory accessible by the CPU. Use<br/>
		/// this if you plan to hand the data to something else or manipulate it<br/>
		/// further in code.<br/>
		/// There are no guarantees about what format the new SDL_Surface data will be;<br/>
		/// in many cases, SDL_image will attempt to supply a surface that exactly<br/>
		/// matches the provided image, but in others it might have to convert (either<br/>
		/// because the image is in a format that SDL doesn't directly support or<br/>
		/// because it's compressed data that could reasonably uncompress to various<br/>
		/// formats and SDL_image had to pick one). You can inspect an SDL_Surface for<br/>
		/// its specifics, and use SDL_ConvertSurface to then migrate to any supported<br/>
		/// format.<br/>
		/// If the image format supports a transparent pixel, SDL will set the colorkey<br/>
		/// for the surface. You can enable RLE acceleration on the surface afterwards<br/>
		/// by calling: SDL_SetColorKey(image, SDL_RLEACCEL, image->format->colorkey);<br/>
		/// If `freesrc` is non-zero, the RWops will be closed before returning,<br/>
		/// whether this function succeeds or not. SDL_image reads everything it needs<br/>
		/// from the RWops during this call in any case.<br/>
		/// Even though this function accepts a file type, SDL_image may still try<br/>
		/// other decoders that are capable of detecting file type from the contents of<br/>
		/// the image data, but may rely on the caller-provided type string for formats<br/>
		/// that it cannot autodetect. If `type` is NULL, SDL_image will rely solely on<br/>
		/// its ability to guess the format.<br/>
		/// There is a separate function to read files from disk without having to deal<br/>
		/// with SDL_RWops: `IMG_Load("filename.jpg")` will call this function and<br/>
		/// manage those details for you, determining the file type from the filename's<br/>
		/// extension.<br/>
		/// There is also IMG_Load_RW(), which is equivalent to this function except<br/>
		/// that it will rely on SDL_image to determine what type of data it is<br/>
		/// loading, much like passing a NULL for type.<br/>
		/// If you are using SDL's 2D rendering API, there is an equivalent call to<br/>
		/// load images directly into an SDL_Texture for use by the GPU without using a<br/>
		/// software surface: call IMG_LoadTextureTyped_RW() instead.<br/>
		/// When done with the returned surface, the app should dispose of it with a<br/>
		/// call to SDL_FreeSurface().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadTyped_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface*")]
		public static SDLSurface* IMGLoadTypedRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> type)
		{
			fixed (byte* ptype = type)
			{
				SDLSurface* ret = IMGLoadTypedRWNative(src, freesrc, (byte*)ptype);
				return ret;
			}
		}

		/// <summary>
		/// Load an image from an SDL data source into a software surface.<br/>
		/// An SDL_Surface is a buffer of pixels in memory accessible by the CPU. Use<br/>
		/// this if you plan to hand the data to something else or manipulate it<br/>
		/// further in code.<br/>
		/// There are no guarantees about what format the new SDL_Surface data will be;<br/>
		/// in many cases, SDL_image will attempt to supply a surface that exactly<br/>
		/// matches the provided image, but in others it might have to convert (either<br/>
		/// because the image is in a format that SDL doesn't directly support or<br/>
		/// because it's compressed data that could reasonably uncompress to various<br/>
		/// formats and SDL_image had to pick one). You can inspect an SDL_Surface for<br/>
		/// its specifics, and use SDL_ConvertSurface to then migrate to any supported<br/>
		/// format.<br/>
		/// If the image format supports a transparent pixel, SDL will set the colorkey<br/>
		/// for the surface. You can enable RLE acceleration on the surface afterwards<br/>
		/// by calling: SDL_SetColorKey(image, SDL_RLEACCEL, image->format->colorkey);<br/>
		/// If `freesrc` is non-zero, the RWops will be closed before returning,<br/>
		/// whether this function succeeds or not. SDL_image reads everything it needs<br/>
		/// from the RWops during this call in any case.<br/>
		/// Even though this function accepts a file type, SDL_image may still try<br/>
		/// other decoders that are capable of detecting file type from the contents of<br/>
		/// the image data, but may rely on the caller-provided type string for formats<br/>
		/// that it cannot autodetect. If `type` is NULL, SDL_image will rely solely on<br/>
		/// its ability to guess the format.<br/>
		/// There is a separate function to read files from disk without having to deal<br/>
		/// with SDL_RWops: `IMG_Load("filename.jpg")` will call this function and<br/>
		/// manage those details for you, determining the file type from the filename's<br/>
		/// extension.<br/>
		/// There is also IMG_Load_RW(), which is equivalent to this function except<br/>
		/// that it will rely on SDL_image to determine what type of data it is<br/>
		/// loading, much like passing a NULL for type.<br/>
		/// If you are using SDL's 2D rendering API, there is an equivalent call to<br/>
		/// load images directly into an SDL_Texture for use by the GPU without using a<br/>
		/// software surface: call IMG_LoadTextureTyped_RW() instead.<br/>
		/// When done with the returned surface, the app should dispose of it with a<br/>
		/// call to SDL_FreeSurface().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadTyped_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface*")]
		public static SDLSurface* IMGLoadTypedRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "const char*")] string type)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (type != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(type);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(type, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLSurface* ret = IMGLoadTypedRWNative(src, freesrc, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Load an image from an SDL data source into a software surface.<br/>
		/// An SDL_Surface is a buffer of pixels in memory accessible by the CPU. Use<br/>
		/// this if you plan to hand the data to something else or manipulate it<br/>
		/// further in code.<br/>
		/// There are no guarantees about what format the new SDL_Surface data will be;<br/>
		/// in many cases, SDL_image will attempt to supply a surface that exactly<br/>
		/// matches the provided image, but in others it might have to convert (either<br/>
		/// because the image is in a format that SDL doesn't directly support or<br/>
		/// because it's compressed data that could reasonably uncompress to various<br/>
		/// formats and SDL_image had to pick one). You can inspect an SDL_Surface for<br/>
		/// its specifics, and use SDL_ConvertSurface to then migrate to any supported<br/>
		/// format.<br/>
		/// If the image format supports a transparent pixel, SDL will set the colorkey<br/>
		/// for the surface. You can enable RLE acceleration on the surface afterwards<br/>
		/// by calling: SDL_SetColorKey(image, SDL_RLEACCEL, image->format->colorkey);<br/>
		/// If `freesrc` is non-zero, the RWops will be closed before returning,<br/>
		/// whether this function succeeds or not. SDL_image reads everything it needs<br/>
		/// from the RWops during this call in any case.<br/>
		/// Even though this function accepts a file type, SDL_image may still try<br/>
		/// other decoders that are capable of detecting file type from the contents of<br/>
		/// the image data, but may rely on the caller-provided type string for formats<br/>
		/// that it cannot autodetect. If `type` is NULL, SDL_image will rely solely on<br/>
		/// its ability to guess the format.<br/>
		/// There is a separate function to read files from disk without having to deal<br/>
		/// with SDL_RWops: `IMG_Load("filename.jpg")` will call this function and<br/>
		/// manage those details for you, determining the file type from the filename's<br/>
		/// extension.<br/>
		/// There is also IMG_Load_RW(), which is equivalent to this function except<br/>
		/// that it will rely on SDL_image to determine what type of data it is<br/>
		/// loading, much like passing a NULL for type.<br/>
		/// If you are using SDL's 2D rendering API, there is an equivalent call to<br/>
		/// load images directly into an SDL_Texture for use by the GPU without using a<br/>
		/// software surface: call IMG_LoadTextureTyped_RW() instead.<br/>
		/// When done with the returned surface, the app should dispose of it with a<br/>
		/// call to SDL_FreeSurface().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadTyped_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface*")]
		public static SDLSurface* IMGLoadTypedRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops src, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "const char*")] ref byte type)
		{
			fixed (SDLRWops* psrc = &src)
			{
				fixed (byte* ptype = &type)
				{
					SDLSurface* ret = IMGLoadTypedRWNative((SDLRWops*)psrc, freesrc, (byte*)ptype);
					return ret;
				}
			}
		}

		/// <summary>
		/// Load an image from an SDL data source into a software surface.<br/>
		/// An SDL_Surface is a buffer of pixels in memory accessible by the CPU. Use<br/>
		/// this if you plan to hand the data to something else or manipulate it<br/>
		/// further in code.<br/>
		/// There are no guarantees about what format the new SDL_Surface data will be;<br/>
		/// in many cases, SDL_image will attempt to supply a surface that exactly<br/>
		/// matches the provided image, but in others it might have to convert (either<br/>
		/// because the image is in a format that SDL doesn't directly support or<br/>
		/// because it's compressed data that could reasonably uncompress to various<br/>
		/// formats and SDL_image had to pick one). You can inspect an SDL_Surface for<br/>
		/// its specifics, and use SDL_ConvertSurface to then migrate to any supported<br/>
		/// format.<br/>
		/// If the image format supports a transparent pixel, SDL will set the colorkey<br/>
		/// for the surface. You can enable RLE acceleration on the surface afterwards<br/>
		/// by calling: SDL_SetColorKey(image, SDL_RLEACCEL, image->format->colorkey);<br/>
		/// If `freesrc` is non-zero, the RWops will be closed before returning,<br/>
		/// whether this function succeeds or not. SDL_image reads everything it needs<br/>
		/// from the RWops during this call in any case.<br/>
		/// Even though this function accepts a file type, SDL_image may still try<br/>
		/// other decoders that are capable of detecting file type from the contents of<br/>
		/// the image data, but may rely on the caller-provided type string for formats<br/>
		/// that it cannot autodetect. If `type` is NULL, SDL_image will rely solely on<br/>
		/// its ability to guess the format.<br/>
		/// There is a separate function to read files from disk without having to deal<br/>
		/// with SDL_RWops: `IMG_Load("filename.jpg")` will call this function and<br/>
		/// manage those details for you, determining the file type from the filename's<br/>
		/// extension.<br/>
		/// There is also IMG_Load_RW(), which is equivalent to this function except<br/>
		/// that it will rely on SDL_image to determine what type of data it is<br/>
		/// loading, much like passing a NULL for type.<br/>
		/// If you are using SDL's 2D rendering API, there is an equivalent call to<br/>
		/// load images directly into an SDL_Texture for use by the GPU without using a<br/>
		/// software surface: call IMG_LoadTextureTyped_RW() instead.<br/>
		/// When done with the returned surface, the app should dispose of it with a<br/>
		/// call to SDL_FreeSurface().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadTyped_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface*")]
		public static SDLSurface* IMGLoadTypedRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops src, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> type)
		{
			fixed (SDLRWops* psrc = &src)
			{
				fixed (byte* ptype = type)
				{
					SDLSurface* ret = IMGLoadTypedRWNative((SDLRWops*)psrc, freesrc, (byte*)ptype);
					return ret;
				}
			}
		}

		/// <summary>
		/// Load an image from an SDL data source into a software surface.<br/>
		/// An SDL_Surface is a buffer of pixels in memory accessible by the CPU. Use<br/>
		/// this if you plan to hand the data to something else or manipulate it<br/>
		/// further in code.<br/>
		/// There are no guarantees about what format the new SDL_Surface data will be;<br/>
		/// in many cases, SDL_image will attempt to supply a surface that exactly<br/>
		/// matches the provided image, but in others it might have to convert (either<br/>
		/// because the image is in a format that SDL doesn't directly support or<br/>
		/// because it's compressed data that could reasonably uncompress to various<br/>
		/// formats and SDL_image had to pick one). You can inspect an SDL_Surface for<br/>
		/// its specifics, and use SDL_ConvertSurface to then migrate to any supported<br/>
		/// format.<br/>
		/// If the image format supports a transparent pixel, SDL will set the colorkey<br/>
		/// for the surface. You can enable RLE acceleration on the surface afterwards<br/>
		/// by calling: SDL_SetColorKey(image, SDL_RLEACCEL, image->format->colorkey);<br/>
		/// If `freesrc` is non-zero, the RWops will be closed before returning,<br/>
		/// whether this function succeeds or not. SDL_image reads everything it needs<br/>
		/// from the RWops during this call in any case.<br/>
		/// Even though this function accepts a file type, SDL_image may still try<br/>
		/// other decoders that are capable of detecting file type from the contents of<br/>
		/// the image data, but may rely on the caller-provided type string for formats<br/>
		/// that it cannot autodetect. If `type` is NULL, SDL_image will rely solely on<br/>
		/// its ability to guess the format.<br/>
		/// There is a separate function to read files from disk without having to deal<br/>
		/// with SDL_RWops: `IMG_Load("filename.jpg")` will call this function and<br/>
		/// manage those details for you, determining the file type from the filename's<br/>
		/// extension.<br/>
		/// There is also IMG_Load_RW(), which is equivalent to this function except<br/>
		/// that it will rely on SDL_image to determine what type of data it is<br/>
		/// loading, much like passing a NULL for type.<br/>
		/// If you are using SDL's 2D rendering API, there is an equivalent call to<br/>
		/// load images directly into an SDL_Texture for use by the GPU without using a<br/>
		/// software surface: call IMG_LoadTextureTyped_RW() instead.<br/>
		/// When done with the returned surface, the app should dispose of it with a<br/>
		/// call to SDL_FreeSurface().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadTyped_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface*")]
		public static SDLSurface* IMGLoadTypedRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops src, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "const char*")] string type)
		{
			fixed (SDLRWops* psrc = &src)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (type != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(type);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(type, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				SDLSurface* ret = IMGLoadTypedRWNative((SDLRWops*)psrc, freesrc, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// Load an image from a filesystem path into a software surface.<br/>
		/// An SDL_Surface is a buffer of pixels in memory accessible by the CPU. Use<br/>
		/// this if you plan to hand the data to something else or manipulate it<br/>
		/// further in code.<br/>
		/// There are no guarantees about what format the new SDL_Surface data will be;<br/>
		/// in many cases, SDL_image will attempt to supply a surface that exactly<br/>
		/// matches the provided image, but in others it might have to convert (either<br/>
		/// because the image is in a format that SDL doesn't directly support or<br/>
		/// because it's compressed data that could reasonably uncompress to various<br/>
		/// formats and SDL_image had to pick one). You can inspect an SDL_Surface for<br/>
		/// its specifics, and use SDL_ConvertSurface to then migrate to any supported<br/>
		/// format.<br/>
		/// If the image format supports a transparent pixel, SDL will set the colorkey<br/>
		/// for the surface. You can enable RLE acceleration on the surface afterwards<br/>
		/// by calling: SDL_SetColorKey(image, SDL_RLEACCEL, image->format->colorkey);<br/>
		/// There is a separate function to read files from an SDL_RWops, if you need<br/>
		/// an i/o abstraction to provide data from anywhere instead of a simple<br/>
		/// filesystem read; that function is IMG_Load_RW().<br/>
		/// If you are using SDL's 2D rendering API, there is an equivalent call to<br/>
		/// load images directly into an SDL_Texture for use by the GPU without using a<br/>
		/// software surface: call IMG_LoadTexture() instead.<br/>
		/// When done with the returned surface, the app should dispose of it with a<br/>
		/// call to SDL_FreeSurface().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_Load")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface*")]
		internal static SDLSurface* IMGLoadNative([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "const char*")] byte* file)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, SDLSurface*>)vt[4])(file);
			#else
			return (SDLSurface*)((delegate* unmanaged[Cdecl]<nint, nint>)vt[4])((nint)file);
			#endif
		}

		/// <summary>
		/// Load an image from a filesystem path into a software surface.<br/>
		/// An SDL_Surface is a buffer of pixels in memory accessible by the CPU. Use<br/>
		/// this if you plan to hand the data to something else or manipulate it<br/>
		/// further in code.<br/>
		/// There are no guarantees about what format the new SDL_Surface data will be;<br/>
		/// in many cases, SDL_image will attempt to supply a surface that exactly<br/>
		/// matches the provided image, but in others it might have to convert (either<br/>
		/// because the image is in a format that SDL doesn't directly support or<br/>
		/// because it's compressed data that could reasonably uncompress to various<br/>
		/// formats and SDL_image had to pick one). You can inspect an SDL_Surface for<br/>
		/// its specifics, and use SDL_ConvertSurface to then migrate to any supported<br/>
		/// format.<br/>
		/// If the image format supports a transparent pixel, SDL will set the colorkey<br/>
		/// for the surface. You can enable RLE acceleration on the surface afterwards<br/>
		/// by calling: SDL_SetColorKey(image, SDL_RLEACCEL, image->format->colorkey);<br/>
		/// There is a separate function to read files from an SDL_RWops, if you need<br/>
		/// an i/o abstraction to provide data from anywhere instead of a simple<br/>
		/// filesystem read; that function is IMG_Load_RW().<br/>
		/// If you are using SDL's 2D rendering API, there is an equivalent call to<br/>
		/// load images directly into an SDL_Texture for use by the GPU without using a<br/>
		/// software surface: call IMG_LoadTexture() instead.<br/>
		/// When done with the returned surface, the app should dispose of it with a<br/>
		/// call to SDL_FreeSurface().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_Load")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface*")]
		public static SDLSurface* IMGLoad([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "const char*")] byte* file)
		{
			SDLSurface* ret = IMGLoadNative(file);
			return ret;
		}

		/// <summary>
		/// Load an image from a filesystem path into a software surface.<br/>
		/// An SDL_Surface is a buffer of pixels in memory accessible by the CPU. Use<br/>
		/// this if you plan to hand the data to something else or manipulate it<br/>
		/// further in code.<br/>
		/// There are no guarantees about what format the new SDL_Surface data will be;<br/>
		/// in many cases, SDL_image will attempt to supply a surface that exactly<br/>
		/// matches the provided image, but in others it might have to convert (either<br/>
		/// because the image is in a format that SDL doesn't directly support or<br/>
		/// because it's compressed data that could reasonably uncompress to various<br/>
		/// formats and SDL_image had to pick one). You can inspect an SDL_Surface for<br/>
		/// its specifics, and use SDL_ConvertSurface to then migrate to any supported<br/>
		/// format.<br/>
		/// If the image format supports a transparent pixel, SDL will set the colorkey<br/>
		/// for the surface. You can enable RLE acceleration on the surface afterwards<br/>
		/// by calling: SDL_SetColorKey(image, SDL_RLEACCEL, image->format->colorkey);<br/>
		/// There is a separate function to read files from an SDL_RWops, if you need<br/>
		/// an i/o abstraction to provide data from anywhere instead of a simple<br/>
		/// filesystem read; that function is IMG_Load_RW().<br/>
		/// If you are using SDL's 2D rendering API, there is an equivalent call to<br/>
		/// load images directly into an SDL_Texture for use by the GPU without using a<br/>
		/// software surface: call IMG_LoadTexture() instead.<br/>
		/// When done with the returned surface, the app should dispose of it with a<br/>
		/// call to SDL_FreeSurface().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_Load")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface*")]
		public static SDLSurface* IMGLoad([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "const char*")] ref byte file)
		{
			fixed (byte* pfile = &file)
			{
				SDLSurface* ret = IMGLoadNative((byte*)pfile);
				return ret;
			}
		}

		/// <summary>
		/// Load an image from a filesystem path into a software surface.<br/>
		/// An SDL_Surface is a buffer of pixels in memory accessible by the CPU. Use<br/>
		/// this if you plan to hand the data to something else or manipulate it<br/>
		/// further in code.<br/>
		/// There are no guarantees about what format the new SDL_Surface data will be;<br/>
		/// in many cases, SDL_image will attempt to supply a surface that exactly<br/>
		/// matches the provided image, but in others it might have to convert (either<br/>
		/// because the image is in a format that SDL doesn't directly support or<br/>
		/// because it's compressed data that could reasonably uncompress to various<br/>
		/// formats and SDL_image had to pick one). You can inspect an SDL_Surface for<br/>
		/// its specifics, and use SDL_ConvertSurface to then migrate to any supported<br/>
		/// format.<br/>
		/// If the image format supports a transparent pixel, SDL will set the colorkey<br/>
		/// for the surface. You can enable RLE acceleration on the surface afterwards<br/>
		/// by calling: SDL_SetColorKey(image, SDL_RLEACCEL, image->format->colorkey);<br/>
		/// There is a separate function to read files from an SDL_RWops, if you need<br/>
		/// an i/o abstraction to provide data from anywhere instead of a simple<br/>
		/// filesystem read; that function is IMG_Load_RW().<br/>
		/// If you are using SDL's 2D rendering API, there is an equivalent call to<br/>
		/// load images directly into an SDL_Texture for use by the GPU without using a<br/>
		/// software surface: call IMG_LoadTexture() instead.<br/>
		/// When done with the returned surface, the app should dispose of it with a<br/>
		/// call to SDL_FreeSurface().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_Load")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface*")]
		public static SDLSurface* IMGLoad([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> file)
		{
			fixed (byte* pfile = file)
			{
				SDLSurface* ret = IMGLoadNative((byte*)pfile);
				return ret;
			}
		}

		/// <summary>
		/// Load an image from a filesystem path into a software surface.<br/>
		/// An SDL_Surface is a buffer of pixels in memory accessible by the CPU. Use<br/>
		/// this if you plan to hand the data to something else or manipulate it<br/>
		/// further in code.<br/>
		/// There are no guarantees about what format the new SDL_Surface data will be;<br/>
		/// in many cases, SDL_image will attempt to supply a surface that exactly<br/>
		/// matches the provided image, but in others it might have to convert (either<br/>
		/// because the image is in a format that SDL doesn't directly support or<br/>
		/// because it's compressed data that could reasonably uncompress to various<br/>
		/// formats and SDL_image had to pick one). You can inspect an SDL_Surface for<br/>
		/// its specifics, and use SDL_ConvertSurface to then migrate to any supported<br/>
		/// format.<br/>
		/// If the image format supports a transparent pixel, SDL will set the colorkey<br/>
		/// for the surface. You can enable RLE acceleration on the surface afterwards<br/>
		/// by calling: SDL_SetColorKey(image, SDL_RLEACCEL, image->format->colorkey);<br/>
		/// There is a separate function to read files from an SDL_RWops, if you need<br/>
		/// an i/o abstraction to provide data from anywhere instead of a simple<br/>
		/// filesystem read; that function is IMG_Load_RW().<br/>
		/// If you are using SDL's 2D rendering API, there is an equivalent call to<br/>
		/// load images directly into an SDL_Texture for use by the GPU without using a<br/>
		/// software surface: call IMG_LoadTexture() instead.<br/>
		/// When done with the returned surface, the app should dispose of it with a<br/>
		/// call to SDL_FreeSurface().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_Load")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface*")]
		public static SDLSurface* IMGLoad([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "const char*")] string file)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (file != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(file);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(file, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLSurface* ret = IMGLoadNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Load an image from an SDL data source into a software surface.<br/>
		/// An SDL_Surface is a buffer of pixels in memory accessible by the CPU. Use<br/>
		/// this if you plan to hand the data to something else or manipulate it<br/>
		/// further in code.<br/>
		/// There are no guarantees about what format the new SDL_Surface data will be;<br/>
		/// in many cases, SDL_image will attempt to supply a surface that exactly<br/>
		/// matches the provided image, but in others it might have to convert (either<br/>
		/// because the image is in a format that SDL doesn't directly support or<br/>
		/// because it's compressed data that could reasonably uncompress to various<br/>
		/// formats and SDL_image had to pick one). You can inspect an SDL_Surface for<br/>
		/// its specifics, and use SDL_ConvertSurface to then migrate to any supported<br/>
		/// format.<br/>
		/// If the image format supports a transparent pixel, SDL will set the colorkey<br/>
		/// for the surface. You can enable RLE acceleration on the surface afterwards<br/>
		/// by calling: SDL_SetColorKey(image, SDL_RLEACCEL, image->format->colorkey);<br/>
		/// If `freesrc` is non-zero, the RWops will be closed before returning,<br/>
		/// whether this function succeeds or not. SDL_image reads everything it needs<br/>
		/// from the RWops during this call in any case.<br/>
		/// There is a separate function to read files from disk without having to deal<br/>
		/// with SDL_RWops: `IMG_Load("filename.jpg")` will call this function and<br/>
		/// manage those details for you, determining the file type from the filename's<br/>
		/// extension.<br/>
		/// There is also IMG_LoadTyped_RW(), which is equivalent to this function<br/>
		/// except a file extension (like "BMP", "JPG", etc) can be specified, in case<br/>
		/// SDL_image cannot autodetect the file format.<br/>
		/// If you are using SDL's 2D rendering API, there is an equivalent call to<br/>
		/// load images directly into an SDL_Texture for use by the GPU without using a<br/>
		/// software surface: call IMG_LoadTexture_RW() instead.<br/>
		/// When done with the returned surface, the app should dispose of it with a<br/>
		/// call to SDL_FreeSurface().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_Load_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface*")]
		internal static SDLSurface* IMGLoadRWNative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, int, SDLSurface*>)vt[5])(src, freesrc);
			#else
			return (SDLSurface*)((delegate* unmanaged[Cdecl]<nint, int, nint>)vt[5])((nint)src, freesrc);
			#endif
		}

		/// <summary>
		/// Load an image from an SDL data source into a software surface.<br/>
		/// An SDL_Surface is a buffer of pixels in memory accessible by the CPU. Use<br/>
		/// this if you plan to hand the data to something else or manipulate it<br/>
		/// further in code.<br/>
		/// There are no guarantees about what format the new SDL_Surface data will be;<br/>
		/// in many cases, SDL_image will attempt to supply a surface that exactly<br/>
		/// matches the provided image, but in others it might have to convert (either<br/>
		/// because the image is in a format that SDL doesn't directly support or<br/>
		/// because it's compressed data that could reasonably uncompress to various<br/>
		/// formats and SDL_image had to pick one). You can inspect an SDL_Surface for<br/>
		/// its specifics, and use SDL_ConvertSurface to then migrate to any supported<br/>
		/// format.<br/>
		/// If the image format supports a transparent pixel, SDL will set the colorkey<br/>
		/// for the surface. You can enable RLE acceleration on the surface afterwards<br/>
		/// by calling: SDL_SetColorKey(image, SDL_RLEACCEL, image->format->colorkey);<br/>
		/// If `freesrc` is non-zero, the RWops will be closed before returning,<br/>
		/// whether this function succeeds or not. SDL_image reads everything it needs<br/>
		/// from the RWops during this call in any case.<br/>
		/// There is a separate function to read files from disk without having to deal<br/>
		/// with SDL_RWops: `IMG_Load("filename.jpg")` will call this function and<br/>
		/// manage those details for you, determining the file type from the filename's<br/>
		/// extension.<br/>
		/// There is also IMG_LoadTyped_RW(), which is equivalent to this function<br/>
		/// except a file extension (like "BMP", "JPG", etc) can be specified, in case<br/>
		/// SDL_image cannot autodetect the file format.<br/>
		/// If you are using SDL's 2D rendering API, there is an equivalent call to<br/>
		/// load images directly into an SDL_Texture for use by the GPU without using a<br/>
		/// software surface: call IMG_LoadTexture_RW() instead.<br/>
		/// When done with the returned surface, the app should dispose of it with a<br/>
		/// call to SDL_FreeSurface().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_Load_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface*")]
		public static SDLSurface* IMGLoadRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc)
		{
			SDLSurface* ret = IMGLoadRWNative(src, freesrc);
			return ret;
		}

		/// <summary>
		/// Load an image from an SDL data source into a software surface.<br/>
		/// An SDL_Surface is a buffer of pixels in memory accessible by the CPU. Use<br/>
		/// this if you plan to hand the data to something else or manipulate it<br/>
		/// further in code.<br/>
		/// There are no guarantees about what format the new SDL_Surface data will be;<br/>
		/// in many cases, SDL_image will attempt to supply a surface that exactly<br/>
		/// matches the provided image, but in others it might have to convert (either<br/>
		/// because the image is in a format that SDL doesn't directly support or<br/>
		/// because it's compressed data that could reasonably uncompress to various<br/>
		/// formats and SDL_image had to pick one). You can inspect an SDL_Surface for<br/>
		/// its specifics, and use SDL_ConvertSurface to then migrate to any supported<br/>
		/// format.<br/>
		/// If the image format supports a transparent pixel, SDL will set the colorkey<br/>
		/// for the surface. You can enable RLE acceleration on the surface afterwards<br/>
		/// by calling: SDL_SetColorKey(image, SDL_RLEACCEL, image->format->colorkey);<br/>
		/// If `freesrc` is non-zero, the RWops will be closed before returning,<br/>
		/// whether this function succeeds or not. SDL_image reads everything it needs<br/>
		/// from the RWops during this call in any case.<br/>
		/// There is a separate function to read files from disk without having to deal<br/>
		/// with SDL_RWops: `IMG_Load("filename.jpg")` will call this function and<br/>
		/// manage those details for you, determining the file type from the filename's<br/>
		/// extension.<br/>
		/// There is also IMG_LoadTyped_RW(), which is equivalent to this function<br/>
		/// except a file extension (like "BMP", "JPG", etc) can be specified, in case<br/>
		/// SDL_image cannot autodetect the file format.<br/>
		/// If you are using SDL's 2D rendering API, there is an equivalent call to<br/>
		/// load images directly into an SDL_Texture for use by the GPU without using a<br/>
		/// software surface: call IMG_LoadTexture_RW() instead.<br/>
		/// When done with the returned surface, the app should dispose of it with a<br/>
		/// call to SDL_FreeSurface().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_Load_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface*")]
		public static SDLSurface* IMGLoadRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops src, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc)
		{
			fixed (SDLRWops* psrc = &src)
			{
				SDLSurface* ret = IMGLoadRWNative((SDLRWops*)psrc, freesrc);
				return ret;
			}
		}

		/// <summary>
		/// Load an image from a filesystem path into a GPU texture.<br/>
		/// An SDL_Texture represents an image in GPU memory, usable by SDL's 2D Render<br/>
		/// API. This can be significantly more efficient than using a CPU-bound<br/>
		/// SDL_Surface if you don't need to manipulate the image directly after<br/>
		/// loading it.<br/>
		/// If the loaded image has transparency or a colorkey, a texture with an alpha<br/>
		/// channel will be created. Otherwise, SDL_image will attempt to create an<br/>
		/// SDL_Texture in the most format that most reasonably represents the image<br/>
		/// data (but in many cases, this will just end up being 32-bit RGB or 32-bit<br/>
		/// RGBA).<br/>
		/// There is a separate function to read files from an SDL_RWops, if you need<br/>
		/// an i/o abstraction to provide data from anywhere instead of a simple<br/>
		/// filesystem read; that function is IMG_LoadTexture_RW().<br/>
		/// If you would rather decode an image to an SDL_Surface (a buffer of pixels<br/>
		/// in CPU memory), call IMG_Load() instead.<br/>
		/// When done with the returned texture, the app should dispose of it with a<br/>
		/// call to SDL_DestroyTexture().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadTexture")]
		[return: NativeName(NativeNameType.Type, "SDL_Texture*")]
		internal static SDLTexture* IMGLoadTextureNative([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "const char*")] byte* file)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRenderer*, byte*, SDLTexture*>)vt[6])(renderer, file);
			#else
			return (SDLTexture*)((delegate* unmanaged[Cdecl]<nint, nint, nint>)vt[6])((nint)renderer, (nint)file);
			#endif
		}

		/// <summary>
		/// Load an image from a filesystem path into a GPU texture.<br/>
		/// An SDL_Texture represents an image in GPU memory, usable by SDL's 2D Render<br/>
		/// API. This can be significantly more efficient than using a CPU-bound<br/>
		/// SDL_Surface if you don't need to manipulate the image directly after<br/>
		/// loading it.<br/>
		/// If the loaded image has transparency or a colorkey, a texture with an alpha<br/>
		/// channel will be created. Otherwise, SDL_image will attempt to create an<br/>
		/// SDL_Texture in the most format that most reasonably represents the image<br/>
		/// data (but in many cases, this will just end up being 32-bit RGB or 32-bit<br/>
		/// RGBA).<br/>
		/// There is a separate function to read files from an SDL_RWops, if you need<br/>
		/// an i/o abstraction to provide data from anywhere instead of a simple<br/>
		/// filesystem read; that function is IMG_LoadTexture_RW().<br/>
		/// If you would rather decode an image to an SDL_Surface (a buffer of pixels<br/>
		/// in CPU memory), call IMG_Load() instead.<br/>
		/// When done with the returned texture, the app should dispose of it with a<br/>
		/// call to SDL_DestroyTexture().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadTexture")]
		[return: NativeName(NativeNameType.Type, "SDL_Texture*")]
		public static SDLTexture* IMGLoadTexture([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "const char*")] byte* file)
		{
			SDLTexture* ret = IMGLoadTextureNative(renderer, file);
			return ret;
		}

		/// <summary>
		/// Load an image from a filesystem path into a GPU texture.<br/>
		/// An SDL_Texture represents an image in GPU memory, usable by SDL's 2D Render<br/>
		/// API. This can be significantly more efficient than using a CPU-bound<br/>
		/// SDL_Surface if you don't need to manipulate the image directly after<br/>
		/// loading it.<br/>
		/// If the loaded image has transparency or a colorkey, a texture with an alpha<br/>
		/// channel will be created. Otherwise, SDL_image will attempt to create an<br/>
		/// SDL_Texture in the most format that most reasonably represents the image<br/>
		/// data (but in many cases, this will just end up being 32-bit RGB or 32-bit<br/>
		/// RGBA).<br/>
		/// There is a separate function to read files from an SDL_RWops, if you need<br/>
		/// an i/o abstraction to provide data from anywhere instead of a simple<br/>
		/// filesystem read; that function is IMG_LoadTexture_RW().<br/>
		/// If you would rather decode an image to an SDL_Surface (a buffer of pixels<br/>
		/// in CPU memory), call IMG_Load() instead.<br/>
		/// When done with the returned texture, the app should dispose of it with a<br/>
		/// call to SDL_DestroyTexture().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadTexture")]
		[return: NativeName(NativeNameType.Type, "SDL_Texture*")]
		public static SDLTexture* IMGLoadTexture([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "const char*")] byte* file)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				SDLTexture* ret = IMGLoadTextureNative((SDLRenderer*)prenderer, file);
				return ret;
			}
		}

		/// <summary>
		/// Load an image from a filesystem path into a GPU texture.<br/>
		/// An SDL_Texture represents an image in GPU memory, usable by SDL's 2D Render<br/>
		/// API. This can be significantly more efficient than using a CPU-bound<br/>
		/// SDL_Surface if you don't need to manipulate the image directly after<br/>
		/// loading it.<br/>
		/// If the loaded image has transparency or a colorkey, a texture with an alpha<br/>
		/// channel will be created. Otherwise, SDL_image will attempt to create an<br/>
		/// SDL_Texture in the most format that most reasonably represents the image<br/>
		/// data (but in many cases, this will just end up being 32-bit RGB or 32-bit<br/>
		/// RGBA).<br/>
		/// There is a separate function to read files from an SDL_RWops, if you need<br/>
		/// an i/o abstraction to provide data from anywhere instead of a simple<br/>
		/// filesystem read; that function is IMG_LoadTexture_RW().<br/>
		/// If you would rather decode an image to an SDL_Surface (a buffer of pixels<br/>
		/// in CPU memory), call IMG_Load() instead.<br/>
		/// When done with the returned texture, the app should dispose of it with a<br/>
		/// call to SDL_DestroyTexture().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadTexture")]
		[return: NativeName(NativeNameType.Type, "SDL_Texture*")]
		public static SDLTexture* IMGLoadTexture([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "const char*")] ref byte file)
		{
			fixed (byte* pfile = &file)
			{
				SDLTexture* ret = IMGLoadTextureNative(renderer, (byte*)pfile);
				return ret;
			}
		}

		/// <summary>
		/// Load an image from a filesystem path into a GPU texture.<br/>
		/// An SDL_Texture represents an image in GPU memory, usable by SDL's 2D Render<br/>
		/// API. This can be significantly more efficient than using a CPU-bound<br/>
		/// SDL_Surface if you don't need to manipulate the image directly after<br/>
		/// loading it.<br/>
		/// If the loaded image has transparency or a colorkey, a texture with an alpha<br/>
		/// channel will be created. Otherwise, SDL_image will attempt to create an<br/>
		/// SDL_Texture in the most format that most reasonably represents the image<br/>
		/// data (but in many cases, this will just end up being 32-bit RGB or 32-bit<br/>
		/// RGBA).<br/>
		/// There is a separate function to read files from an SDL_RWops, if you need<br/>
		/// an i/o abstraction to provide data from anywhere instead of a simple<br/>
		/// filesystem read; that function is IMG_LoadTexture_RW().<br/>
		/// If you would rather decode an image to an SDL_Surface (a buffer of pixels<br/>
		/// in CPU memory), call IMG_Load() instead.<br/>
		/// When done with the returned texture, the app should dispose of it with a<br/>
		/// call to SDL_DestroyTexture().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadTexture")]
		[return: NativeName(NativeNameType.Type, "SDL_Texture*")]
		public static SDLTexture* IMGLoadTexture([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> file)
		{
			fixed (byte* pfile = file)
			{
				SDLTexture* ret = IMGLoadTextureNative(renderer, (byte*)pfile);
				return ret;
			}
		}

		/// <summary>
		/// Load an image from a filesystem path into a GPU texture.<br/>
		/// An SDL_Texture represents an image in GPU memory, usable by SDL's 2D Render<br/>
		/// API. This can be significantly more efficient than using a CPU-bound<br/>
		/// SDL_Surface if you don't need to manipulate the image directly after<br/>
		/// loading it.<br/>
		/// If the loaded image has transparency or a colorkey, a texture with an alpha<br/>
		/// channel will be created. Otherwise, SDL_image will attempt to create an<br/>
		/// SDL_Texture in the most format that most reasonably represents the image<br/>
		/// data (but in many cases, this will just end up being 32-bit RGB or 32-bit<br/>
		/// RGBA).<br/>
		/// There is a separate function to read files from an SDL_RWops, if you need<br/>
		/// an i/o abstraction to provide data from anywhere instead of a simple<br/>
		/// filesystem read; that function is IMG_LoadTexture_RW().<br/>
		/// If you would rather decode an image to an SDL_Surface (a buffer of pixels<br/>
		/// in CPU memory), call IMG_Load() instead.<br/>
		/// When done with the returned texture, the app should dispose of it with a<br/>
		/// call to SDL_DestroyTexture().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadTexture")]
		[return: NativeName(NativeNameType.Type, "SDL_Texture*")]
		public static SDLTexture* IMGLoadTexture([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "const char*")] string file)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (file != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(file);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(file, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLTexture* ret = IMGLoadTextureNative(renderer, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Load an image from a filesystem path into a GPU texture.<br/>
		/// An SDL_Texture represents an image in GPU memory, usable by SDL's 2D Render<br/>
		/// API. This can be significantly more efficient than using a CPU-bound<br/>
		/// SDL_Surface if you don't need to manipulate the image directly after<br/>
		/// loading it.<br/>
		/// If the loaded image has transparency or a colorkey, a texture with an alpha<br/>
		/// channel will be created. Otherwise, SDL_image will attempt to create an<br/>
		/// SDL_Texture in the most format that most reasonably represents the image<br/>
		/// data (but in many cases, this will just end up being 32-bit RGB or 32-bit<br/>
		/// RGBA).<br/>
		/// There is a separate function to read files from an SDL_RWops, if you need<br/>
		/// an i/o abstraction to provide data from anywhere instead of a simple<br/>
		/// filesystem read; that function is IMG_LoadTexture_RW().<br/>
		/// If you would rather decode an image to an SDL_Surface (a buffer of pixels<br/>
		/// in CPU memory), call IMG_Load() instead.<br/>
		/// When done with the returned texture, the app should dispose of it with a<br/>
		/// call to SDL_DestroyTexture().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadTexture")]
		[return: NativeName(NativeNameType.Type, "SDL_Texture*")]
		public static SDLTexture* IMGLoadTexture([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "const char*")] ref byte file)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (byte* pfile = &file)
				{
					SDLTexture* ret = IMGLoadTextureNative((SDLRenderer*)prenderer, (byte*)pfile);
					return ret;
				}
			}
		}

		/// <summary>
		/// Load an image from a filesystem path into a GPU texture.<br/>
		/// An SDL_Texture represents an image in GPU memory, usable by SDL's 2D Render<br/>
		/// API. This can be significantly more efficient than using a CPU-bound<br/>
		/// SDL_Surface if you don't need to manipulate the image directly after<br/>
		/// loading it.<br/>
		/// If the loaded image has transparency or a colorkey, a texture with an alpha<br/>
		/// channel will be created. Otherwise, SDL_image will attempt to create an<br/>
		/// SDL_Texture in the most format that most reasonably represents the image<br/>
		/// data (but in many cases, this will just end up being 32-bit RGB or 32-bit<br/>
		/// RGBA).<br/>
		/// There is a separate function to read files from an SDL_RWops, if you need<br/>
		/// an i/o abstraction to provide data from anywhere instead of a simple<br/>
		/// filesystem read; that function is IMG_LoadTexture_RW().<br/>
		/// If you would rather decode an image to an SDL_Surface (a buffer of pixels<br/>
		/// in CPU memory), call IMG_Load() instead.<br/>
		/// When done with the returned texture, the app should dispose of it with a<br/>
		/// call to SDL_DestroyTexture().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadTexture")]
		[return: NativeName(NativeNameType.Type, "SDL_Texture*")]
		public static SDLTexture* IMGLoadTexture([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> file)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (byte* pfile = file)
				{
					SDLTexture* ret = IMGLoadTextureNative((SDLRenderer*)prenderer, (byte*)pfile);
					return ret;
				}
			}
		}

		/// <summary>
		/// Load an image from a filesystem path into a GPU texture.<br/>
		/// An SDL_Texture represents an image in GPU memory, usable by SDL's 2D Render<br/>
		/// API. This can be significantly more efficient than using a CPU-bound<br/>
		/// SDL_Surface if you don't need to manipulate the image directly after<br/>
		/// loading it.<br/>
		/// If the loaded image has transparency or a colorkey, a texture with an alpha<br/>
		/// channel will be created. Otherwise, SDL_image will attempt to create an<br/>
		/// SDL_Texture in the most format that most reasonably represents the image<br/>
		/// data (but in many cases, this will just end up being 32-bit RGB or 32-bit<br/>
		/// RGBA).<br/>
		/// There is a separate function to read files from an SDL_RWops, if you need<br/>
		/// an i/o abstraction to provide data from anywhere instead of a simple<br/>
		/// filesystem read; that function is IMG_LoadTexture_RW().<br/>
		/// If you would rather decode an image to an SDL_Surface (a buffer of pixels<br/>
		/// in CPU memory), call IMG_Load() instead.<br/>
		/// When done with the returned texture, the app should dispose of it with a<br/>
		/// call to SDL_DestroyTexture().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadTexture")]
		[return: NativeName(NativeNameType.Type, "SDL_Texture*")]
		public static SDLTexture* IMGLoadTexture([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "const char*")] string file)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (file != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(file);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(file, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				SDLTexture* ret = IMGLoadTextureNative((SDLRenderer*)prenderer, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// Load an image from an SDL data source into a GPU texture.<br/>
		/// An SDL_Texture represents an image in GPU memory, usable by SDL's 2D Render<br/>
		/// API. This can be significantly more efficient than using a CPU-bound<br/>
		/// SDL_Surface if you don't need to manipulate the image directly after<br/>
		/// loading it.<br/>
		/// If the loaded image has transparency or a colorkey, a texture with an alpha<br/>
		/// channel will be created. Otherwise, SDL_image will attempt to create an<br/>
		/// SDL_Texture in the most format that most reasonably represents the image<br/>
		/// data (but in many cases, this will just end up being 32-bit RGB or 32-bit<br/>
		/// RGBA).<br/>
		/// If `freesrc` is non-zero, the RWops will be closed before returning,<br/>
		/// whether this function succeeds or not. SDL_image reads everything it needs<br/>
		/// from the RWops during this call in any case.<br/>
		/// There is a separate function to read files from disk without having to deal<br/>
		/// with SDL_RWops: `IMG_LoadTexture(renderer, "filename.jpg")` will call this<br/>
		/// function and manage those details for you, determining the file type from<br/>
		/// the filename's extension.<br/>
		/// There is also IMG_LoadTextureTyped_RW(), which is equivalent to this<br/>
		/// function except a file extension (like "BMP", "JPG", etc) can be specified,<br/>
		/// in case SDL_image cannot autodetect the file format.<br/>
		/// If you would rather decode an image to an SDL_Surface (a buffer of pixels<br/>
		/// in CPU memory), call IMG_Load() instead.<br/>
		/// When done with the returned texture, the app should dispose of it with a<br/>
		/// call to SDL_DestroyTexture().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadTexture_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Texture*")]
		internal static SDLTexture* IMGLoadTextureRWNative([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRenderer*, SDLRWops*, int, SDLTexture*>)vt[7])(renderer, src, freesrc);
			#else
			return (SDLTexture*)((delegate* unmanaged[Cdecl]<nint, nint, int, nint>)vt[7])((nint)renderer, (nint)src, freesrc);
			#endif
		}

		/// <summary>
		/// Load an image from an SDL data source into a GPU texture.<br/>
		/// An SDL_Texture represents an image in GPU memory, usable by SDL's 2D Render<br/>
		/// API. This can be significantly more efficient than using a CPU-bound<br/>
		/// SDL_Surface if you don't need to manipulate the image directly after<br/>
		/// loading it.<br/>
		/// If the loaded image has transparency or a colorkey, a texture with an alpha<br/>
		/// channel will be created. Otherwise, SDL_image will attempt to create an<br/>
		/// SDL_Texture in the most format that most reasonably represents the image<br/>
		/// data (but in many cases, this will just end up being 32-bit RGB or 32-bit<br/>
		/// RGBA).<br/>
		/// If `freesrc` is non-zero, the RWops will be closed before returning,<br/>
		/// whether this function succeeds or not. SDL_image reads everything it needs<br/>
		/// from the RWops during this call in any case.<br/>
		/// There is a separate function to read files from disk without having to deal<br/>
		/// with SDL_RWops: `IMG_LoadTexture(renderer, "filename.jpg")` will call this<br/>
		/// function and manage those details for you, determining the file type from<br/>
		/// the filename's extension.<br/>
		/// There is also IMG_LoadTextureTyped_RW(), which is equivalent to this<br/>
		/// function except a file extension (like "BMP", "JPG", etc) can be specified,<br/>
		/// in case SDL_image cannot autodetect the file format.<br/>
		/// If you would rather decode an image to an SDL_Surface (a buffer of pixels<br/>
		/// in CPU memory), call IMG_Load() instead.<br/>
		/// When done with the returned texture, the app should dispose of it with a<br/>
		/// call to SDL_DestroyTexture().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadTexture_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Texture*")]
		public static SDLTexture* IMGLoadTextureRW([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc)
		{
			SDLTexture* ret = IMGLoadTextureRWNative(renderer, src, freesrc);
			return ret;
		}

		/// <summary>
		/// Load an image from an SDL data source into a GPU texture.<br/>
		/// An SDL_Texture represents an image in GPU memory, usable by SDL's 2D Render<br/>
		/// API. This can be significantly more efficient than using a CPU-bound<br/>
		/// SDL_Surface if you don't need to manipulate the image directly after<br/>
		/// loading it.<br/>
		/// If the loaded image has transparency or a colorkey, a texture with an alpha<br/>
		/// channel will be created. Otherwise, SDL_image will attempt to create an<br/>
		/// SDL_Texture in the most format that most reasonably represents the image<br/>
		/// data (but in many cases, this will just end up being 32-bit RGB or 32-bit<br/>
		/// RGBA).<br/>
		/// If `freesrc` is non-zero, the RWops will be closed before returning,<br/>
		/// whether this function succeeds or not. SDL_image reads everything it needs<br/>
		/// from the RWops during this call in any case.<br/>
		/// There is a separate function to read files from disk without having to deal<br/>
		/// with SDL_RWops: `IMG_LoadTexture(renderer, "filename.jpg")` will call this<br/>
		/// function and manage those details for you, determining the file type from<br/>
		/// the filename's extension.<br/>
		/// There is also IMG_LoadTextureTyped_RW(), which is equivalent to this<br/>
		/// function except a file extension (like "BMP", "JPG", etc) can be specified,<br/>
		/// in case SDL_image cannot autodetect the file format.<br/>
		/// If you would rather decode an image to an SDL_Surface (a buffer of pixels<br/>
		/// in CPU memory), call IMG_Load() instead.<br/>
		/// When done with the returned texture, the app should dispose of it with a<br/>
		/// call to SDL_DestroyTexture().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadTexture_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Texture*")]
		public static SDLTexture* IMGLoadTextureRW([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				SDLTexture* ret = IMGLoadTextureRWNative((SDLRenderer*)prenderer, src, freesrc);
				return ret;
			}
		}

		/// <summary>
		/// Load an image from an SDL data source into a GPU texture.<br/>
		/// An SDL_Texture represents an image in GPU memory, usable by SDL's 2D Render<br/>
		/// API. This can be significantly more efficient than using a CPU-bound<br/>
		/// SDL_Surface if you don't need to manipulate the image directly after<br/>
		/// loading it.<br/>
		/// If the loaded image has transparency or a colorkey, a texture with an alpha<br/>
		/// channel will be created. Otherwise, SDL_image will attempt to create an<br/>
		/// SDL_Texture in the most format that most reasonably represents the image<br/>
		/// data (but in many cases, this will just end up being 32-bit RGB or 32-bit<br/>
		/// RGBA).<br/>
		/// If `freesrc` is non-zero, the RWops will be closed before returning,<br/>
		/// whether this function succeeds or not. SDL_image reads everything it needs<br/>
		/// from the RWops during this call in any case.<br/>
		/// There is a separate function to read files from disk without having to deal<br/>
		/// with SDL_RWops: `IMG_LoadTexture(renderer, "filename.jpg")` will call this<br/>
		/// function and manage those details for you, determining the file type from<br/>
		/// the filename's extension.<br/>
		/// There is also IMG_LoadTextureTyped_RW(), which is equivalent to this<br/>
		/// function except a file extension (like "BMP", "JPG", etc) can be specified,<br/>
		/// in case SDL_image cannot autodetect the file format.<br/>
		/// If you would rather decode an image to an SDL_Surface (a buffer of pixels<br/>
		/// in CPU memory), call IMG_Load() instead.<br/>
		/// When done with the returned texture, the app should dispose of it with a<br/>
		/// call to SDL_DestroyTexture().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadTexture_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Texture*")]
		public static SDLTexture* IMGLoadTextureRW([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops src, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc)
		{
			fixed (SDLRWops* psrc = &src)
			{
				SDLTexture* ret = IMGLoadTextureRWNative(renderer, (SDLRWops*)psrc, freesrc);
				return ret;
			}
		}

		/// <summary>
		/// Load an image from an SDL data source into a GPU texture.<br/>
		/// An SDL_Texture represents an image in GPU memory, usable by SDL's 2D Render<br/>
		/// API. This can be significantly more efficient than using a CPU-bound<br/>
		/// SDL_Surface if you don't need to manipulate the image directly after<br/>
		/// loading it.<br/>
		/// If the loaded image has transparency or a colorkey, a texture with an alpha<br/>
		/// channel will be created. Otherwise, SDL_image will attempt to create an<br/>
		/// SDL_Texture in the most format that most reasonably represents the image<br/>
		/// data (but in many cases, this will just end up being 32-bit RGB or 32-bit<br/>
		/// RGBA).<br/>
		/// If `freesrc` is non-zero, the RWops will be closed before returning,<br/>
		/// whether this function succeeds or not. SDL_image reads everything it needs<br/>
		/// from the RWops during this call in any case.<br/>
		/// There is a separate function to read files from disk without having to deal<br/>
		/// with SDL_RWops: `IMG_LoadTexture(renderer, "filename.jpg")` will call this<br/>
		/// function and manage those details for you, determining the file type from<br/>
		/// the filename's extension.<br/>
		/// There is also IMG_LoadTextureTyped_RW(), which is equivalent to this<br/>
		/// function except a file extension (like "BMP", "JPG", etc) can be specified,<br/>
		/// in case SDL_image cannot autodetect the file format.<br/>
		/// If you would rather decode an image to an SDL_Surface (a buffer of pixels<br/>
		/// in CPU memory), call IMG_Load() instead.<br/>
		/// When done with the returned texture, the app should dispose of it with a<br/>
		/// call to SDL_DestroyTexture().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadTexture_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Texture*")]
		public static SDLTexture* IMGLoadTextureRW([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops src, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLRWops* psrc = &src)
				{
					SDLTexture* ret = IMGLoadTextureRWNative((SDLRenderer*)prenderer, (SDLRWops*)psrc, freesrc);
					return ret;
				}
			}
		}

		/// <summary>
		/// Load an image from an SDL data source into a GPU texture.<br/>
		/// An SDL_Texture represents an image in GPU memory, usable by SDL's 2D Render<br/>
		/// API. This can be significantly more efficient than using a CPU-bound<br/>
		/// SDL_Surface if you don't need to manipulate the image directly after<br/>
		/// loading it.<br/>
		/// If the loaded image has transparency or a colorkey, a texture with an alpha<br/>
		/// channel will be created. Otherwise, SDL_image will attempt to create an<br/>
		/// SDL_Texture in the most format that most reasonably represents the image<br/>
		/// data (but in many cases, this will just end up being 32-bit RGB or 32-bit<br/>
		/// RGBA).<br/>
		/// If `freesrc` is non-zero, the RWops will be closed before returning,<br/>
		/// whether this function succeeds or not. SDL_image reads everything it needs<br/>
		/// from the RWops during this call in any case.<br/>
		/// Even though this function accepts a file type, SDL_image may still try<br/>
		/// other decoders that are capable of detecting file type from the contents of<br/>
		/// the image data, but may rely on the caller-provided type string for formats<br/>
		/// that it cannot autodetect. If `type` is NULL, SDL_image will rely solely on<br/>
		/// its ability to guess the format.<br/>
		/// There is a separate function to read files from disk without having to deal<br/>
		/// with SDL_RWops: `IMG_LoadTexture("filename.jpg")` will call this function<br/>
		/// and manage those details for you, determining the file type from the<br/>
		/// filename's extension.<br/>
		/// There is also IMG_LoadTexture_RW(), which is equivalent to this function<br/>
		/// except that it will rely on SDL_image to determine what type of data it is<br/>
		/// loading, much like passing a NULL for type.<br/>
		/// If you would rather decode an image to an SDL_Surface (a buffer of pixels<br/>
		/// in CPU memory), call IMG_LoadTyped_RW() instead.<br/>
		/// When done with the returned texture, the app should dispose of it with a<br/>
		/// call to SDL_DestroyTexture().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadTextureTyped_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Texture*")]
		internal static SDLTexture* IMGLoadTextureTypedRWNative([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "const char*")] byte* type)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRenderer*, SDLRWops*, int, byte*, SDLTexture*>)vt[8])(renderer, src, freesrc, type);
			#else
			return (SDLTexture*)((delegate* unmanaged[Cdecl]<nint, nint, int, nint, nint>)vt[8])((nint)renderer, (nint)src, freesrc, (nint)type);
			#endif
		}

		/// <summary>
		/// Load an image from an SDL data source into a GPU texture.<br/>
		/// An SDL_Texture represents an image in GPU memory, usable by SDL's 2D Render<br/>
		/// API. This can be significantly more efficient than using a CPU-bound<br/>
		/// SDL_Surface if you don't need to manipulate the image directly after<br/>
		/// loading it.<br/>
		/// If the loaded image has transparency or a colorkey, a texture with an alpha<br/>
		/// channel will be created. Otherwise, SDL_image will attempt to create an<br/>
		/// SDL_Texture in the most format that most reasonably represents the image<br/>
		/// data (but in many cases, this will just end up being 32-bit RGB or 32-bit<br/>
		/// RGBA).<br/>
		/// If `freesrc` is non-zero, the RWops will be closed before returning,<br/>
		/// whether this function succeeds or not. SDL_image reads everything it needs<br/>
		/// from the RWops during this call in any case.<br/>
		/// Even though this function accepts a file type, SDL_image may still try<br/>
		/// other decoders that are capable of detecting file type from the contents of<br/>
		/// the image data, but may rely on the caller-provided type string for formats<br/>
		/// that it cannot autodetect. If `type` is NULL, SDL_image will rely solely on<br/>
		/// its ability to guess the format.<br/>
		/// There is a separate function to read files from disk without having to deal<br/>
		/// with SDL_RWops: `IMG_LoadTexture("filename.jpg")` will call this function<br/>
		/// and manage those details for you, determining the file type from the<br/>
		/// filename's extension.<br/>
		/// There is also IMG_LoadTexture_RW(), which is equivalent to this function<br/>
		/// except that it will rely on SDL_image to determine what type of data it is<br/>
		/// loading, much like passing a NULL for type.<br/>
		/// If you would rather decode an image to an SDL_Surface (a buffer of pixels<br/>
		/// in CPU memory), call IMG_LoadTyped_RW() instead.<br/>
		/// When done with the returned texture, the app should dispose of it with a<br/>
		/// call to SDL_DestroyTexture().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadTextureTyped_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Texture*")]
		public static SDLTexture* IMGLoadTextureTypedRW([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "const char*")] byte* type)
		{
			SDLTexture* ret = IMGLoadTextureTypedRWNative(renderer, src, freesrc, type);
			return ret;
		}

		/// <summary>
		/// Load an image from an SDL data source into a GPU texture.<br/>
		/// An SDL_Texture represents an image in GPU memory, usable by SDL's 2D Render<br/>
		/// API. This can be significantly more efficient than using a CPU-bound<br/>
		/// SDL_Surface if you don't need to manipulate the image directly after<br/>
		/// loading it.<br/>
		/// If the loaded image has transparency or a colorkey, a texture with an alpha<br/>
		/// channel will be created. Otherwise, SDL_image will attempt to create an<br/>
		/// SDL_Texture in the most format that most reasonably represents the image<br/>
		/// data (but in many cases, this will just end up being 32-bit RGB or 32-bit<br/>
		/// RGBA).<br/>
		/// If `freesrc` is non-zero, the RWops will be closed before returning,<br/>
		/// whether this function succeeds or not. SDL_image reads everything it needs<br/>
		/// from the RWops during this call in any case.<br/>
		/// Even though this function accepts a file type, SDL_image may still try<br/>
		/// other decoders that are capable of detecting file type from the contents of<br/>
		/// the image data, but may rely on the caller-provided type string for formats<br/>
		/// that it cannot autodetect. If `type` is NULL, SDL_image will rely solely on<br/>
		/// its ability to guess the format.<br/>
		/// There is a separate function to read files from disk without having to deal<br/>
		/// with SDL_RWops: `IMG_LoadTexture("filename.jpg")` will call this function<br/>
		/// and manage those details for you, determining the file type from the<br/>
		/// filename's extension.<br/>
		/// There is also IMG_LoadTexture_RW(), which is equivalent to this function<br/>
		/// except that it will rely on SDL_image to determine what type of data it is<br/>
		/// loading, much like passing a NULL for type.<br/>
		/// If you would rather decode an image to an SDL_Surface (a buffer of pixels<br/>
		/// in CPU memory), call IMG_LoadTyped_RW() instead.<br/>
		/// When done with the returned texture, the app should dispose of it with a<br/>
		/// call to SDL_DestroyTexture().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadTextureTyped_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Texture*")]
		public static SDLTexture* IMGLoadTextureTypedRW([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "const char*")] byte* type)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				SDLTexture* ret = IMGLoadTextureTypedRWNative((SDLRenderer*)prenderer, src, freesrc, type);
				return ret;
			}
		}

		/// <summary>
		/// Load an image from an SDL data source into a GPU texture.<br/>
		/// An SDL_Texture represents an image in GPU memory, usable by SDL's 2D Render<br/>
		/// API. This can be significantly more efficient than using a CPU-bound<br/>
		/// SDL_Surface if you don't need to manipulate the image directly after<br/>
		/// loading it.<br/>
		/// If the loaded image has transparency or a colorkey, a texture with an alpha<br/>
		/// channel will be created. Otherwise, SDL_image will attempt to create an<br/>
		/// SDL_Texture in the most format that most reasonably represents the image<br/>
		/// data (but in many cases, this will just end up being 32-bit RGB or 32-bit<br/>
		/// RGBA).<br/>
		/// If `freesrc` is non-zero, the RWops will be closed before returning,<br/>
		/// whether this function succeeds or not. SDL_image reads everything it needs<br/>
		/// from the RWops during this call in any case.<br/>
		/// Even though this function accepts a file type, SDL_image may still try<br/>
		/// other decoders that are capable of detecting file type from the contents of<br/>
		/// the image data, but may rely on the caller-provided type string for formats<br/>
		/// that it cannot autodetect. If `type` is NULL, SDL_image will rely solely on<br/>
		/// its ability to guess the format.<br/>
		/// There is a separate function to read files from disk without having to deal<br/>
		/// with SDL_RWops: `IMG_LoadTexture("filename.jpg")` will call this function<br/>
		/// and manage those details for you, determining the file type from the<br/>
		/// filename's extension.<br/>
		/// There is also IMG_LoadTexture_RW(), which is equivalent to this function<br/>
		/// except that it will rely on SDL_image to determine what type of data it is<br/>
		/// loading, much like passing a NULL for type.<br/>
		/// If you would rather decode an image to an SDL_Surface (a buffer of pixels<br/>
		/// in CPU memory), call IMG_LoadTyped_RW() instead.<br/>
		/// When done with the returned texture, the app should dispose of it with a<br/>
		/// call to SDL_DestroyTexture().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadTextureTyped_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Texture*")]
		public static SDLTexture* IMGLoadTextureTypedRW([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops src, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "const char*")] byte* type)
		{
			fixed (SDLRWops* psrc = &src)
			{
				SDLTexture* ret = IMGLoadTextureTypedRWNative(renderer, (SDLRWops*)psrc, freesrc, type);
				return ret;
			}
		}

		/// <summary>
		/// Load an image from an SDL data source into a GPU texture.<br/>
		/// An SDL_Texture represents an image in GPU memory, usable by SDL's 2D Render<br/>
		/// API. This can be significantly more efficient than using a CPU-bound<br/>
		/// SDL_Surface if you don't need to manipulate the image directly after<br/>
		/// loading it.<br/>
		/// If the loaded image has transparency or a colorkey, a texture with an alpha<br/>
		/// channel will be created. Otherwise, SDL_image will attempt to create an<br/>
		/// SDL_Texture in the most format that most reasonably represents the image<br/>
		/// data (but in many cases, this will just end up being 32-bit RGB or 32-bit<br/>
		/// RGBA).<br/>
		/// If `freesrc` is non-zero, the RWops will be closed before returning,<br/>
		/// whether this function succeeds or not. SDL_image reads everything it needs<br/>
		/// from the RWops during this call in any case.<br/>
		/// Even though this function accepts a file type, SDL_image may still try<br/>
		/// other decoders that are capable of detecting file type from the contents of<br/>
		/// the image data, but may rely on the caller-provided type string for formats<br/>
		/// that it cannot autodetect. If `type` is NULL, SDL_image will rely solely on<br/>
		/// its ability to guess the format.<br/>
		/// There is a separate function to read files from disk without having to deal<br/>
		/// with SDL_RWops: `IMG_LoadTexture("filename.jpg")` will call this function<br/>
		/// and manage those details for you, determining the file type from the<br/>
		/// filename's extension.<br/>
		/// There is also IMG_LoadTexture_RW(), which is equivalent to this function<br/>
		/// except that it will rely on SDL_image to determine what type of data it is<br/>
		/// loading, much like passing a NULL for type.<br/>
		/// If you would rather decode an image to an SDL_Surface (a buffer of pixels<br/>
		/// in CPU memory), call IMG_LoadTyped_RW() instead.<br/>
		/// When done with the returned texture, the app should dispose of it with a<br/>
		/// call to SDL_DestroyTexture().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadTextureTyped_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Texture*")]
		public static SDLTexture* IMGLoadTextureTypedRW([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops src, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "const char*")] byte* type)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLRWops* psrc = &src)
				{
					SDLTexture* ret = IMGLoadTextureTypedRWNative((SDLRenderer*)prenderer, (SDLRWops*)psrc, freesrc, type);
					return ret;
				}
			}
		}

		/// <summary>
		/// Load an image from an SDL data source into a GPU texture.<br/>
		/// An SDL_Texture represents an image in GPU memory, usable by SDL's 2D Render<br/>
		/// API. This can be significantly more efficient than using a CPU-bound<br/>
		/// SDL_Surface if you don't need to manipulate the image directly after<br/>
		/// loading it.<br/>
		/// If the loaded image has transparency or a colorkey, a texture with an alpha<br/>
		/// channel will be created. Otherwise, SDL_image will attempt to create an<br/>
		/// SDL_Texture in the most format that most reasonably represents the image<br/>
		/// data (but in many cases, this will just end up being 32-bit RGB or 32-bit<br/>
		/// RGBA).<br/>
		/// If `freesrc` is non-zero, the RWops will be closed before returning,<br/>
		/// whether this function succeeds or not. SDL_image reads everything it needs<br/>
		/// from the RWops during this call in any case.<br/>
		/// Even though this function accepts a file type, SDL_image may still try<br/>
		/// other decoders that are capable of detecting file type from the contents of<br/>
		/// the image data, but may rely on the caller-provided type string for formats<br/>
		/// that it cannot autodetect. If `type` is NULL, SDL_image will rely solely on<br/>
		/// its ability to guess the format.<br/>
		/// There is a separate function to read files from disk without having to deal<br/>
		/// with SDL_RWops: `IMG_LoadTexture("filename.jpg")` will call this function<br/>
		/// and manage those details for you, determining the file type from the<br/>
		/// filename's extension.<br/>
		/// There is also IMG_LoadTexture_RW(), which is equivalent to this function<br/>
		/// except that it will rely on SDL_image to determine what type of data it is<br/>
		/// loading, much like passing a NULL for type.<br/>
		/// If you would rather decode an image to an SDL_Surface (a buffer of pixels<br/>
		/// in CPU memory), call IMG_LoadTyped_RW() instead.<br/>
		/// When done with the returned texture, the app should dispose of it with a<br/>
		/// call to SDL_DestroyTexture().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadTextureTyped_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Texture*")]
		public static SDLTexture* IMGLoadTextureTypedRW([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "const char*")] ref byte type)
		{
			fixed (byte* ptype = &type)
			{
				SDLTexture* ret = IMGLoadTextureTypedRWNative(renderer, src, freesrc, (byte*)ptype);
				return ret;
			}
		}

		/// <summary>
		/// Load an image from an SDL data source into a GPU texture.<br/>
		/// An SDL_Texture represents an image in GPU memory, usable by SDL's 2D Render<br/>
		/// API. This can be significantly more efficient than using a CPU-bound<br/>
		/// SDL_Surface if you don't need to manipulate the image directly after<br/>
		/// loading it.<br/>
		/// If the loaded image has transparency or a colorkey, a texture with an alpha<br/>
		/// channel will be created. Otherwise, SDL_image will attempt to create an<br/>
		/// SDL_Texture in the most format that most reasonably represents the image<br/>
		/// data (but in many cases, this will just end up being 32-bit RGB or 32-bit<br/>
		/// RGBA).<br/>
		/// If `freesrc` is non-zero, the RWops will be closed before returning,<br/>
		/// whether this function succeeds or not. SDL_image reads everything it needs<br/>
		/// from the RWops during this call in any case.<br/>
		/// Even though this function accepts a file type, SDL_image may still try<br/>
		/// other decoders that are capable of detecting file type from the contents of<br/>
		/// the image data, but may rely on the caller-provided type string for formats<br/>
		/// that it cannot autodetect. If `type` is NULL, SDL_image will rely solely on<br/>
		/// its ability to guess the format.<br/>
		/// There is a separate function to read files from disk without having to deal<br/>
		/// with SDL_RWops: `IMG_LoadTexture("filename.jpg")` will call this function<br/>
		/// and manage those details for you, determining the file type from the<br/>
		/// filename's extension.<br/>
		/// There is also IMG_LoadTexture_RW(), which is equivalent to this function<br/>
		/// except that it will rely on SDL_image to determine what type of data it is<br/>
		/// loading, much like passing a NULL for type.<br/>
		/// If you would rather decode an image to an SDL_Surface (a buffer of pixels<br/>
		/// in CPU memory), call IMG_LoadTyped_RW() instead.<br/>
		/// When done with the returned texture, the app should dispose of it with a<br/>
		/// call to SDL_DestroyTexture().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadTextureTyped_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Texture*")]
		public static SDLTexture* IMGLoadTextureTypedRW([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> type)
		{
			fixed (byte* ptype = type)
			{
				SDLTexture* ret = IMGLoadTextureTypedRWNative(renderer, src, freesrc, (byte*)ptype);
				return ret;
			}
		}

		/// <summary>
		/// Load an image from an SDL data source into a GPU texture.<br/>
		/// An SDL_Texture represents an image in GPU memory, usable by SDL's 2D Render<br/>
		/// API. This can be significantly more efficient than using a CPU-bound<br/>
		/// SDL_Surface if you don't need to manipulate the image directly after<br/>
		/// loading it.<br/>
		/// If the loaded image has transparency or a colorkey, a texture with an alpha<br/>
		/// channel will be created. Otherwise, SDL_image will attempt to create an<br/>
		/// SDL_Texture in the most format that most reasonably represents the image<br/>
		/// data (but in many cases, this will just end up being 32-bit RGB or 32-bit<br/>
		/// RGBA).<br/>
		/// If `freesrc` is non-zero, the RWops will be closed before returning,<br/>
		/// whether this function succeeds or not. SDL_image reads everything it needs<br/>
		/// from the RWops during this call in any case.<br/>
		/// Even though this function accepts a file type, SDL_image may still try<br/>
		/// other decoders that are capable of detecting file type from the contents of<br/>
		/// the image data, but may rely on the caller-provided type string for formats<br/>
		/// that it cannot autodetect. If `type` is NULL, SDL_image will rely solely on<br/>
		/// its ability to guess the format.<br/>
		/// There is a separate function to read files from disk without having to deal<br/>
		/// with SDL_RWops: `IMG_LoadTexture("filename.jpg")` will call this function<br/>
		/// and manage those details for you, determining the file type from the<br/>
		/// filename's extension.<br/>
		/// There is also IMG_LoadTexture_RW(), which is equivalent to this function<br/>
		/// except that it will rely on SDL_image to determine what type of data it is<br/>
		/// loading, much like passing a NULL for type.<br/>
		/// If you would rather decode an image to an SDL_Surface (a buffer of pixels<br/>
		/// in CPU memory), call IMG_LoadTyped_RW() instead.<br/>
		/// When done with the returned texture, the app should dispose of it with a<br/>
		/// call to SDL_DestroyTexture().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadTextureTyped_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Texture*")]
		public static SDLTexture* IMGLoadTextureTypedRW([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "const char*")] string type)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (type != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(type);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(type, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLTexture* ret = IMGLoadTextureTypedRWNative(renderer, src, freesrc, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Load an image from an SDL data source into a GPU texture.<br/>
		/// An SDL_Texture represents an image in GPU memory, usable by SDL's 2D Render<br/>
		/// API. This can be significantly more efficient than using a CPU-bound<br/>
		/// SDL_Surface if you don't need to manipulate the image directly after<br/>
		/// loading it.<br/>
		/// If the loaded image has transparency or a colorkey, a texture with an alpha<br/>
		/// channel will be created. Otherwise, SDL_image will attempt to create an<br/>
		/// SDL_Texture in the most format that most reasonably represents the image<br/>
		/// data (but in many cases, this will just end up being 32-bit RGB or 32-bit<br/>
		/// RGBA).<br/>
		/// If `freesrc` is non-zero, the RWops will be closed before returning,<br/>
		/// whether this function succeeds or not. SDL_image reads everything it needs<br/>
		/// from the RWops during this call in any case.<br/>
		/// Even though this function accepts a file type, SDL_image may still try<br/>
		/// other decoders that are capable of detecting file type from the contents of<br/>
		/// the image data, but may rely on the caller-provided type string for formats<br/>
		/// that it cannot autodetect. If `type` is NULL, SDL_image will rely solely on<br/>
		/// its ability to guess the format.<br/>
		/// There is a separate function to read files from disk without having to deal<br/>
		/// with SDL_RWops: `IMG_LoadTexture("filename.jpg")` will call this function<br/>
		/// and manage those details for you, determining the file type from the<br/>
		/// filename's extension.<br/>
		/// There is also IMG_LoadTexture_RW(), which is equivalent to this function<br/>
		/// except that it will rely on SDL_image to determine what type of data it is<br/>
		/// loading, much like passing a NULL for type.<br/>
		/// If you would rather decode an image to an SDL_Surface (a buffer of pixels<br/>
		/// in CPU memory), call IMG_LoadTyped_RW() instead.<br/>
		/// When done with the returned texture, the app should dispose of it with a<br/>
		/// call to SDL_DestroyTexture().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadTextureTyped_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Texture*")]
		public static SDLTexture* IMGLoadTextureTypedRW([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "const char*")] ref byte type)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (byte* ptype = &type)
				{
					SDLTexture* ret = IMGLoadTextureTypedRWNative((SDLRenderer*)prenderer, src, freesrc, (byte*)ptype);
					return ret;
				}
			}
		}

		/// <summary>
		/// Load an image from an SDL data source into a GPU texture.<br/>
		/// An SDL_Texture represents an image in GPU memory, usable by SDL's 2D Render<br/>
		/// API. This can be significantly more efficient than using a CPU-bound<br/>
		/// SDL_Surface if you don't need to manipulate the image directly after<br/>
		/// loading it.<br/>
		/// If the loaded image has transparency or a colorkey, a texture with an alpha<br/>
		/// channel will be created. Otherwise, SDL_image will attempt to create an<br/>
		/// SDL_Texture in the most format that most reasonably represents the image<br/>
		/// data (but in many cases, this will just end up being 32-bit RGB or 32-bit<br/>
		/// RGBA).<br/>
		/// If `freesrc` is non-zero, the RWops will be closed before returning,<br/>
		/// whether this function succeeds or not. SDL_image reads everything it needs<br/>
		/// from the RWops during this call in any case.<br/>
		/// Even though this function accepts a file type, SDL_image may still try<br/>
		/// other decoders that are capable of detecting file type from the contents of<br/>
		/// the image data, but may rely on the caller-provided type string for formats<br/>
		/// that it cannot autodetect. If `type` is NULL, SDL_image will rely solely on<br/>
		/// its ability to guess the format.<br/>
		/// There is a separate function to read files from disk without having to deal<br/>
		/// with SDL_RWops: `IMG_LoadTexture("filename.jpg")` will call this function<br/>
		/// and manage those details for you, determining the file type from the<br/>
		/// filename's extension.<br/>
		/// There is also IMG_LoadTexture_RW(), which is equivalent to this function<br/>
		/// except that it will rely on SDL_image to determine what type of data it is<br/>
		/// loading, much like passing a NULL for type.<br/>
		/// If you would rather decode an image to an SDL_Surface (a buffer of pixels<br/>
		/// in CPU memory), call IMG_LoadTyped_RW() instead.<br/>
		/// When done with the returned texture, the app should dispose of it with a<br/>
		/// call to SDL_DestroyTexture().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadTextureTyped_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Texture*")]
		public static SDLTexture* IMGLoadTextureTypedRW([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> type)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (byte* ptype = type)
				{
					SDLTexture* ret = IMGLoadTextureTypedRWNative((SDLRenderer*)prenderer, src, freesrc, (byte*)ptype);
					return ret;
				}
			}
		}

		/// <summary>
		/// Load an image from an SDL data source into a GPU texture.<br/>
		/// An SDL_Texture represents an image in GPU memory, usable by SDL's 2D Render<br/>
		/// API. This can be significantly more efficient than using a CPU-bound<br/>
		/// SDL_Surface if you don't need to manipulate the image directly after<br/>
		/// loading it.<br/>
		/// If the loaded image has transparency or a colorkey, a texture with an alpha<br/>
		/// channel will be created. Otherwise, SDL_image will attempt to create an<br/>
		/// SDL_Texture in the most format that most reasonably represents the image<br/>
		/// data (but in many cases, this will just end up being 32-bit RGB or 32-bit<br/>
		/// RGBA).<br/>
		/// If `freesrc` is non-zero, the RWops will be closed before returning,<br/>
		/// whether this function succeeds or not. SDL_image reads everything it needs<br/>
		/// from the RWops during this call in any case.<br/>
		/// Even though this function accepts a file type, SDL_image may still try<br/>
		/// other decoders that are capable of detecting file type from the contents of<br/>
		/// the image data, but may rely on the caller-provided type string for formats<br/>
		/// that it cannot autodetect. If `type` is NULL, SDL_image will rely solely on<br/>
		/// its ability to guess the format.<br/>
		/// There is a separate function to read files from disk without having to deal<br/>
		/// with SDL_RWops: `IMG_LoadTexture("filename.jpg")` will call this function<br/>
		/// and manage those details for you, determining the file type from the<br/>
		/// filename's extension.<br/>
		/// There is also IMG_LoadTexture_RW(), which is equivalent to this function<br/>
		/// except that it will rely on SDL_image to determine what type of data it is<br/>
		/// loading, much like passing a NULL for type.<br/>
		/// If you would rather decode an image to an SDL_Surface (a buffer of pixels<br/>
		/// in CPU memory), call IMG_LoadTyped_RW() instead.<br/>
		/// When done with the returned texture, the app should dispose of it with a<br/>
		/// call to SDL_DestroyTexture().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadTextureTyped_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Texture*")]
		public static SDLTexture* IMGLoadTextureTypedRW([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "const char*")] string type)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (type != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(type);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(type, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				SDLTexture* ret = IMGLoadTextureTypedRWNative((SDLRenderer*)prenderer, src, freesrc, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// Load an image from an SDL data source into a GPU texture.<br/>
		/// An SDL_Texture represents an image in GPU memory, usable by SDL's 2D Render<br/>
		/// API. This can be significantly more efficient than using a CPU-bound<br/>
		/// SDL_Surface if you don't need to manipulate the image directly after<br/>
		/// loading it.<br/>
		/// If the loaded image has transparency or a colorkey, a texture with an alpha<br/>
		/// channel will be created. Otherwise, SDL_image will attempt to create an<br/>
		/// SDL_Texture in the most format that most reasonably represents the image<br/>
		/// data (but in many cases, this will just end up being 32-bit RGB or 32-bit<br/>
		/// RGBA).<br/>
		/// If `freesrc` is non-zero, the RWops will be closed before returning,<br/>
		/// whether this function succeeds or not. SDL_image reads everything it needs<br/>
		/// from the RWops during this call in any case.<br/>
		/// Even though this function accepts a file type, SDL_image may still try<br/>
		/// other decoders that are capable of detecting file type from the contents of<br/>
		/// the image data, but may rely on the caller-provided type string for formats<br/>
		/// that it cannot autodetect. If `type` is NULL, SDL_image will rely solely on<br/>
		/// its ability to guess the format.<br/>
		/// There is a separate function to read files from disk without having to deal<br/>
		/// with SDL_RWops: `IMG_LoadTexture("filename.jpg")` will call this function<br/>
		/// and manage those details for you, determining the file type from the<br/>
		/// filename's extension.<br/>
		/// There is also IMG_LoadTexture_RW(), which is equivalent to this function<br/>
		/// except that it will rely on SDL_image to determine what type of data it is<br/>
		/// loading, much like passing a NULL for type.<br/>
		/// If you would rather decode an image to an SDL_Surface (a buffer of pixels<br/>
		/// in CPU memory), call IMG_LoadTyped_RW() instead.<br/>
		/// When done with the returned texture, the app should dispose of it with a<br/>
		/// call to SDL_DestroyTexture().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadTextureTyped_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Texture*")]
		public static SDLTexture* IMGLoadTextureTypedRW([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops src, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "const char*")] ref byte type)
		{
			fixed (SDLRWops* psrc = &src)
			{
				fixed (byte* ptype = &type)
				{
					SDLTexture* ret = IMGLoadTextureTypedRWNative(renderer, (SDLRWops*)psrc, freesrc, (byte*)ptype);
					return ret;
				}
			}
		}

		/// <summary>
		/// Load an image from an SDL data source into a GPU texture.<br/>
		/// An SDL_Texture represents an image in GPU memory, usable by SDL's 2D Render<br/>
		/// API. This can be significantly more efficient than using a CPU-bound<br/>
		/// SDL_Surface if you don't need to manipulate the image directly after<br/>
		/// loading it.<br/>
		/// If the loaded image has transparency or a colorkey, a texture with an alpha<br/>
		/// channel will be created. Otherwise, SDL_image will attempt to create an<br/>
		/// SDL_Texture in the most format that most reasonably represents the image<br/>
		/// data (but in many cases, this will just end up being 32-bit RGB or 32-bit<br/>
		/// RGBA).<br/>
		/// If `freesrc` is non-zero, the RWops will be closed before returning,<br/>
		/// whether this function succeeds or not. SDL_image reads everything it needs<br/>
		/// from the RWops during this call in any case.<br/>
		/// Even though this function accepts a file type, SDL_image may still try<br/>
		/// other decoders that are capable of detecting file type from the contents of<br/>
		/// the image data, but may rely on the caller-provided type string for formats<br/>
		/// that it cannot autodetect. If `type` is NULL, SDL_image will rely solely on<br/>
		/// its ability to guess the format.<br/>
		/// There is a separate function to read files from disk without having to deal<br/>
		/// with SDL_RWops: `IMG_LoadTexture("filename.jpg")` will call this function<br/>
		/// and manage those details for you, determining the file type from the<br/>
		/// filename's extension.<br/>
		/// There is also IMG_LoadTexture_RW(), which is equivalent to this function<br/>
		/// except that it will rely on SDL_image to determine what type of data it is<br/>
		/// loading, much like passing a NULL for type.<br/>
		/// If you would rather decode an image to an SDL_Surface (a buffer of pixels<br/>
		/// in CPU memory), call IMG_LoadTyped_RW() instead.<br/>
		/// When done with the returned texture, the app should dispose of it with a<br/>
		/// call to SDL_DestroyTexture().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadTextureTyped_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Texture*")]
		public static SDLTexture* IMGLoadTextureTypedRW([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops src, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> type)
		{
			fixed (SDLRWops* psrc = &src)
			{
				fixed (byte* ptype = type)
				{
					SDLTexture* ret = IMGLoadTextureTypedRWNative(renderer, (SDLRWops*)psrc, freesrc, (byte*)ptype);
					return ret;
				}
			}
		}

		/// <summary>
		/// Load an image from an SDL data source into a GPU texture.<br/>
		/// An SDL_Texture represents an image in GPU memory, usable by SDL's 2D Render<br/>
		/// API. This can be significantly more efficient than using a CPU-bound<br/>
		/// SDL_Surface if you don't need to manipulate the image directly after<br/>
		/// loading it.<br/>
		/// If the loaded image has transparency or a colorkey, a texture with an alpha<br/>
		/// channel will be created. Otherwise, SDL_image will attempt to create an<br/>
		/// SDL_Texture in the most format that most reasonably represents the image<br/>
		/// data (but in many cases, this will just end up being 32-bit RGB or 32-bit<br/>
		/// RGBA).<br/>
		/// If `freesrc` is non-zero, the RWops will be closed before returning,<br/>
		/// whether this function succeeds or not. SDL_image reads everything it needs<br/>
		/// from the RWops during this call in any case.<br/>
		/// Even though this function accepts a file type, SDL_image may still try<br/>
		/// other decoders that are capable of detecting file type from the contents of<br/>
		/// the image data, but may rely on the caller-provided type string for formats<br/>
		/// that it cannot autodetect. If `type` is NULL, SDL_image will rely solely on<br/>
		/// its ability to guess the format.<br/>
		/// There is a separate function to read files from disk without having to deal<br/>
		/// with SDL_RWops: `IMG_LoadTexture("filename.jpg")` will call this function<br/>
		/// and manage those details for you, determining the file type from the<br/>
		/// filename's extension.<br/>
		/// There is also IMG_LoadTexture_RW(), which is equivalent to this function<br/>
		/// except that it will rely on SDL_image to determine what type of data it is<br/>
		/// loading, much like passing a NULL for type.<br/>
		/// If you would rather decode an image to an SDL_Surface (a buffer of pixels<br/>
		/// in CPU memory), call IMG_LoadTyped_RW() instead.<br/>
		/// When done with the returned texture, the app should dispose of it with a<br/>
		/// call to SDL_DestroyTexture().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadTextureTyped_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Texture*")]
		public static SDLTexture* IMGLoadTextureTypedRW([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops src, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "const char*")] string type)
		{
			fixed (SDLRWops* psrc = &src)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (type != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(type);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(type, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				SDLTexture* ret = IMGLoadTextureTypedRWNative(renderer, (SDLRWops*)psrc, freesrc, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// Load an image from an SDL data source into a GPU texture.<br/>
		/// An SDL_Texture represents an image in GPU memory, usable by SDL's 2D Render<br/>
		/// API. This can be significantly more efficient than using a CPU-bound<br/>
		/// SDL_Surface if you don't need to manipulate the image directly after<br/>
		/// loading it.<br/>
		/// If the loaded image has transparency or a colorkey, a texture with an alpha<br/>
		/// channel will be created. Otherwise, SDL_image will attempt to create an<br/>
		/// SDL_Texture in the most format that most reasonably represents the image<br/>
		/// data (but in many cases, this will just end up being 32-bit RGB or 32-bit<br/>
		/// RGBA).<br/>
		/// If `freesrc` is non-zero, the RWops will be closed before returning,<br/>
		/// whether this function succeeds or not. SDL_image reads everything it needs<br/>
		/// from the RWops during this call in any case.<br/>
		/// Even though this function accepts a file type, SDL_image may still try<br/>
		/// other decoders that are capable of detecting file type from the contents of<br/>
		/// the image data, but may rely on the caller-provided type string for formats<br/>
		/// that it cannot autodetect. If `type` is NULL, SDL_image will rely solely on<br/>
		/// its ability to guess the format.<br/>
		/// There is a separate function to read files from disk without having to deal<br/>
		/// with SDL_RWops: `IMG_LoadTexture("filename.jpg")` will call this function<br/>
		/// and manage those details for you, determining the file type from the<br/>
		/// filename's extension.<br/>
		/// There is also IMG_LoadTexture_RW(), which is equivalent to this function<br/>
		/// except that it will rely on SDL_image to determine what type of data it is<br/>
		/// loading, much like passing a NULL for type.<br/>
		/// If you would rather decode an image to an SDL_Surface (a buffer of pixels<br/>
		/// in CPU memory), call IMG_LoadTyped_RW() instead.<br/>
		/// When done with the returned texture, the app should dispose of it with a<br/>
		/// call to SDL_DestroyTexture().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadTextureTyped_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Texture*")]
		public static SDLTexture* IMGLoadTextureTypedRW([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops src, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "const char*")] ref byte type)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLRWops* psrc = &src)
				{
					fixed (byte* ptype = &type)
					{
						SDLTexture* ret = IMGLoadTextureTypedRWNative((SDLRenderer*)prenderer, (SDLRWops*)psrc, freesrc, (byte*)ptype);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Load an image from an SDL data source into a GPU texture.<br/>
		/// An SDL_Texture represents an image in GPU memory, usable by SDL's 2D Render<br/>
		/// API. This can be significantly more efficient than using a CPU-bound<br/>
		/// SDL_Surface if you don't need to manipulate the image directly after<br/>
		/// loading it.<br/>
		/// If the loaded image has transparency or a colorkey, a texture with an alpha<br/>
		/// channel will be created. Otherwise, SDL_image will attempt to create an<br/>
		/// SDL_Texture in the most format that most reasonably represents the image<br/>
		/// data (but in many cases, this will just end up being 32-bit RGB or 32-bit<br/>
		/// RGBA).<br/>
		/// If `freesrc` is non-zero, the RWops will be closed before returning,<br/>
		/// whether this function succeeds or not. SDL_image reads everything it needs<br/>
		/// from the RWops during this call in any case.<br/>
		/// Even though this function accepts a file type, SDL_image may still try<br/>
		/// other decoders that are capable of detecting file type from the contents of<br/>
		/// the image data, but may rely on the caller-provided type string for formats<br/>
		/// that it cannot autodetect. If `type` is NULL, SDL_image will rely solely on<br/>
		/// its ability to guess the format.<br/>
		/// There is a separate function to read files from disk without having to deal<br/>
		/// with SDL_RWops: `IMG_LoadTexture("filename.jpg")` will call this function<br/>
		/// and manage those details for you, determining the file type from the<br/>
		/// filename's extension.<br/>
		/// There is also IMG_LoadTexture_RW(), which is equivalent to this function<br/>
		/// except that it will rely on SDL_image to determine what type of data it is<br/>
		/// loading, much like passing a NULL for type.<br/>
		/// If you would rather decode an image to an SDL_Surface (a buffer of pixels<br/>
		/// in CPU memory), call IMG_LoadTyped_RW() instead.<br/>
		/// When done with the returned texture, the app should dispose of it with a<br/>
		/// call to SDL_DestroyTexture().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadTextureTyped_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Texture*")]
		public static SDLTexture* IMGLoadTextureTypedRW([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops src, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> type)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLRWops* psrc = &src)
				{
					fixed (byte* ptype = type)
					{
						SDLTexture* ret = IMGLoadTextureTypedRWNative((SDLRenderer*)prenderer, (SDLRWops*)psrc, freesrc, (byte*)ptype);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Load an image from an SDL data source into a GPU texture.<br/>
		/// An SDL_Texture represents an image in GPU memory, usable by SDL's 2D Render<br/>
		/// API. This can be significantly more efficient than using a CPU-bound<br/>
		/// SDL_Surface if you don't need to manipulate the image directly after<br/>
		/// loading it.<br/>
		/// If the loaded image has transparency or a colorkey, a texture with an alpha<br/>
		/// channel will be created. Otherwise, SDL_image will attempt to create an<br/>
		/// SDL_Texture in the most format that most reasonably represents the image<br/>
		/// data (but in many cases, this will just end up being 32-bit RGB or 32-bit<br/>
		/// RGBA).<br/>
		/// If `freesrc` is non-zero, the RWops will be closed before returning,<br/>
		/// whether this function succeeds or not. SDL_image reads everything it needs<br/>
		/// from the RWops during this call in any case.<br/>
		/// Even though this function accepts a file type, SDL_image may still try<br/>
		/// other decoders that are capable of detecting file type from the contents of<br/>
		/// the image data, but may rely on the caller-provided type string for formats<br/>
		/// that it cannot autodetect. If `type` is NULL, SDL_image will rely solely on<br/>
		/// its ability to guess the format.<br/>
		/// There is a separate function to read files from disk without having to deal<br/>
		/// with SDL_RWops: `IMG_LoadTexture("filename.jpg")` will call this function<br/>
		/// and manage those details for you, determining the file type from the<br/>
		/// filename's extension.<br/>
		/// There is also IMG_LoadTexture_RW(), which is equivalent to this function<br/>
		/// except that it will rely on SDL_image to determine what type of data it is<br/>
		/// loading, much like passing a NULL for type.<br/>
		/// If you would rather decode an image to an SDL_Surface (a buffer of pixels<br/>
		/// in CPU memory), call IMG_LoadTyped_RW() instead.<br/>
		/// When done with the returned texture, the app should dispose of it with a<br/>
		/// call to SDL_DestroyTexture().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadTextureTyped_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Texture*")]
		public static SDLTexture* IMGLoadTextureTypedRW([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer*")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops src, [NativeName(NativeNameType.Param, "freesrc")] [NativeName(NativeNameType.Type, "int")] int freesrc, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "const char*")] string type)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLRWops* psrc = &src)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (type != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(type);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(type, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					SDLTexture* ret = IMGLoadTextureTypedRWNative((SDLRenderer*)prenderer, (SDLRWops*)psrc, freesrc, pStr0);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		/// <summary>
		/// Detect AVIF image data on a readable/seekable SDL_RWops.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_RWops (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek the RWops back to where it<br/>
		/// started when this function was called, but it will not report any errors in<br/>
		/// doing so, but assuming seeking works, this means you can immediately use<br/>
		/// this with a different IMG_isTYPE function, or load the image without<br/>
		/// further seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isAVIF")]
		[return: NativeName(NativeNameType.Type, "int")]
		internal static int IMGIsAVIFNative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, int>)vt[9])(src);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)vt[9])((nint)src);
			#endif
		}

		/// <summary>
		/// Detect AVIF image data on a readable/seekable SDL_RWops.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_RWops (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek the RWops back to where it<br/>
		/// started when this function was called, but it will not report any errors in<br/>
		/// doing so, but assuming seeking works, this means you can immediately use<br/>
		/// this with a different IMG_isTYPE function, or load the image without<br/>
		/// further seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isAVIF")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int IMGIsAVIF([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src)
		{
			int ret = IMGIsAVIFNative(src);
			return ret;
		}

		/// <summary>
		/// Detect AVIF image data on a readable/seekable SDL_RWops.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_RWops (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek the RWops back to where it<br/>
		/// started when this function was called, but it will not report any errors in<br/>
		/// doing so, but assuming seeking works, this means you can immediately use<br/>
		/// this with a different IMG_isTYPE function, or load the image without<br/>
		/// further seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isAVIF")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int IMGIsAVIF([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops src)
		{
			fixed (SDLRWops* psrc = &src)
			{
				int ret = IMGIsAVIFNative((SDLRWops*)psrc);
				return ret;
			}
		}

		/// <summary>
		/// Detect ICO image data on a readable/seekable SDL_RWops.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_RWops (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek the RWops back to where it<br/>
		/// started when this function was called, but it will not report any errors in<br/>
		/// doing so, but assuming seeking works, this means you can immediately use<br/>
		/// this with a different IMG_isTYPE function, or load the image without<br/>
		/// further seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isICO")]
		[return: NativeName(NativeNameType.Type, "int")]
		internal static int IMGIsICONative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, int>)vt[10])(src);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)vt[10])((nint)src);
			#endif
		}

		/// <summary>
		/// Detect ICO image data on a readable/seekable SDL_RWops.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_RWops (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek the RWops back to where it<br/>
		/// started when this function was called, but it will not report any errors in<br/>
		/// doing so, but assuming seeking works, this means you can immediately use<br/>
		/// this with a different IMG_isTYPE function, or load the image without<br/>
		/// further seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isICO")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int IMGIsICO([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src)
		{
			int ret = IMGIsICONative(src);
			return ret;
		}

		/// <summary>
		/// Detect ICO image data on a readable/seekable SDL_RWops.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_RWops (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek the RWops back to where it<br/>
		/// started when this function was called, but it will not report any errors in<br/>
		/// doing so, but assuming seeking works, this means you can immediately use<br/>
		/// this with a different IMG_isTYPE function, or load the image without<br/>
		/// further seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isICO")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int IMGIsICO([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops src)
		{
			fixed (SDLRWops* psrc = &src)
			{
				int ret = IMGIsICONative((SDLRWops*)psrc);
				return ret;
			}
		}

		/// <summary>
		/// Detect CUR image data on a readable/seekable SDL_RWops.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_RWops (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek the RWops back to where it<br/>
		/// started when this function was called, but it will not report any errors in<br/>
		/// doing so, but assuming seeking works, this means you can immediately use<br/>
		/// this with a different IMG_isTYPE function, or load the image without<br/>
		/// further seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isCUR")]
		[return: NativeName(NativeNameType.Type, "int")]
		internal static int IMGIsCURNative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, int>)vt[11])(src);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)vt[11])((nint)src);
			#endif
		}

		/// <summary>
		/// Detect CUR image data on a readable/seekable SDL_RWops.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_RWops (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek the RWops back to where it<br/>
		/// started when this function was called, but it will not report any errors in<br/>
		/// doing so, but assuming seeking works, this means you can immediately use<br/>
		/// this with a different IMG_isTYPE function, or load the image without<br/>
		/// further seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isCUR")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int IMGIsCUR([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src)
		{
			int ret = IMGIsCURNative(src);
			return ret;
		}

		/// <summary>
		/// Detect CUR image data on a readable/seekable SDL_RWops.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_RWops (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek the RWops back to where it<br/>
		/// started when this function was called, but it will not report any errors in<br/>
		/// doing so, but assuming seeking works, this means you can immediately use<br/>
		/// this with a different IMG_isTYPE function, or load the image without<br/>
		/// further seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isCUR")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int IMGIsCUR([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops src)
		{
			fixed (SDLRWops* psrc = &src)
			{
				int ret = IMGIsCURNative((SDLRWops*)psrc);
				return ret;
			}
		}

		/// <summary>
		/// Detect BMP image data on a readable/seekable SDL_RWops.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_RWops (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek the RWops back to where it<br/>
		/// started when this function was called, but it will not report any errors in<br/>
		/// doing so, but assuming seeking works, this means you can immediately use<br/>
		/// this with a different IMG_isTYPE function, or load the image without<br/>
		/// further seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isBMP")]
		[return: NativeName(NativeNameType.Type, "int")]
		internal static int IMGIsBMPNative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, int>)vt[12])(src);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)vt[12])((nint)src);
			#endif
		}

		/// <summary>
		/// Detect BMP image data on a readable/seekable SDL_RWops.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_RWops (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek the RWops back to where it<br/>
		/// started when this function was called, but it will not report any errors in<br/>
		/// doing so, but assuming seeking works, this means you can immediately use<br/>
		/// this with a different IMG_isTYPE function, or load the image without<br/>
		/// further seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isBMP")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int IMGIsBMP([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src)
		{
			int ret = IMGIsBMPNative(src);
			return ret;
		}

		/// <summary>
		/// Detect BMP image data on a readable/seekable SDL_RWops.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_RWops (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek the RWops back to where it<br/>
		/// started when this function was called, but it will not report any errors in<br/>
		/// doing so, but assuming seeking works, this means you can immediately use<br/>
		/// this with a different IMG_isTYPE function, or load the image without<br/>
		/// further seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isBMP")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int IMGIsBMP([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops src)
		{
			fixed (SDLRWops* psrc = &src)
			{
				int ret = IMGIsBMPNative((SDLRWops*)psrc);
				return ret;
			}
		}

		/// <summary>
		/// Detect GIF image data on a readable/seekable SDL_RWops.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_RWops (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek the RWops back to where it<br/>
		/// started when this function was called, but it will not report any errors in<br/>
		/// doing so, but assuming seeking works, this means you can immediately use<br/>
		/// this with a different IMG_isTYPE function, or load the image without<br/>
		/// further seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isGIF")]
		[return: NativeName(NativeNameType.Type, "int")]
		internal static int IMGIsGIFNative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, int>)vt[13])(src);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)vt[13])((nint)src);
			#endif
		}

		/// <summary>
		/// Detect GIF image data on a readable/seekable SDL_RWops.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_RWops (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek the RWops back to where it<br/>
		/// started when this function was called, but it will not report any errors in<br/>
		/// doing so, but assuming seeking works, this means you can immediately use<br/>
		/// this with a different IMG_isTYPE function, or load the image without<br/>
		/// further seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isGIF")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int IMGIsGIF([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src)
		{
			int ret = IMGIsGIFNative(src);
			return ret;
		}

		/// <summary>
		/// Detect GIF image data on a readable/seekable SDL_RWops.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_RWops (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek the RWops back to where it<br/>
		/// started when this function was called, but it will not report any errors in<br/>
		/// doing so, but assuming seeking works, this means you can immediately use<br/>
		/// this with a different IMG_isTYPE function, or load the image without<br/>
		/// further seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isGIF")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int IMGIsGIF([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops src)
		{
			fixed (SDLRWops* psrc = &src)
			{
				int ret = IMGIsGIFNative((SDLRWops*)psrc);
				return ret;
			}
		}

		/// <summary>
		/// Detect JPG image data on a readable/seekable SDL_RWops.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_RWops (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek the RWops back to where it<br/>
		/// started when this function was called, but it will not report any errors in<br/>
		/// doing so, but assuming seeking works, this means you can immediately use<br/>
		/// this with a different IMG_isTYPE function, or load the image without<br/>
		/// further seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isJPG")]
		[return: NativeName(NativeNameType.Type, "int")]
		internal static int IMGIsJPGNative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, int>)vt[14])(src);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)vt[14])((nint)src);
			#endif
		}

		/// <summary>
		/// Detect JPG image data on a readable/seekable SDL_RWops.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_RWops (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek the RWops back to where it<br/>
		/// started when this function was called, but it will not report any errors in<br/>
		/// doing so, but assuming seeking works, this means you can immediately use<br/>
		/// this with a different IMG_isTYPE function, or load the image without<br/>
		/// further seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isJPG")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int IMGIsJPG([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src)
		{
			int ret = IMGIsJPGNative(src);
			return ret;
		}

		/// <summary>
		/// Detect JPG image data on a readable/seekable SDL_RWops.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_RWops (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek the RWops back to where it<br/>
		/// started when this function was called, but it will not report any errors in<br/>
		/// doing so, but assuming seeking works, this means you can immediately use<br/>
		/// this with a different IMG_isTYPE function, or load the image without<br/>
		/// further seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isJPG")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int IMGIsJPG([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops src)
		{
			fixed (SDLRWops* psrc = &src)
			{
				int ret = IMGIsJPGNative((SDLRWops*)psrc);
				return ret;
			}
		}

		/// <summary>
		/// Detect JXL image data on a readable/seekable SDL_RWops.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_RWops (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek the RWops back to where it<br/>
		/// started when this function was called, but it will not report any errors in<br/>
		/// doing so, but assuming seeking works, this means you can immediately use<br/>
		/// this with a different IMG_isTYPE function, or load the image without<br/>
		/// further seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isJXL")]
		[return: NativeName(NativeNameType.Type, "int")]
		internal static int IMGIsJXLNative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, int>)vt[15])(src);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)vt[15])((nint)src);
			#endif
		}

		/// <summary>
		/// Detect JXL image data on a readable/seekable SDL_RWops.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_RWops (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek the RWops back to where it<br/>
		/// started when this function was called, but it will not report any errors in<br/>
		/// doing so, but assuming seeking works, this means you can immediately use<br/>
		/// this with a different IMG_isTYPE function, or load the image without<br/>
		/// further seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isJXL")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int IMGIsJXL([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src)
		{
			int ret = IMGIsJXLNative(src);
			return ret;
		}

		/// <summary>
		/// Detect JXL image data on a readable/seekable SDL_RWops.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_RWops (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek the RWops back to where it<br/>
		/// started when this function was called, but it will not report any errors in<br/>
		/// doing so, but assuming seeking works, this means you can immediately use<br/>
		/// this with a different IMG_isTYPE function, or load the image without<br/>
		/// further seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isJXL")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int IMGIsJXL([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops src)
		{
			fixed (SDLRWops* psrc = &src)
			{
				int ret = IMGIsJXLNative((SDLRWops*)psrc);
				return ret;
			}
		}

		/// <summary>
		/// Detect LBM image data on a readable/seekable SDL_RWops.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_RWops (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek the RWops back to where it<br/>
		/// started when this function was called, but it will not report any errors in<br/>
		/// doing so, but assuming seeking works, this means you can immediately use<br/>
		/// this with a different IMG_isTYPE function, or load the image without<br/>
		/// further seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isLBM")]
		[return: NativeName(NativeNameType.Type, "int")]
		internal static int IMGIsLBMNative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, int>)vt[16])(src);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)vt[16])((nint)src);
			#endif
		}

		/// <summary>
		/// Detect LBM image data on a readable/seekable SDL_RWops.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_RWops (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek the RWops back to where it<br/>
		/// started when this function was called, but it will not report any errors in<br/>
		/// doing so, but assuming seeking works, this means you can immediately use<br/>
		/// this with a different IMG_isTYPE function, or load the image without<br/>
		/// further seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isLBM")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int IMGIsLBM([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src)
		{
			int ret = IMGIsLBMNative(src);
			return ret;
		}

		/// <summary>
		/// Detect LBM image data on a readable/seekable SDL_RWops.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_RWops (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek the RWops back to where it<br/>
		/// started when this function was called, but it will not report any errors in<br/>
		/// doing so, but assuming seeking works, this means you can immediately use<br/>
		/// this with a different IMG_isTYPE function, or load the image without<br/>
		/// further seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isLBM")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int IMGIsLBM([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops src)
		{
			fixed (SDLRWops* psrc = &src)
			{
				int ret = IMGIsLBMNative((SDLRWops*)psrc);
				return ret;
			}
		}

		/// <summary>
		/// Detect PCX image data on a readable/seekable SDL_RWops.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_RWops (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek the RWops back to where it<br/>
		/// started when this function was called, but it will not report any errors in<br/>
		/// doing so, but assuming seeking works, this means you can immediately use<br/>
		/// this with a different IMG_isTYPE function, or load the image without<br/>
		/// further seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isPCX")]
		[return: NativeName(NativeNameType.Type, "int")]
		internal static int IMGIsPCXNative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, int>)vt[17])(src);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)vt[17])((nint)src);
			#endif
		}

		/// <summary>
		/// Detect PCX image data on a readable/seekable SDL_RWops.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_RWops (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek the RWops back to where it<br/>
		/// started when this function was called, but it will not report any errors in<br/>
		/// doing so, but assuming seeking works, this means you can immediately use<br/>
		/// this with a different IMG_isTYPE function, or load the image without<br/>
		/// further seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isPCX")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int IMGIsPCX([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src)
		{
			int ret = IMGIsPCXNative(src);
			return ret;
		}

		/// <summary>
		/// Detect PCX image data on a readable/seekable SDL_RWops.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_RWops (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek the RWops back to where it<br/>
		/// started when this function was called, but it will not report any errors in<br/>
		/// doing so, but assuming seeking works, this means you can immediately use<br/>
		/// this with a different IMG_isTYPE function, or load the image without<br/>
		/// further seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isPCX")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int IMGIsPCX([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops src)
		{
			fixed (SDLRWops* psrc = &src)
			{
				int ret = IMGIsPCXNative((SDLRWops*)psrc);
				return ret;
			}
		}

		/// <summary>
		/// Detect PNG image data on a readable/seekable SDL_RWops.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_RWops (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek the RWops back to where it<br/>
		/// started when this function was called, but it will not report any errors in<br/>
		/// doing so, but assuming seeking works, this means you can immediately use<br/>
		/// this with a different IMG_isTYPE function, or load the image without<br/>
		/// further seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isPNG")]
		[return: NativeName(NativeNameType.Type, "int")]
		internal static int IMGIsPNGNative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, int>)vt[18])(src);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)vt[18])((nint)src);
			#endif
		}

		/// <summary>
		/// Detect PNG image data on a readable/seekable SDL_RWops.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_RWops (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek the RWops back to where it<br/>
		/// started when this function was called, but it will not report any errors in<br/>
		/// doing so, but assuming seeking works, this means you can immediately use<br/>
		/// this with a different IMG_isTYPE function, or load the image without<br/>
		/// further seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isPNG")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int IMGIsPNG([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src)
		{
			int ret = IMGIsPNGNative(src);
			return ret;
		}

		/// <summary>
		/// Detect PNG image data on a readable/seekable SDL_RWops.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_RWops (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek the RWops back to where it<br/>
		/// started when this function was called, but it will not report any errors in<br/>
		/// doing so, but assuming seeking works, this means you can immediately use<br/>
		/// this with a different IMG_isTYPE function, or load the image without<br/>
		/// further seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isPNG")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int IMGIsPNG([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops src)
		{
			fixed (SDLRWops* psrc = &src)
			{
				int ret = IMGIsPNGNative((SDLRWops*)psrc);
				return ret;
			}
		}

		/// <summary>
		/// Detect PNM image data on a readable/seekable SDL_RWops.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_RWops (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek the RWops back to where it<br/>
		/// started when this function was called, but it will not report any errors in<br/>
		/// doing so, but assuming seeking works, this means you can immediately use<br/>
		/// this with a different IMG_isTYPE function, or load the image without<br/>
		/// further seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isPNM")]
		[return: NativeName(NativeNameType.Type, "int")]
		internal static int IMGIsPNMNative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, int>)vt[19])(src);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)vt[19])((nint)src);
			#endif
		}

		/// <summary>
		/// Detect PNM image data on a readable/seekable SDL_RWops.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_RWops (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek the RWops back to where it<br/>
		/// started when this function was called, but it will not report any errors in<br/>
		/// doing so, but assuming seeking works, this means you can immediately use<br/>
		/// this with a different IMG_isTYPE function, or load the image without<br/>
		/// further seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isPNM")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int IMGIsPNM([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src)
		{
			int ret = IMGIsPNMNative(src);
			return ret;
		}

		/// <summary>
		/// Detect PNM image data on a readable/seekable SDL_RWops.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_RWops (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek the RWops back to where it<br/>
		/// started when this function was called, but it will not report any errors in<br/>
		/// doing so, but assuming seeking works, this means you can immediately use<br/>
		/// this with a different IMG_isTYPE function, or load the image without<br/>
		/// further seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isPNM")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int IMGIsPNM([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops src)
		{
			fixed (SDLRWops* psrc = &src)
			{
				int ret = IMGIsPNMNative((SDLRWops*)psrc);
				return ret;
			}
		}

		/// <summary>
		/// Detect SVG image data on a readable/seekable SDL_RWops.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_RWops (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek the RWops back to where it<br/>
		/// started when this function was called, but it will not report any errors in<br/>
		/// doing so, but assuming seeking works, this means you can immediately use<br/>
		/// this with a different IMG_isTYPE function, or load the image without<br/>
		/// further seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isSVG")]
		[return: NativeName(NativeNameType.Type, "int")]
		internal static int IMGIsSVGNative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, int>)vt[20])(src);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)vt[20])((nint)src);
			#endif
		}

		/// <summary>
		/// Detect SVG image data on a readable/seekable SDL_RWops.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_RWops (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek the RWops back to where it<br/>
		/// started when this function was called, but it will not report any errors in<br/>
		/// doing so, but assuming seeking works, this means you can immediately use<br/>
		/// this with a different IMG_isTYPE function, or load the image without<br/>
		/// further seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isSVG")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int IMGIsSVG([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src)
		{
			int ret = IMGIsSVGNative(src);
			return ret;
		}

		/// <summary>
		/// Detect SVG image data on a readable/seekable SDL_RWops.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_RWops (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek the RWops back to where it<br/>
		/// started when this function was called, but it will not report any errors in<br/>
		/// doing so, but assuming seeking works, this means you can immediately use<br/>
		/// this with a different IMG_isTYPE function, or load the image without<br/>
		/// further seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isSVG")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int IMGIsSVG([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops src)
		{
			fixed (SDLRWops* psrc = &src)
			{
				int ret = IMGIsSVGNative((SDLRWops*)psrc);
				return ret;
			}
		}

		/// <summary>
		/// Detect QOI image data on a readable/seekable SDL_RWops.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_RWops (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek the RWops back to where it<br/>
		/// started when this function was called, but it will not report any errors in<br/>
		/// doing so, but assuming seeking works, this means you can immediately use<br/>
		/// this with a different IMG_isTYPE function, or load the image without<br/>
		/// further seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isQOI")]
		[return: NativeName(NativeNameType.Type, "int")]
		internal static int IMGIsQOINative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, int>)vt[21])(src);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)vt[21])((nint)src);
			#endif
		}

		/// <summary>
		/// Detect QOI image data on a readable/seekable SDL_RWops.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_RWops (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek the RWops back to where it<br/>
		/// started when this function was called, but it will not report any errors in<br/>
		/// doing so, but assuming seeking works, this means you can immediately use<br/>
		/// this with a different IMG_isTYPE function, or load the image without<br/>
		/// further seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isQOI")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int IMGIsQOI([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src)
		{
			int ret = IMGIsQOINative(src);
			return ret;
		}

		/// <summary>
		/// Detect QOI image data on a readable/seekable SDL_RWops.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_RWops (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek the RWops back to where it<br/>
		/// started when this function was called, but it will not report any errors in<br/>
		/// doing so, but assuming seeking works, this means you can immediately use<br/>
		/// this with a different IMG_isTYPE function, or load the image without<br/>
		/// further seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isQOI")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int IMGIsQOI([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops src)
		{
			fixed (SDLRWops* psrc = &src)
			{
				int ret = IMGIsQOINative((SDLRWops*)psrc);
				return ret;
			}
		}

		/// <summary>
		/// Detect TIFF image data on a readable/seekable SDL_RWops.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_RWops (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek the RWops back to where it<br/>
		/// started when this function was called, but it will not report any errors in<br/>
		/// doing so, but assuming seeking works, this means you can immediately use<br/>
		/// this with a different IMG_isTYPE function, or load the image without<br/>
		/// further seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isTIF")]
		[return: NativeName(NativeNameType.Type, "int")]
		internal static int IMGIsTIFNative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, int>)vt[22])(src);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)vt[22])((nint)src);
			#endif
		}

		/// <summary>
		/// Detect TIFF image data on a readable/seekable SDL_RWops.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_RWops (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek the RWops back to where it<br/>
		/// started when this function was called, but it will not report any errors in<br/>
		/// doing so, but assuming seeking works, this means you can immediately use<br/>
		/// this with a different IMG_isTYPE function, or load the image without<br/>
		/// further seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isTIF")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int IMGIsTIF([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src)
		{
			int ret = IMGIsTIFNative(src);
			return ret;
		}

		/// <summary>
		/// Detect TIFF image data on a readable/seekable SDL_RWops.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_RWops (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek the RWops back to where it<br/>
		/// started when this function was called, but it will not report any errors in<br/>
		/// doing so, but assuming seeking works, this means you can immediately use<br/>
		/// this with a different IMG_isTYPE function, or load the image without<br/>
		/// further seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isTIF")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int IMGIsTIF([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops src)
		{
			fixed (SDLRWops* psrc = &src)
			{
				int ret = IMGIsTIFNative((SDLRWops*)psrc);
				return ret;
			}
		}

		/// <summary>
		/// Detect XCF image data on a readable/seekable SDL_RWops.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_RWops (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek the RWops back to where it<br/>
		/// started when this function was called, but it will not report any errors in<br/>
		/// doing so, but assuming seeking works, this means you can immediately use<br/>
		/// this with a different IMG_isTYPE function, or load the image without<br/>
		/// further seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isXCF")]
		[return: NativeName(NativeNameType.Type, "int")]
		internal static int IMGIsXCFNative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, int>)vt[23])(src);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)vt[23])((nint)src);
			#endif
		}

		/// <summary>
		/// Detect XCF image data on a readable/seekable SDL_RWops.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_RWops (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek the RWops back to where it<br/>
		/// started when this function was called, but it will not report any errors in<br/>
		/// doing so, but assuming seeking works, this means you can immediately use<br/>
		/// this with a different IMG_isTYPE function, or load the image without<br/>
		/// further seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isXCF")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int IMGIsXCF([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src)
		{
			int ret = IMGIsXCFNative(src);
			return ret;
		}

		/// <summary>
		/// Detect XCF image data on a readable/seekable SDL_RWops.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_RWops (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek the RWops back to where it<br/>
		/// started when this function was called, but it will not report any errors in<br/>
		/// doing so, but assuming seeking works, this means you can immediately use<br/>
		/// this with a different IMG_isTYPE function, or load the image without<br/>
		/// further seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isXCF")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int IMGIsXCF([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops src)
		{
			fixed (SDLRWops* psrc = &src)
			{
				int ret = IMGIsXCFNative((SDLRWops*)psrc);
				return ret;
			}
		}

		/// <summary>
		/// Detect XPM image data on a readable/seekable SDL_RWops.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_RWops (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek the RWops back to where it<br/>
		/// started when this function was called, but it will not report any errors in<br/>
		/// doing so, but assuming seeking works, this means you can immediately use<br/>
		/// this with a different IMG_isTYPE function, or load the image without<br/>
		/// further seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isXPM")]
		[return: NativeName(NativeNameType.Type, "int")]
		internal static int IMGIsXPMNative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, int>)vt[24])(src);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)vt[24])((nint)src);
			#endif
		}

		/// <summary>
		/// Detect XPM image data on a readable/seekable SDL_RWops.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_RWops (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek the RWops back to where it<br/>
		/// started when this function was called, but it will not report any errors in<br/>
		/// doing so, but assuming seeking works, this means you can immediately use<br/>
		/// this with a different IMG_isTYPE function, or load the image without<br/>
		/// further seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isXPM")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int IMGIsXPM([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src)
		{
			int ret = IMGIsXPMNative(src);
			return ret;
		}

		/// <summary>
		/// Detect XPM image data on a readable/seekable SDL_RWops.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_RWops (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek the RWops back to where it<br/>
		/// started when this function was called, but it will not report any errors in<br/>
		/// doing so, but assuming seeking works, this means you can immediately use<br/>
		/// this with a different IMG_isTYPE function, or load the image without<br/>
		/// further seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isXPM")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int IMGIsXPM([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops src)
		{
			fixed (SDLRWops* psrc = &src)
			{
				int ret = IMGIsXPMNative((SDLRWops*)psrc);
				return ret;
			}
		}

		/// <summary>
		/// Detect XV image data on a readable/seekable SDL_RWops.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_RWops (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek the RWops back to where it<br/>
		/// started when this function was called, but it will not report any errors in<br/>
		/// doing so, but assuming seeking works, this means you can immediately use<br/>
		/// this with a different IMG_isTYPE function, or load the image without<br/>
		/// further seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isXV")]
		[return: NativeName(NativeNameType.Type, "int")]
		internal static int IMGIsXVNative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, int>)vt[25])(src);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)vt[25])((nint)src);
			#endif
		}

		/// <summary>
		/// Detect XV image data on a readable/seekable SDL_RWops.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_RWops (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek the RWops back to where it<br/>
		/// started when this function was called, but it will not report any errors in<br/>
		/// doing so, but assuming seeking works, this means you can immediately use<br/>
		/// this with a different IMG_isTYPE function, or load the image without<br/>
		/// further seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isXV")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int IMGIsXV([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src)
		{
			int ret = IMGIsXVNative(src);
			return ret;
		}

		/// <summary>
		/// Detect XV image data on a readable/seekable SDL_RWops.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_RWops (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek the RWops back to where it<br/>
		/// started when this function was called, but it will not report any errors in<br/>
		/// doing so, but assuming seeking works, this means you can immediately use<br/>
		/// this with a different IMG_isTYPE function, or load the image without<br/>
		/// further seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isXV")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int IMGIsXV([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops src)
		{
			fixed (SDLRWops* psrc = &src)
			{
				int ret = IMGIsXVNative((SDLRWops*)psrc);
				return ret;
			}
		}

		/// <summary>
		/// Detect WEBP image data on a readable/seekable SDL_RWops.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_RWops (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek the RWops back to where it<br/>
		/// started when this function was called, but it will not report any errors in<br/>
		/// doing so, but assuming seeking works, this means you can immediately use<br/>
		/// this with a different IMG_isTYPE function, or load the image without<br/>
		/// further seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isWEBP")]
		[return: NativeName(NativeNameType.Type, "int")]
		internal static int IMGIsWEBPNative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, int>)vt[26])(src);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)vt[26])((nint)src);
			#endif
		}

		/// <summary>
		/// Detect WEBP image data on a readable/seekable SDL_RWops.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_RWops (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek the RWops back to where it<br/>
		/// started when this function was called, but it will not report any errors in<br/>
		/// doing so, but assuming seeking works, this means you can immediately use<br/>
		/// this with a different IMG_isTYPE function, or load the image without<br/>
		/// further seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isWEBP")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int IMGIsWEBP([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src)
		{
			int ret = IMGIsWEBPNative(src);
			return ret;
		}

		/// <summary>
		/// Detect WEBP image data on a readable/seekable SDL_RWops.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_RWops (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek the RWops back to where it<br/>
		/// started when this function was called, but it will not report any errors in<br/>
		/// doing so, but assuming seeking works, this means you can immediately use<br/>
		/// this with a different IMG_isTYPE function, or load the image without<br/>
		/// further seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isWEBP")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int IMGIsWEBP([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops src)
		{
			fixed (SDLRWops* psrc = &src)
			{
				int ret = IMGIsWEBPNative((SDLRWops*)psrc);
				return ret;
			}
		}

		/// <summary>
		/// Load a AVIF image directly.<br/>
		/// If you know you definitely have a AVIF image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_RWops<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadAVIF_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface*")]
		internal static SDLSurface* IMGLoadAVIFRWNative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, SDLSurface*>)vt[27])(src);
			#else
			return (SDLSurface*)((delegate* unmanaged[Cdecl]<nint, nint>)vt[27])((nint)src);
			#endif
		}

		/// <summary>
		/// Load a AVIF image directly.<br/>
		/// If you know you definitely have a AVIF image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_RWops<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadAVIF_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface*")]
		public static SDLSurface* IMGLoadAVIFRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src)
		{
			SDLSurface* ret = IMGLoadAVIFRWNative(src);
			return ret;
		}

		/// <summary>
		/// Load a AVIF image directly.<br/>
		/// If you know you definitely have a AVIF image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_RWops<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadAVIF_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface*")]
		public static SDLSurface* IMGLoadAVIFRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops src)
		{
			fixed (SDLRWops* psrc = &src)
			{
				SDLSurface* ret = IMGLoadAVIFRWNative((SDLRWops*)psrc);
				return ret;
			}
		}

		/// <summary>
		/// Load a ICO image directly.<br/>
		/// If you know you definitely have a ICO image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_RWops<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadICO_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface*")]
		internal static SDLSurface* IMGLoadICORWNative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, SDLSurface*>)vt[28])(src);
			#else
			return (SDLSurface*)((delegate* unmanaged[Cdecl]<nint, nint>)vt[28])((nint)src);
			#endif
		}

		/// <summary>
		/// Load a ICO image directly.<br/>
		/// If you know you definitely have a ICO image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_RWops<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadICO_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface*")]
		public static SDLSurface* IMGLoadICORW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src)
		{
			SDLSurface* ret = IMGLoadICORWNative(src);
			return ret;
		}

		/// <summary>
		/// Load a ICO image directly.<br/>
		/// If you know you definitely have a ICO image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_RWops<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadICO_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface*")]
		public static SDLSurface* IMGLoadICORW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops src)
		{
			fixed (SDLRWops* psrc = &src)
			{
				SDLSurface* ret = IMGLoadICORWNative((SDLRWops*)psrc);
				return ret;
			}
		}

		/// <summary>
		/// Load a CUR image directly.<br/>
		/// If you know you definitely have a CUR image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_RWops<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadCUR_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface*")]
		internal static SDLSurface* IMGLoadCURRWNative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, SDLSurface*>)vt[29])(src);
			#else
			return (SDLSurface*)((delegate* unmanaged[Cdecl]<nint, nint>)vt[29])((nint)src);
			#endif
		}

		/// <summary>
		/// Load a CUR image directly.<br/>
		/// If you know you definitely have a CUR image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_RWops<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadCUR_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface*")]
		public static SDLSurface* IMGLoadCURRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src)
		{
			SDLSurface* ret = IMGLoadCURRWNative(src);
			return ret;
		}

		/// <summary>
		/// Load a CUR image directly.<br/>
		/// If you know you definitely have a CUR image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_RWops<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadCUR_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface*")]
		public static SDLSurface* IMGLoadCURRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops src)
		{
			fixed (SDLRWops* psrc = &src)
			{
				SDLSurface* ret = IMGLoadCURRWNative((SDLRWops*)psrc);
				return ret;
			}
		}

		/// <summary>
		/// Load a BMP image directly.<br/>
		/// If you know you definitely have a BMP image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_RWops<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadBMP_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface*")]
		internal static SDLSurface* IMGLoadBMPRWNative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, SDLSurface*>)vt[30])(src);
			#else
			return (SDLSurface*)((delegate* unmanaged[Cdecl]<nint, nint>)vt[30])((nint)src);
			#endif
		}

		/// <summary>
		/// Load a BMP image directly.<br/>
		/// If you know you definitely have a BMP image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_RWops<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadBMP_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface*")]
		public static SDLSurface* IMGLoadBMPRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src)
		{
			SDLSurface* ret = IMGLoadBMPRWNative(src);
			return ret;
		}

		/// <summary>
		/// Load a BMP image directly.<br/>
		/// If you know you definitely have a BMP image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_RWops<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadBMP_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface*")]
		public static SDLSurface* IMGLoadBMPRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops src)
		{
			fixed (SDLRWops* psrc = &src)
			{
				SDLSurface* ret = IMGLoadBMPRWNative((SDLRWops*)psrc);
				return ret;
			}
		}

		/// <summary>
		/// Load a GIF image directly.<br/>
		/// If you know you definitely have a GIF image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_RWops<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadGIF_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface*")]
		internal static SDLSurface* IMGLoadGIFRWNative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, SDLSurface*>)vt[31])(src);
			#else
			return (SDLSurface*)((delegate* unmanaged[Cdecl]<nint, nint>)vt[31])((nint)src);
			#endif
		}

		/// <summary>
		/// Load a GIF image directly.<br/>
		/// If you know you definitely have a GIF image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_RWops<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadGIF_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface*")]
		public static SDLSurface* IMGLoadGIFRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src)
		{
			SDLSurface* ret = IMGLoadGIFRWNative(src);
			return ret;
		}

		/// <summary>
		/// Load a GIF image directly.<br/>
		/// If you know you definitely have a GIF image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_RWops<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadGIF_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface*")]
		public static SDLSurface* IMGLoadGIFRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops src)
		{
			fixed (SDLRWops* psrc = &src)
			{
				SDLSurface* ret = IMGLoadGIFRWNative((SDLRWops*)psrc);
				return ret;
			}
		}

		/// <summary>
		/// Load a JPG image directly.<br/>
		/// If you know you definitely have a JPG image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_RWops<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadJPG_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface*")]
		internal static SDLSurface* IMGLoadJPGRWNative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, SDLSurface*>)vt[32])(src);
			#else
			return (SDLSurface*)((delegate* unmanaged[Cdecl]<nint, nint>)vt[32])((nint)src);
			#endif
		}

		/// <summary>
		/// Load a JPG image directly.<br/>
		/// If you know you definitely have a JPG image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_RWops<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadJPG_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface*")]
		public static SDLSurface* IMGLoadJPGRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src)
		{
			SDLSurface* ret = IMGLoadJPGRWNative(src);
			return ret;
		}

		/// <summary>
		/// Load a JPG image directly.<br/>
		/// If you know you definitely have a JPG image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_RWops<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadJPG_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface*")]
		public static SDLSurface* IMGLoadJPGRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops src)
		{
			fixed (SDLRWops* psrc = &src)
			{
				SDLSurface* ret = IMGLoadJPGRWNative((SDLRWops*)psrc);
				return ret;
			}
		}

		/// <summary>
		/// Load a JXL image directly.<br/>
		/// If you know you definitely have a JXL image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_RWops<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadJXL_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface*")]
		internal static SDLSurface* IMGLoadJXLRWNative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, SDLSurface*>)vt[33])(src);
			#else
			return (SDLSurface*)((delegate* unmanaged[Cdecl]<nint, nint>)vt[33])((nint)src);
			#endif
		}

		/// <summary>
		/// Load a JXL image directly.<br/>
		/// If you know you definitely have a JXL image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_RWops<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadJXL_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface*")]
		public static SDLSurface* IMGLoadJXLRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src)
		{
			SDLSurface* ret = IMGLoadJXLRWNative(src);
			return ret;
		}

		/// <summary>
		/// Load a JXL image directly.<br/>
		/// If you know you definitely have a JXL image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_RWops<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadJXL_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface*")]
		public static SDLSurface* IMGLoadJXLRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops src)
		{
			fixed (SDLRWops* psrc = &src)
			{
				SDLSurface* ret = IMGLoadJXLRWNative((SDLRWops*)psrc);
				return ret;
			}
		}

		/// <summary>
		/// Load a LBM image directly.<br/>
		/// If you know you definitely have a LBM image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_RWops<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadLBM_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface*")]
		internal static SDLSurface* IMGLoadLBMRWNative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, SDLSurface*>)vt[34])(src);
			#else
			return (SDLSurface*)((delegate* unmanaged[Cdecl]<nint, nint>)vt[34])((nint)src);
			#endif
		}

		/// <summary>
		/// Load a LBM image directly.<br/>
		/// If you know you definitely have a LBM image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_RWops<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadLBM_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface*")]
		public static SDLSurface* IMGLoadLBMRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src)
		{
			SDLSurface* ret = IMGLoadLBMRWNative(src);
			return ret;
		}

		/// <summary>
		/// Load a LBM image directly.<br/>
		/// If you know you definitely have a LBM image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_RWops<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadLBM_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface*")]
		public static SDLSurface* IMGLoadLBMRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops src)
		{
			fixed (SDLRWops* psrc = &src)
			{
				SDLSurface* ret = IMGLoadLBMRWNative((SDLRWops*)psrc);
				return ret;
			}
		}

		/// <summary>
		/// Load a PCX image directly.<br/>
		/// If you know you definitely have a PCX image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_RWops<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadPCX_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface*")]
		internal static SDLSurface* IMGLoadPCXRWNative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, SDLSurface*>)vt[35])(src);
			#else
			return (SDLSurface*)((delegate* unmanaged[Cdecl]<nint, nint>)vt[35])((nint)src);
			#endif
		}

		/// <summary>
		/// Load a PCX image directly.<br/>
		/// If you know you definitely have a PCX image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_RWops<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadPCX_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface*")]
		public static SDLSurface* IMGLoadPCXRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src)
		{
			SDLSurface* ret = IMGLoadPCXRWNative(src);
			return ret;
		}

		/// <summary>
		/// Load a PCX image directly.<br/>
		/// If you know you definitely have a PCX image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_RWops<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadPCX_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface*")]
		public static SDLSurface* IMGLoadPCXRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops src)
		{
			fixed (SDLRWops* psrc = &src)
			{
				SDLSurface* ret = IMGLoadPCXRWNative((SDLRWops*)psrc);
				return ret;
			}
		}

		/// <summary>
		/// Load a PNG image directly.<br/>
		/// If you know you definitely have a PNG image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_RWops<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadPNG_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface*")]
		internal static SDLSurface* IMGLoadPNGRWNative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, SDLSurface*>)vt[36])(src);
			#else
			return (SDLSurface*)((delegate* unmanaged[Cdecl]<nint, nint>)vt[36])((nint)src);
			#endif
		}

		/// <summary>
		/// Load a PNG image directly.<br/>
		/// If you know you definitely have a PNG image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_RWops<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadPNG_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface*")]
		public static SDLSurface* IMGLoadPNGRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src)
		{
			SDLSurface* ret = IMGLoadPNGRWNative(src);
			return ret;
		}

		/// <summary>
		/// Load a PNG image directly.<br/>
		/// If you know you definitely have a PNG image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_RWops<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadPNG_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface*")]
		public static SDLSurface* IMGLoadPNGRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops src)
		{
			fixed (SDLRWops* psrc = &src)
			{
				SDLSurface* ret = IMGLoadPNGRWNative((SDLRWops*)psrc);
				return ret;
			}
		}

		/// <summary>
		/// Load a PNM image directly.<br/>
		/// If you know you definitely have a PNM image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_RWops<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadPNM_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface*")]
		internal static SDLSurface* IMGLoadPNMRWNative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, SDLSurface*>)vt[37])(src);
			#else
			return (SDLSurface*)((delegate* unmanaged[Cdecl]<nint, nint>)vt[37])((nint)src);
			#endif
		}

		/// <summary>
		/// Load a PNM image directly.<br/>
		/// If you know you definitely have a PNM image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_RWops<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadPNM_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface*")]
		public static SDLSurface* IMGLoadPNMRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src)
		{
			SDLSurface* ret = IMGLoadPNMRWNative(src);
			return ret;
		}

		/// <summary>
		/// Load a PNM image directly.<br/>
		/// If you know you definitely have a PNM image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_RWops<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadPNM_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface*")]
		public static SDLSurface* IMGLoadPNMRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops src)
		{
			fixed (SDLRWops* psrc = &src)
			{
				SDLSurface* ret = IMGLoadPNMRWNative((SDLRWops*)psrc);
				return ret;
			}
		}

		/// <summary>
		/// Load a SVG image directly.<br/>
		/// If you know you definitely have a SVG image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_RWops<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadSVG_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface*")]
		internal static SDLSurface* IMGLoadSVGRWNative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, SDLSurface*>)vt[38])(src);
			#else
			return (SDLSurface*)((delegate* unmanaged[Cdecl]<nint, nint>)vt[38])((nint)src);
			#endif
		}

		/// <summary>
		/// Load a SVG image directly.<br/>
		/// If you know you definitely have a SVG image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_RWops<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadSVG_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface*")]
		public static SDLSurface* IMGLoadSVGRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src)
		{
			SDLSurface* ret = IMGLoadSVGRWNative(src);
			return ret;
		}

		/// <summary>
		/// Load a SVG image directly.<br/>
		/// If you know you definitely have a SVG image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_RWops<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadSVG_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface*")]
		public static SDLSurface* IMGLoadSVGRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops src)
		{
			fixed (SDLRWops* psrc = &src)
			{
				SDLSurface* ret = IMGLoadSVGRWNative((SDLRWops*)psrc);
				return ret;
			}
		}

		/// <summary>
		/// Load a QOI image directly.<br/>
		/// If you know you definitely have a QOI image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_RWops<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadQOI_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface*")]
		internal static SDLSurface* IMGLoadQOIRWNative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, SDLSurface*>)vt[39])(src);
			#else
			return (SDLSurface*)((delegate* unmanaged[Cdecl]<nint, nint>)vt[39])((nint)src);
			#endif
		}

		/// <summary>
		/// Load a QOI image directly.<br/>
		/// If you know you definitely have a QOI image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_RWops<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadQOI_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface*")]
		public static SDLSurface* IMGLoadQOIRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src)
		{
			SDLSurface* ret = IMGLoadQOIRWNative(src);
			return ret;
		}

		/// <summary>
		/// Load a QOI image directly.<br/>
		/// If you know you definitely have a QOI image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_RWops<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadQOI_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface*")]
		public static SDLSurface* IMGLoadQOIRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops src)
		{
			fixed (SDLRWops* psrc = &src)
			{
				SDLSurface* ret = IMGLoadQOIRWNative((SDLRWops*)psrc);
				return ret;
			}
		}

		/// <summary>
		/// Load a TGA image directly.<br/>
		/// If you know you definitely have a TGA image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_RWops<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadTGA_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface*")]
		internal static SDLSurface* IMGLoadTGARWNative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, SDLSurface*>)vt[40])(src);
			#else
			return (SDLSurface*)((delegate* unmanaged[Cdecl]<nint, nint>)vt[40])((nint)src);
			#endif
		}

		/// <summary>
		/// Load a TGA image directly.<br/>
		/// If you know you definitely have a TGA image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_RWops<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadTGA_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface*")]
		public static SDLSurface* IMGLoadTGARW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src)
		{
			SDLSurface* ret = IMGLoadTGARWNative(src);
			return ret;
		}

		/// <summary>
		/// Load a TGA image directly.<br/>
		/// If you know you definitely have a TGA image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_RWops<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadTGA_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface*")]
		public static SDLSurface* IMGLoadTGARW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops src)
		{
			fixed (SDLRWops* psrc = &src)
			{
				SDLSurface* ret = IMGLoadTGARWNative((SDLRWops*)psrc);
				return ret;
			}
		}

		/// <summary>
		/// Load a TIFF image directly.<br/>
		/// If you know you definitely have a TIFF image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_RWops<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadTIF_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface*")]
		internal static SDLSurface* IMGLoadTIFRWNative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, SDLSurface*>)vt[41])(src);
			#else
			return (SDLSurface*)((delegate* unmanaged[Cdecl]<nint, nint>)vt[41])((nint)src);
			#endif
		}

		/// <summary>
		/// Load a TIFF image directly.<br/>
		/// If you know you definitely have a TIFF image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_RWops<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadTIF_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface*")]
		public static SDLSurface* IMGLoadTIFRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src)
		{
			SDLSurface* ret = IMGLoadTIFRWNative(src);
			return ret;
		}

		/// <summary>
		/// Load a TIFF image directly.<br/>
		/// If you know you definitely have a TIFF image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_RWops<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadTIF_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface*")]
		public static SDLSurface* IMGLoadTIFRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops src)
		{
			fixed (SDLRWops* psrc = &src)
			{
				SDLSurface* ret = IMGLoadTIFRWNative((SDLRWops*)psrc);
				return ret;
			}
		}

		/// <summary>
		/// Load a XCF image directly.<br/>
		/// If you know you definitely have a XCF image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_RWops<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadXCF_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface*")]
		internal static SDLSurface* IMGLoadXCFRWNative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, SDLSurface*>)vt[42])(src);
			#else
			return (SDLSurface*)((delegate* unmanaged[Cdecl]<nint, nint>)vt[42])((nint)src);
			#endif
		}

		/// <summary>
		/// Load a XCF image directly.<br/>
		/// If you know you definitely have a XCF image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_RWops<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadXCF_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface*")]
		public static SDLSurface* IMGLoadXCFRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src)
		{
			SDLSurface* ret = IMGLoadXCFRWNative(src);
			return ret;
		}

		/// <summary>
		/// Load a XCF image directly.<br/>
		/// If you know you definitely have a XCF image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_RWops<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadXCF_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface*")]
		public static SDLSurface* IMGLoadXCFRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops src)
		{
			fixed (SDLRWops* psrc = &src)
			{
				SDLSurface* ret = IMGLoadXCFRWNative((SDLRWops*)psrc);
				return ret;
			}
		}

		/// <summary>
		/// Load a XPM image directly.<br/>
		/// If you know you definitely have a XPM image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_RWops<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadXPM_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface*")]
		internal static SDLSurface* IMGLoadXPMRWNative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, SDLSurface*>)vt[43])(src);
			#else
			return (SDLSurface*)((delegate* unmanaged[Cdecl]<nint, nint>)vt[43])((nint)src);
			#endif
		}

		/// <summary>
		/// Load a XPM image directly.<br/>
		/// If you know you definitely have a XPM image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_RWops<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadXPM_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface*")]
		public static SDLSurface* IMGLoadXPMRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src)
		{
			SDLSurface* ret = IMGLoadXPMRWNative(src);
			return ret;
		}

		/// <summary>
		/// Load a XPM image directly.<br/>
		/// If you know you definitely have a XPM image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_RWops<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadXPM_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface*")]
		public static SDLSurface* IMGLoadXPMRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops src)
		{
			fixed (SDLRWops* psrc = &src)
			{
				SDLSurface* ret = IMGLoadXPMRWNative((SDLRWops*)psrc);
				return ret;
			}
		}

		/// <summary>
		/// Load a XV image directly.<br/>
		/// If you know you definitely have a XV image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_RWops<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadXV_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface*")]
		internal static SDLSurface* IMGLoadXVRWNative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, SDLSurface*>)vt[44])(src);
			#else
			return (SDLSurface*)((delegate* unmanaged[Cdecl]<nint, nint>)vt[44])((nint)src);
			#endif
		}

		/// <summary>
		/// Load a XV image directly.<br/>
		/// If you know you definitely have a XV image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_RWops<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadXV_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface*")]
		public static SDLSurface* IMGLoadXVRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src)
		{
			SDLSurface* ret = IMGLoadXVRWNative(src);
			return ret;
		}

		/// <summary>
		/// Load a XV image directly.<br/>
		/// If you know you definitely have a XV image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_RWops<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadXV_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface*")]
		public static SDLSurface* IMGLoadXVRW([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] ref SDLRWops src)
		{
			fixed (SDLRWops* psrc = &src)
			{
				SDLSurface* ret = IMGLoadXVRWNative((SDLRWops*)psrc);
				return ret;
			}
		}

		/// <summary>
		/// Load a WEBP image directly.<br/>
		/// If you know you definitely have a WEBP image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_RWops<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadWEBP_RW")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface*")]
		internal static SDLSurface* IMGLoadWEBPRWNative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_RWops*")] SDLRWops* src)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRWops*, SDLSurface*>)vt[45])(src);
			#else
			return (SDLSurface*)((delegate* unmanaged[Cdecl]<nint, nint>)vt[45])((nint)src);
			#endif
		}
	}
}
