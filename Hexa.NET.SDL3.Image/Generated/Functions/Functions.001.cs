// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;
using Hexa.NET.SDL3;

namespace Hexa.NET.SDL3.Image
{
	public unsafe partial class SDLImage
	{

		/// <summary>
		/// Load an SVG image, scaled to a specific size.<br/>
		/// Since SVG files are resolution-independent, you specify the size you would<br/>
		/// like the output image to be and it will be generated at those dimensions.<br/>
		/// Either width or height may be 0 and the image will be auto-sized to<br/>
		/// preserve aspect ratio.<br/>
		/// When done with the returned surface, the app should dispose of it with a<br/>
		/// call to SDL_DestroySurface().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadSizedSVG_IO")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurface* LoadSizedSVGIO([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream src, [NativeName(NativeNameType.Param, "width")] [NativeName(NativeNameType.Type, "int")] int width, [NativeName(NativeNameType.Param, "height")] [NativeName(NativeNameType.Type, "int")] int height)
		{
			fixed (SDLIOStream* psrc = &src)
			{
				SDLSurface* ret = LoadSizedSVGIONative((SDLIOStream*)psrc, width, height);
				return ret;
			}
		}

		/// <summary>
		/// Load an XPM image from a memory array.<br/>
		/// The returned surface will be an 8bpp indexed surface, if possible,<br/>
		/// otherwise it will be 32bpp. If you always want 32-bit data, use<br/>
		/// IMG_ReadXPMFromArrayToRGB888() instead.<br/>
		/// When done with the returned surface, the app should dispose of it with a<br/>
		/// call to SDL_DestroySurface().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_ReadXPMFromArray")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLSurface* ReadXPMFromArrayNative([NativeName(NativeNameType.Param, "xpm")] [NativeName(NativeNameType.Type, "char * *")] byte** xpm)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte**, SDLSurface*>)funcTable[45])(xpm);
			#else
			return (SDLSurface*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[45])((nint)xpm);
			#endif
		}

		/// <summary>
		/// Load an XPM image from a memory array.<br/>
		/// The returned surface will be an 8bpp indexed surface, if possible,<br/>
		/// otherwise it will be 32bpp. If you always want 32-bit data, use<br/>
		/// IMG_ReadXPMFromArrayToRGB888() instead.<br/>
		/// When done with the returned surface, the app should dispose of it with a<br/>
		/// call to SDL_DestroySurface().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_ReadXPMFromArray")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurface* ReadXPMFromArray([NativeName(NativeNameType.Param, "xpm")] [NativeName(NativeNameType.Type, "char * *")] byte** xpm)
		{
			SDLSurface* ret = ReadXPMFromArrayNative(xpm);
			return ret;
		}

		/// <summary>
		/// Load an XPM image from a memory array.<br/>
		/// The returned surface will be an 8bpp indexed surface, if possible,<br/>
		/// otherwise it will be 32bpp. If you always want 32-bit data, use<br/>
		/// IMG_ReadXPMFromArrayToRGB888() instead.<br/>
		/// When done with the returned surface, the app should dispose of it with a<br/>
		/// call to SDL_DestroySurface().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_ReadXPMFromArray")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurface* ReadXPMFromArray([NativeName(NativeNameType.Param, "xpm")] [NativeName(NativeNameType.Type, "char * *")] ref byte* xpm)
		{
			fixed (byte** pxpm = &xpm)
			{
				SDLSurface* ret = ReadXPMFromArrayNative((byte**)pxpm);
				return ret;
			}
		}

		/// <summary>
		/// Load an XPM image from a memory array.<br/>
		/// The returned surface will always be a 32-bit RGB surface. If you want 8-bit<br/>
		/// indexed colors (and the XPM data allows it), use IMG_ReadXPMFromArray()<br/>
		/// instead.<br/>
		/// When done with the returned surface, the app should dispose of it with a<br/>
		/// call to SDL_DestroySurface().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_ReadXPMFromArrayToRGB888")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLSurface* ReadXPMFromArrayToRGB888Native([NativeName(NativeNameType.Param, "xpm")] [NativeName(NativeNameType.Type, "char * *")] byte** xpm)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte**, SDLSurface*>)funcTable[46])(xpm);
			#else
			return (SDLSurface*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[46])((nint)xpm);
			#endif
		}

		/// <summary>
		/// Load an XPM image from a memory array.<br/>
		/// The returned surface will always be a 32-bit RGB surface. If you want 8-bit<br/>
		/// indexed colors (and the XPM data allows it), use IMG_ReadXPMFromArray()<br/>
		/// instead.<br/>
		/// When done with the returned surface, the app should dispose of it with a<br/>
		/// call to SDL_DestroySurface().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_ReadXPMFromArrayToRGB888")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurface* ReadXPMFromArrayToRGB888([NativeName(NativeNameType.Param, "xpm")] [NativeName(NativeNameType.Type, "char * *")] byte** xpm)
		{
			SDLSurface* ret = ReadXPMFromArrayToRGB888Native(xpm);
			return ret;
		}

		/// <summary>
		/// Load an XPM image from a memory array.<br/>
		/// The returned surface will always be a 32-bit RGB surface. If you want 8-bit<br/>
		/// indexed colors (and the XPM data allows it), use IMG_ReadXPMFromArray()<br/>
		/// instead.<br/>
		/// When done with the returned surface, the app should dispose of it with a<br/>
		/// call to SDL_DestroySurface().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_ReadXPMFromArrayToRGB888")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurface* ReadXPMFromArrayToRGB888([NativeName(NativeNameType.Param, "xpm")] [NativeName(NativeNameType.Type, "char * *")] ref byte* xpm)
		{
			fixed (byte** pxpm = &xpm)
			{
				SDLSurface* ret = ReadXPMFromArrayToRGB888Native((byte**)pxpm);
				return ret;
			}
		}

		/// <summary>
		/// Save an SDL_Surface into a AVIF image file.<br/>
		/// If the file already exists, it will be overwritten.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_SaveAVIF")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SaveAVIFNative([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] byte* file, [NativeName(NativeNameType.Param, "quality")] [NativeName(NativeNameType.Type, "int")] int quality)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSurface*, byte*, int, byte>)funcTable[47])(surface, file, quality);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, int, byte>)funcTable[47])((nint)surface, (nint)file, quality);
			#endif
		}

		/// <summary>
		/// Save an SDL_Surface into a AVIF image file.<br/>
		/// If the file already exists, it will be overwritten.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_SaveAVIF")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SaveAVIF([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] byte* file, [NativeName(NativeNameType.Param, "quality")] [NativeName(NativeNameType.Type, "int")] int quality)
		{
			byte ret = SaveAVIFNative(surface, file, quality);
			return ret != 0;
		}

		/// <summary>
		/// Save an SDL_Surface into a AVIF image file.<br/>
		/// If the file already exists, it will be overwritten.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_SaveAVIF")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SaveAVIF([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] byte* file, [NativeName(NativeNameType.Param, "quality")] [NativeName(NativeNameType.Type, "int")] int quality)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				byte ret = SaveAVIFNative((SDLSurface*)psurface, file, quality);
				return ret != 0;
			}
		}

		/// <summary>
		/// Save an SDL_Surface into a AVIF image file.<br/>
		/// If the file already exists, it will be overwritten.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_SaveAVIF")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SaveAVIF([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] ref byte file, [NativeName(NativeNameType.Param, "quality")] [NativeName(NativeNameType.Type, "int")] int quality)
		{
			fixed (byte* pfile = &file)
			{
				byte ret = SaveAVIFNative(surface, (byte*)pfile, quality);
				return ret != 0;
			}
		}

		/// <summary>
		/// Save an SDL_Surface into a AVIF image file.<br/>
		/// If the file already exists, it will be overwritten.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_SaveAVIF")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SaveAVIF([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> file, [NativeName(NativeNameType.Param, "quality")] [NativeName(NativeNameType.Type, "int")] int quality)
		{
			fixed (byte* pfile = file)
			{
				byte ret = SaveAVIFNative(surface, (byte*)pfile, quality);
				return ret != 0;
			}
		}

		/// <summary>
		/// Save an SDL_Surface into a AVIF image file.<br/>
		/// If the file already exists, it will be overwritten.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_SaveAVIF")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SaveAVIF([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] string file, [NativeName(NativeNameType.Param, "quality")] [NativeName(NativeNameType.Type, "int")] int quality)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (file != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(file);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(file, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = SaveAVIFNative(surface, pStr0, quality);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// Save an SDL_Surface into a AVIF image file.<br/>
		/// If the file already exists, it will be overwritten.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_SaveAVIF")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SaveAVIF([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] ref byte file, [NativeName(NativeNameType.Param, "quality")] [NativeName(NativeNameType.Type, "int")] int quality)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				fixed (byte* pfile = &file)
				{
					byte ret = SaveAVIFNative((SDLSurface*)psurface, (byte*)pfile, quality);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Save an SDL_Surface into a AVIF image file.<br/>
		/// If the file already exists, it will be overwritten.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_SaveAVIF")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SaveAVIF([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> file, [NativeName(NativeNameType.Param, "quality")] [NativeName(NativeNameType.Type, "int")] int quality)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				fixed (byte* pfile = file)
				{
					byte ret = SaveAVIFNative((SDLSurface*)psurface, (byte*)pfile, quality);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Save an SDL_Surface into a AVIF image file.<br/>
		/// If the file already exists, it will be overwritten.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_SaveAVIF")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SaveAVIF([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] string file, [NativeName(NativeNameType.Param, "quality")] [NativeName(NativeNameType.Type, "int")] int quality)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (file != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(file);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(file, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = SaveAVIFNative((SDLSurface*)psurface, pStr0, quality);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		/// <summary>
		/// Save an SDL_Surface into AVIF image data, via an SDL_IOStream.<br/>
		/// If you just want to save to a filename, you can use IMG_SaveAVIF() instead.<br/>
		/// If `closeio` is true, `dst` will be closed before returning, whether this<br/>
		/// function succeeds or not.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_SaveAVIF_IO")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SaveAVIFIONative([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* dst, [NativeName(NativeNameType.Param, "closeio")] [NativeName(NativeNameType.Type, "bool")] byte closeio, [NativeName(NativeNameType.Param, "quality")] [NativeName(NativeNameType.Type, "int")] int quality)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSurface*, SDLIOStream*, byte, int, byte>)funcTable[48])(surface, dst, closeio, quality);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, byte, int, byte>)funcTable[48])((nint)surface, (nint)dst, closeio, quality);
			#endif
		}

		/// <summary>
		/// Save an SDL_Surface into AVIF image data, via an SDL_IOStream.<br/>
		/// If you just want to save to a filename, you can use IMG_SaveAVIF() instead.<br/>
		/// If `closeio` is true, `dst` will be closed before returning, whether this<br/>
		/// function succeeds or not.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_SaveAVIF_IO")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SaveAVIFIO([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* dst, [NativeName(NativeNameType.Param, "closeio")] [NativeName(NativeNameType.Type, "bool")] bool closeio, [NativeName(NativeNameType.Param, "quality")] [NativeName(NativeNameType.Type, "int")] int quality)
		{
			byte ret = SaveAVIFIONative(surface, dst, closeio ? (byte)1 : (byte)0, quality);
			return ret != 0;
		}

		/// <summary>
		/// Save an SDL_Surface into AVIF image data, via an SDL_IOStream.<br/>
		/// If you just want to save to a filename, you can use IMG_SaveAVIF() instead.<br/>
		/// If `closeio` is true, `dst` will be closed before returning, whether this<br/>
		/// function succeeds or not.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_SaveAVIF_IO")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SaveAVIFIO([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* dst, [NativeName(NativeNameType.Param, "closeio")] [NativeName(NativeNameType.Type, "bool")] bool closeio, [NativeName(NativeNameType.Param, "quality")] [NativeName(NativeNameType.Type, "int")] int quality)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				byte ret = SaveAVIFIONative((SDLSurface*)psurface, dst, closeio ? (byte)1 : (byte)0, quality);
				return ret != 0;
			}
		}

		/// <summary>
		/// Save an SDL_Surface into AVIF image data, via an SDL_IOStream.<br/>
		/// If you just want to save to a filename, you can use IMG_SaveAVIF() instead.<br/>
		/// If `closeio` is true, `dst` will be closed before returning, whether this<br/>
		/// function succeeds or not.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_SaveAVIF_IO")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SaveAVIFIO([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream dst, [NativeName(NativeNameType.Param, "closeio")] [NativeName(NativeNameType.Type, "bool")] bool closeio, [NativeName(NativeNameType.Param, "quality")] [NativeName(NativeNameType.Type, "int")] int quality)
		{
			fixed (SDLIOStream* pdst = &dst)
			{
				byte ret = SaveAVIFIONative(surface, (SDLIOStream*)pdst, closeio ? (byte)1 : (byte)0, quality);
				return ret != 0;
			}
		}

		/// <summary>
		/// Save an SDL_Surface into AVIF image data, via an SDL_IOStream.<br/>
		/// If you just want to save to a filename, you can use IMG_SaveAVIF() instead.<br/>
		/// If `closeio` is true, `dst` will be closed before returning, whether this<br/>
		/// function succeeds or not.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_SaveAVIF_IO")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SaveAVIFIO([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream dst, [NativeName(NativeNameType.Param, "closeio")] [NativeName(NativeNameType.Type, "bool")] bool closeio, [NativeName(NativeNameType.Param, "quality")] [NativeName(NativeNameType.Type, "int")] int quality)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				fixed (SDLIOStream* pdst = &dst)
				{
					byte ret = SaveAVIFIONative((SDLSurface*)psurface, (SDLIOStream*)pdst, closeio ? (byte)1 : (byte)0, quality);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Save an SDL_Surface into a PNG image file.<br/>
		/// If the file already exists, it will be overwritten.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_SavePNG")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SavePNGNative([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] byte* file)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSurface*, byte*, byte>)funcTable[49])(surface, file);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, byte>)funcTable[49])((nint)surface, (nint)file);
			#endif
		}

		/// <summary>
		/// Save an SDL_Surface into a PNG image file.<br/>
		/// If the file already exists, it will be overwritten.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_SavePNG")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SavePNG([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] byte* file)
		{
			byte ret = SavePNGNative(surface, file);
			return ret != 0;
		}

		/// <summary>
		/// Save an SDL_Surface into a PNG image file.<br/>
		/// If the file already exists, it will be overwritten.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_SavePNG")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SavePNG([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] byte* file)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				byte ret = SavePNGNative((SDLSurface*)psurface, file);
				return ret != 0;
			}
		}

		/// <summary>
		/// Save an SDL_Surface into a PNG image file.<br/>
		/// If the file already exists, it will be overwritten.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_SavePNG")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SavePNG([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] ref byte file)
		{
			fixed (byte* pfile = &file)
			{
				byte ret = SavePNGNative(surface, (byte*)pfile);
				return ret != 0;
			}
		}

		/// <summary>
		/// Save an SDL_Surface into a PNG image file.<br/>
		/// If the file already exists, it will be overwritten.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_SavePNG")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SavePNG([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> file)
		{
			fixed (byte* pfile = file)
			{
				byte ret = SavePNGNative(surface, (byte*)pfile);
				return ret != 0;
			}
		}

		/// <summary>
		/// Save an SDL_Surface into a PNG image file.<br/>
		/// If the file already exists, it will be overwritten.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_SavePNG")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SavePNG([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] string file)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (file != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(file);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(file, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = SavePNGNative(surface, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// Save an SDL_Surface into a PNG image file.<br/>
		/// If the file already exists, it will be overwritten.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_SavePNG")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SavePNG([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] ref byte file)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				fixed (byte* pfile = &file)
				{
					byte ret = SavePNGNative((SDLSurface*)psurface, (byte*)pfile);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Save an SDL_Surface into a PNG image file.<br/>
		/// If the file already exists, it will be overwritten.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_SavePNG")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SavePNG([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> file)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				fixed (byte* pfile = file)
				{
					byte ret = SavePNGNative((SDLSurface*)psurface, (byte*)pfile);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Save an SDL_Surface into a PNG image file.<br/>
		/// If the file already exists, it will be overwritten.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_SavePNG")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SavePNG([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] string file)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (file != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(file);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(file, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = SavePNGNative((SDLSurface*)psurface, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		/// <summary>
		/// Save an SDL_Surface into PNG image data, via an SDL_IOStream.<br/>
		/// If you just want to save to a filename, you can use IMG_SavePNG() instead.<br/>
		/// If `closeio` is true, `dst` will be closed before returning, whether this<br/>
		/// function succeeds or not.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_SavePNG_IO")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SavePNGIONative([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* dst, [NativeName(NativeNameType.Param, "closeio")] [NativeName(NativeNameType.Type, "bool")] byte closeio)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSurface*, SDLIOStream*, byte, byte>)funcTable[50])(surface, dst, closeio);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, byte, byte>)funcTable[50])((nint)surface, (nint)dst, closeio);
			#endif
		}

		/// <summary>
		/// Save an SDL_Surface into PNG image data, via an SDL_IOStream.<br/>
		/// If you just want to save to a filename, you can use IMG_SavePNG() instead.<br/>
		/// If `closeio` is true, `dst` will be closed before returning, whether this<br/>
		/// function succeeds or not.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_SavePNG_IO")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SavePNGIO([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* dst, [NativeName(NativeNameType.Param, "closeio")] [NativeName(NativeNameType.Type, "bool")] bool closeio)
		{
			byte ret = SavePNGIONative(surface, dst, closeio ? (byte)1 : (byte)0);
			return ret != 0;
		}

		/// <summary>
		/// Save an SDL_Surface into PNG image data, via an SDL_IOStream.<br/>
		/// If you just want to save to a filename, you can use IMG_SavePNG() instead.<br/>
		/// If `closeio` is true, `dst` will be closed before returning, whether this<br/>
		/// function succeeds or not.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_SavePNG_IO")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SavePNGIO([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* dst, [NativeName(NativeNameType.Param, "closeio")] [NativeName(NativeNameType.Type, "bool")] bool closeio)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				byte ret = SavePNGIONative((SDLSurface*)psurface, dst, closeio ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}

		/// <summary>
		/// Save an SDL_Surface into PNG image data, via an SDL_IOStream.<br/>
		/// If you just want to save to a filename, you can use IMG_SavePNG() instead.<br/>
		/// If `closeio` is true, `dst` will be closed before returning, whether this<br/>
		/// function succeeds or not.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_SavePNG_IO")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SavePNGIO([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream dst, [NativeName(NativeNameType.Param, "closeio")] [NativeName(NativeNameType.Type, "bool")] bool closeio)
		{
			fixed (SDLIOStream* pdst = &dst)
			{
				byte ret = SavePNGIONative(surface, (SDLIOStream*)pdst, closeio ? (byte)1 : (byte)0);
				return ret != 0;
			}
		}

		/// <summary>
		/// Save an SDL_Surface into PNG image data, via an SDL_IOStream.<br/>
		/// If you just want to save to a filename, you can use IMG_SavePNG() instead.<br/>
		/// If `closeio` is true, `dst` will be closed before returning, whether this<br/>
		/// function succeeds or not.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_SavePNG_IO")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SavePNGIO([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream dst, [NativeName(NativeNameType.Param, "closeio")] [NativeName(NativeNameType.Type, "bool")] bool closeio)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				fixed (SDLIOStream* pdst = &dst)
				{
					byte ret = SavePNGIONative((SDLSurface*)psurface, (SDLIOStream*)pdst, closeio ? (byte)1 : (byte)0);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Save an SDL_Surface into a JPEG image file.<br/>
		/// If the file already exists, it will be overwritten.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_SaveJPG")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SaveJPGNative([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] byte* file, [NativeName(NativeNameType.Param, "quality")] [NativeName(NativeNameType.Type, "int")] int quality)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSurface*, byte*, int, byte>)funcTable[51])(surface, file, quality);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, int, byte>)funcTable[51])((nint)surface, (nint)file, quality);
			#endif
		}

		/// <summary>
		/// Save an SDL_Surface into a JPEG image file.<br/>
		/// If the file already exists, it will be overwritten.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_SaveJPG")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SaveJPG([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] byte* file, [NativeName(NativeNameType.Param, "quality")] [NativeName(NativeNameType.Type, "int")] int quality)
		{
			byte ret = SaveJPGNative(surface, file, quality);
			return ret != 0;
		}

		/// <summary>
		/// Save an SDL_Surface into a JPEG image file.<br/>
		/// If the file already exists, it will be overwritten.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_SaveJPG")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SaveJPG([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] byte* file, [NativeName(NativeNameType.Param, "quality")] [NativeName(NativeNameType.Type, "int")] int quality)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				byte ret = SaveJPGNative((SDLSurface*)psurface, file, quality);
				return ret != 0;
			}
		}

		/// <summary>
		/// Save an SDL_Surface into a JPEG image file.<br/>
		/// If the file already exists, it will be overwritten.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_SaveJPG")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SaveJPG([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] ref byte file, [NativeName(NativeNameType.Param, "quality")] [NativeName(NativeNameType.Type, "int")] int quality)
		{
			fixed (byte* pfile = &file)
			{
				byte ret = SaveJPGNative(surface, (byte*)pfile, quality);
				return ret != 0;
			}
		}

		/// <summary>
		/// Save an SDL_Surface into a JPEG image file.<br/>
		/// If the file already exists, it will be overwritten.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_SaveJPG")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SaveJPG([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> file, [NativeName(NativeNameType.Param, "quality")] [NativeName(NativeNameType.Type, "int")] int quality)
		{
			fixed (byte* pfile = file)
			{
				byte ret = SaveJPGNative(surface, (byte*)pfile, quality);
				return ret != 0;
			}
		}

		/// <summary>
		/// Save an SDL_Surface into a JPEG image file.<br/>
		/// If the file already exists, it will be overwritten.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_SaveJPG")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SaveJPG([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] string file, [NativeName(NativeNameType.Param, "quality")] [NativeName(NativeNameType.Type, "int")] int quality)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (file != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(file);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(file, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = SaveJPGNative(surface, pStr0, quality);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// Save an SDL_Surface into a JPEG image file.<br/>
		/// If the file already exists, it will be overwritten.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_SaveJPG")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SaveJPG([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] ref byte file, [NativeName(NativeNameType.Param, "quality")] [NativeName(NativeNameType.Type, "int")] int quality)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				fixed (byte* pfile = &file)
				{
					byte ret = SaveJPGNative((SDLSurface*)psurface, (byte*)pfile, quality);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Save an SDL_Surface into a JPEG image file.<br/>
		/// If the file already exists, it will be overwritten.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_SaveJPG")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SaveJPG([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> file, [NativeName(NativeNameType.Param, "quality")] [NativeName(NativeNameType.Type, "int")] int quality)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				fixed (byte* pfile = file)
				{
					byte ret = SaveJPGNative((SDLSurface*)psurface, (byte*)pfile, quality);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Save an SDL_Surface into a JPEG image file.<br/>
		/// If the file already exists, it will be overwritten.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_SaveJPG")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SaveJPG([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] string file, [NativeName(NativeNameType.Param, "quality")] [NativeName(NativeNameType.Type, "int")] int quality)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (file != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(file);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(file, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte ret = SaveJPGNative((SDLSurface*)psurface, pStr0, quality);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret != 0;
			}
		}

		/// <summary>
		/// Save an SDL_Surface into JPEG image data, via an SDL_IOStream.<br/>
		/// If you just want to save to a filename, you can use IMG_SaveJPG() instead.<br/>
		/// If `closeio` is true, `dst` will be closed before returning, whether this<br/>
		/// function succeeds or not.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_SaveJPG_IO")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte SaveJPGIONative([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* dst, [NativeName(NativeNameType.Param, "closeio")] [NativeName(NativeNameType.Type, "bool")] byte closeio, [NativeName(NativeNameType.Param, "quality")] [NativeName(NativeNameType.Type, "int")] int quality)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLSurface*, SDLIOStream*, byte, int, byte>)funcTable[52])(surface, dst, closeio, quality);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nint, byte, int, byte>)funcTable[52])((nint)surface, (nint)dst, closeio, quality);
			#endif
		}

		/// <summary>
		/// Save an SDL_Surface into JPEG image data, via an SDL_IOStream.<br/>
		/// If you just want to save to a filename, you can use IMG_SaveJPG() instead.<br/>
		/// If `closeio` is true, `dst` will be closed before returning, whether this<br/>
		/// function succeeds or not.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_SaveJPG_IO")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SaveJPGIO([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* dst, [NativeName(NativeNameType.Param, "closeio")] [NativeName(NativeNameType.Type, "bool")] bool closeio, [NativeName(NativeNameType.Param, "quality")] [NativeName(NativeNameType.Type, "int")] int quality)
		{
			byte ret = SaveJPGIONative(surface, dst, closeio ? (byte)1 : (byte)0, quality);
			return ret != 0;
		}

		/// <summary>
		/// Save an SDL_Surface into JPEG image data, via an SDL_IOStream.<br/>
		/// If you just want to save to a filename, you can use IMG_SaveJPG() instead.<br/>
		/// If `closeio` is true, `dst` will be closed before returning, whether this<br/>
		/// function succeeds or not.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_SaveJPG_IO")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SaveJPGIO([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* dst, [NativeName(NativeNameType.Param, "closeio")] [NativeName(NativeNameType.Type, "bool")] bool closeio, [NativeName(NativeNameType.Param, "quality")] [NativeName(NativeNameType.Type, "int")] int quality)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				byte ret = SaveJPGIONative((SDLSurface*)psurface, dst, closeio ? (byte)1 : (byte)0, quality);
				return ret != 0;
			}
		}

		/// <summary>
		/// Save an SDL_Surface into JPEG image data, via an SDL_IOStream.<br/>
		/// If you just want to save to a filename, you can use IMG_SaveJPG() instead.<br/>
		/// If `closeio` is true, `dst` will be closed before returning, whether this<br/>
		/// function succeeds or not.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_SaveJPG_IO")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SaveJPGIO([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] SDLSurface* surface, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream dst, [NativeName(NativeNameType.Param, "closeio")] [NativeName(NativeNameType.Type, "bool")] bool closeio, [NativeName(NativeNameType.Param, "quality")] [NativeName(NativeNameType.Type, "int")] int quality)
		{
			fixed (SDLIOStream* pdst = &dst)
			{
				byte ret = SaveJPGIONative(surface, (SDLIOStream*)pdst, closeio ? (byte)1 : (byte)0, quality);
				return ret != 0;
			}
		}

		/// <summary>
		/// Save an SDL_Surface into JPEG image data, via an SDL_IOStream.<br/>
		/// If you just want to save to a filename, you can use IMG_SaveJPG() instead.<br/>
		/// If `closeio` is true, `dst` will be closed before returning, whether this<br/>
		/// function succeeds or not.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_SaveJPG_IO")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool SaveJPGIO([NativeName(NativeNameType.Param, "surface")] [NativeName(NativeNameType.Type, "SDL_Surface *")] ref SDLSurface surface, [NativeName(NativeNameType.Param, "dst")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream dst, [NativeName(NativeNameType.Param, "closeio")] [NativeName(NativeNameType.Type, "bool")] bool closeio, [NativeName(NativeNameType.Param, "quality")] [NativeName(NativeNameType.Type, "int")] int quality)
		{
			fixed (SDLSurface* psurface = &surface)
			{
				fixed (SDLIOStream* pdst = &dst)
				{
					byte ret = SaveJPGIONative((SDLSurface*)psurface, (SDLIOStream*)pdst, closeio ? (byte)1 : (byte)0, quality);
					return ret != 0;
				}
			}
		}

		/// <summary>
		/// Load an animation from a file.<br/>
		/// When done with the returned animation, the app should dispose of it with a<br/>
		/// call to IMG_FreeAnimation().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadAnimation")]
		[return: NativeName(NativeNameType.Type, "IMG_Animation *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static IMGAnimation* LoadAnimationNative([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] byte* file)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, IMGAnimation*>)funcTable[53])(file);
			#else
			return (IMGAnimation*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[53])((nint)file);
			#endif
		}

		/// <summary>
		/// Load an animation from a file.<br/>
		/// When done with the returned animation, the app should dispose of it with a<br/>
		/// call to IMG_FreeAnimation().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadAnimation")]
		[return: NativeName(NativeNameType.Type, "IMG_Animation *")]
		public static IMGAnimation* LoadAnimation([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] byte* file)
		{
			IMGAnimation* ret = LoadAnimationNative(file);
			return ret;
		}

		/// <summary>
		/// Load an animation from a file.<br/>
		/// When done with the returned animation, the app should dispose of it with a<br/>
		/// call to IMG_FreeAnimation().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadAnimation")]
		[return: NativeName(NativeNameType.Type, "IMG_Animation *")]
		public static IMGAnimation* LoadAnimation([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] ref byte file)
		{
			fixed (byte* pfile = &file)
			{
				IMGAnimation* ret = LoadAnimationNative((byte*)pfile);
				return ret;
			}
		}

		/// <summary>
		/// Load an animation from a file.<br/>
		/// When done with the returned animation, the app should dispose of it with a<br/>
		/// call to IMG_FreeAnimation().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadAnimation")]
		[return: NativeName(NativeNameType.Type, "IMG_Animation *")]
		public static IMGAnimation* LoadAnimation([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> file)
		{
			fixed (byte* pfile = file)
			{
				IMGAnimation* ret = LoadAnimationNative((byte*)pfile);
				return ret;
			}
		}

		/// <summary>
		/// Load an animation from a file.<br/>
		/// When done with the returned animation, the app should dispose of it with a<br/>
		/// call to IMG_FreeAnimation().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadAnimation")]
		[return: NativeName(NativeNameType.Type, "IMG_Animation *")]
		public static IMGAnimation* LoadAnimation([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] string file)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (file != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(file);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(file, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			IMGAnimation* ret = LoadAnimationNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Load an animation from an SDL_IOStream.<br/>
		/// If `closeio` is true, `src` will be closed before returning, whether this<br/>
		/// function succeeds or not. SDL_image reads everything it needs from `src`<br/>
		/// during this call in any case.<br/>
		/// When done with the returned animation, the app should dispose of it with a<br/>
		/// call to IMG_FreeAnimation().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadAnimation_IO")]
		[return: NativeName(NativeNameType.Type, "IMG_Animation *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static IMGAnimation* LoadAnimationIONative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src, [NativeName(NativeNameType.Param, "closeio")] [NativeName(NativeNameType.Type, "bool")] byte closeio)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLIOStream*, byte, IMGAnimation*>)funcTable[54])(src, closeio);
			#else
			return (IMGAnimation*)((delegate* unmanaged[Cdecl]<nint, byte, nint>)funcTable[54])((nint)src, closeio);
			#endif
		}

		/// <summary>
		/// Load an animation from an SDL_IOStream.<br/>
		/// If `closeio` is true, `src` will be closed before returning, whether this<br/>
		/// function succeeds or not. SDL_image reads everything it needs from `src`<br/>
		/// during this call in any case.<br/>
		/// When done with the returned animation, the app should dispose of it with a<br/>
		/// call to IMG_FreeAnimation().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadAnimation_IO")]
		[return: NativeName(NativeNameType.Type, "IMG_Animation *")]
		public static IMGAnimation* LoadAnimationIO([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src, [NativeName(NativeNameType.Param, "closeio")] [NativeName(NativeNameType.Type, "bool")] bool closeio)
		{
			IMGAnimation* ret = LoadAnimationIONative(src, closeio ? (byte)1 : (byte)0);
			return ret;
		}

		/// <summary>
		/// Load an animation from an SDL_IOStream.<br/>
		/// If `closeio` is true, `src` will be closed before returning, whether this<br/>
		/// function succeeds or not. SDL_image reads everything it needs from `src`<br/>
		/// during this call in any case.<br/>
		/// When done with the returned animation, the app should dispose of it with a<br/>
		/// call to IMG_FreeAnimation().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadAnimation_IO")]
		[return: NativeName(NativeNameType.Type, "IMG_Animation *")]
		public static IMGAnimation* LoadAnimationIO([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream src, [NativeName(NativeNameType.Param, "closeio")] [NativeName(NativeNameType.Type, "bool")] bool closeio)
		{
			fixed (SDLIOStream* psrc = &src)
			{
				IMGAnimation* ret = LoadAnimationIONative((SDLIOStream*)psrc, closeio ? (byte)1 : (byte)0);
				return ret;
			}
		}

		/// <summary>
		/// Load an animation from an SDL datasource<br/>
		/// Even though this function accepts a file type, SDL_image may still try<br/>
		/// other decoders that are capable of detecting file type from the contents of<br/>
		/// the image data, but may rely on the caller-provided type string for formats<br/>
		/// that it cannot autodetect. If `type` is NULL, SDL_image will rely solely on<br/>
		/// its ability to guess the format.<br/>
		/// If `closeio` is true, `src` will be closed before returning, whether this<br/>
		/// function succeeds or not. SDL_image reads everything it needs from `src`<br/>
		/// during this call in any case.<br/>
		/// When done with the returned animation, the app should dispose of it with a<br/>
		/// call to IMG_FreeAnimation().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadAnimationTyped_IO")]
		[return: NativeName(NativeNameType.Type, "IMG_Animation *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static IMGAnimation* LoadAnimationTypedIONative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src, [NativeName(NativeNameType.Param, "closeio")] [NativeName(NativeNameType.Type, "bool")] byte closeio, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "char const *")] byte* type)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLIOStream*, byte, byte*, IMGAnimation*>)funcTable[55])(src, closeio, type);
			#else
			return (IMGAnimation*)((delegate* unmanaged[Cdecl]<nint, byte, nint, nint>)funcTable[55])((nint)src, closeio, (nint)type);
			#endif
		}

		/// <summary>
		/// Load an animation from an SDL datasource<br/>
		/// Even though this function accepts a file type, SDL_image may still try<br/>
		/// other decoders that are capable of detecting file type from the contents of<br/>
		/// the image data, but may rely on the caller-provided type string for formats<br/>
		/// that it cannot autodetect. If `type` is NULL, SDL_image will rely solely on<br/>
		/// its ability to guess the format.<br/>
		/// If `closeio` is true, `src` will be closed before returning, whether this<br/>
		/// function succeeds or not. SDL_image reads everything it needs from `src`<br/>
		/// during this call in any case.<br/>
		/// When done with the returned animation, the app should dispose of it with a<br/>
		/// call to IMG_FreeAnimation().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadAnimationTyped_IO")]
		[return: NativeName(NativeNameType.Type, "IMG_Animation *")]
		public static IMGAnimation* LoadAnimationTypedIO([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src, [NativeName(NativeNameType.Param, "closeio")] [NativeName(NativeNameType.Type, "bool")] bool closeio, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "char const *")] byte* type)
		{
			IMGAnimation* ret = LoadAnimationTypedIONative(src, closeio ? (byte)1 : (byte)0, type);
			return ret;
		}

		/// <summary>
		/// Load an animation from an SDL datasource<br/>
		/// Even though this function accepts a file type, SDL_image may still try<br/>
		/// other decoders that are capable of detecting file type from the contents of<br/>
		/// the image data, but may rely on the caller-provided type string for formats<br/>
		/// that it cannot autodetect. If `type` is NULL, SDL_image will rely solely on<br/>
		/// its ability to guess the format.<br/>
		/// If `closeio` is true, `src` will be closed before returning, whether this<br/>
		/// function succeeds or not. SDL_image reads everything it needs from `src`<br/>
		/// during this call in any case.<br/>
		/// When done with the returned animation, the app should dispose of it with a<br/>
		/// call to IMG_FreeAnimation().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadAnimationTyped_IO")]
		[return: NativeName(NativeNameType.Type, "IMG_Animation *")]
		public static IMGAnimation* LoadAnimationTypedIO([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream src, [NativeName(NativeNameType.Param, "closeio")] [NativeName(NativeNameType.Type, "bool")] bool closeio, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "char const *")] byte* type)
		{
			fixed (SDLIOStream* psrc = &src)
			{
				IMGAnimation* ret = LoadAnimationTypedIONative((SDLIOStream*)psrc, closeio ? (byte)1 : (byte)0, type);
				return ret;
			}
		}

		/// <summary>
		/// Load an animation from an SDL datasource<br/>
		/// Even though this function accepts a file type, SDL_image may still try<br/>
		/// other decoders that are capable of detecting file type from the contents of<br/>
		/// the image data, but may rely on the caller-provided type string for formats<br/>
		/// that it cannot autodetect. If `type` is NULL, SDL_image will rely solely on<br/>
		/// its ability to guess the format.<br/>
		/// If `closeio` is true, `src` will be closed before returning, whether this<br/>
		/// function succeeds or not. SDL_image reads everything it needs from `src`<br/>
		/// during this call in any case.<br/>
		/// When done with the returned animation, the app should dispose of it with a<br/>
		/// call to IMG_FreeAnimation().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadAnimationTyped_IO")]
		[return: NativeName(NativeNameType.Type, "IMG_Animation *")]
		public static IMGAnimation* LoadAnimationTypedIO([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src, [NativeName(NativeNameType.Param, "closeio")] [NativeName(NativeNameType.Type, "bool")] bool closeio, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "char const *")] ref byte type)
		{
			fixed (byte* ptype = &type)
			{
				IMGAnimation* ret = LoadAnimationTypedIONative(src, closeio ? (byte)1 : (byte)0, (byte*)ptype);
				return ret;
			}
		}

		/// <summary>
		/// Load an animation from an SDL datasource<br/>
		/// Even though this function accepts a file type, SDL_image may still try<br/>
		/// other decoders that are capable of detecting file type from the contents of<br/>
		/// the image data, but may rely on the caller-provided type string for formats<br/>
		/// that it cannot autodetect. If `type` is NULL, SDL_image will rely solely on<br/>
		/// its ability to guess the format.<br/>
		/// If `closeio` is true, `src` will be closed before returning, whether this<br/>
		/// function succeeds or not. SDL_image reads everything it needs from `src`<br/>
		/// during this call in any case.<br/>
		/// When done with the returned animation, the app should dispose of it with a<br/>
		/// call to IMG_FreeAnimation().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadAnimationTyped_IO")]
		[return: NativeName(NativeNameType.Type, "IMG_Animation *")]
		public static IMGAnimation* LoadAnimationTypedIO([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src, [NativeName(NativeNameType.Param, "closeio")] [NativeName(NativeNameType.Type, "bool")] bool closeio, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> type)
		{
			fixed (byte* ptype = type)
			{
				IMGAnimation* ret = LoadAnimationTypedIONative(src, closeio ? (byte)1 : (byte)0, (byte*)ptype);
				return ret;
			}
		}

		/// <summary>
		/// Load an animation from an SDL datasource<br/>
		/// Even though this function accepts a file type, SDL_image may still try<br/>
		/// other decoders that are capable of detecting file type from the contents of<br/>
		/// the image data, but may rely on the caller-provided type string for formats<br/>
		/// that it cannot autodetect. If `type` is NULL, SDL_image will rely solely on<br/>
		/// its ability to guess the format.<br/>
		/// If `closeio` is true, `src` will be closed before returning, whether this<br/>
		/// function succeeds or not. SDL_image reads everything it needs from `src`<br/>
		/// during this call in any case.<br/>
		/// When done with the returned animation, the app should dispose of it with a<br/>
		/// call to IMG_FreeAnimation().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadAnimationTyped_IO")]
		[return: NativeName(NativeNameType.Type, "IMG_Animation *")]
		public static IMGAnimation* LoadAnimationTypedIO([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src, [NativeName(NativeNameType.Param, "closeio")] [NativeName(NativeNameType.Type, "bool")] bool closeio, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "char const *")] string type)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (type != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(type);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(type, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			IMGAnimation* ret = LoadAnimationTypedIONative(src, closeio ? (byte)1 : (byte)0, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Load an animation from an SDL datasource<br/>
		/// Even though this function accepts a file type, SDL_image may still try<br/>
		/// other decoders that are capable of detecting file type from the contents of<br/>
		/// the image data, but may rely on the caller-provided type string for formats<br/>
		/// that it cannot autodetect. If `type` is NULL, SDL_image will rely solely on<br/>
		/// its ability to guess the format.<br/>
		/// If `closeio` is true, `src` will be closed before returning, whether this<br/>
		/// function succeeds or not. SDL_image reads everything it needs from `src`<br/>
		/// during this call in any case.<br/>
		/// When done with the returned animation, the app should dispose of it with a<br/>
		/// call to IMG_FreeAnimation().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadAnimationTyped_IO")]
		[return: NativeName(NativeNameType.Type, "IMG_Animation *")]
		public static IMGAnimation* LoadAnimationTypedIO([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream src, [NativeName(NativeNameType.Param, "closeio")] [NativeName(NativeNameType.Type, "bool")] bool closeio, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "char const *")] ref byte type)
		{
			fixed (SDLIOStream* psrc = &src)
			{
				fixed (byte* ptype = &type)
				{
					IMGAnimation* ret = LoadAnimationTypedIONative((SDLIOStream*)psrc, closeio ? (byte)1 : (byte)0, (byte*)ptype);
					return ret;
				}
			}
		}

		/// <summary>
		/// Load an animation from an SDL datasource<br/>
		/// Even though this function accepts a file type, SDL_image may still try<br/>
		/// other decoders that are capable of detecting file type from the contents of<br/>
		/// the image data, but may rely on the caller-provided type string for formats<br/>
		/// that it cannot autodetect. If `type` is NULL, SDL_image will rely solely on<br/>
		/// its ability to guess the format.<br/>
		/// If `closeio` is true, `src` will be closed before returning, whether this<br/>
		/// function succeeds or not. SDL_image reads everything it needs from `src`<br/>
		/// during this call in any case.<br/>
		/// When done with the returned animation, the app should dispose of it with a<br/>
		/// call to IMG_FreeAnimation().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadAnimationTyped_IO")]
		[return: NativeName(NativeNameType.Type, "IMG_Animation *")]
		public static IMGAnimation* LoadAnimationTypedIO([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream src, [NativeName(NativeNameType.Param, "closeio")] [NativeName(NativeNameType.Type, "bool")] bool closeio, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> type)
		{
			fixed (SDLIOStream* psrc = &src)
			{
				fixed (byte* ptype = type)
				{
					IMGAnimation* ret = LoadAnimationTypedIONative((SDLIOStream*)psrc, closeio ? (byte)1 : (byte)0, (byte*)ptype);
					return ret;
				}
			}
		}

		/// <summary>
		/// Load an animation from an SDL datasource<br/>
		/// Even though this function accepts a file type, SDL_image may still try<br/>
		/// other decoders that are capable of detecting file type from the contents of<br/>
		/// the image data, but may rely on the caller-provided type string for formats<br/>
		/// that it cannot autodetect. If `type` is NULL, SDL_image will rely solely on<br/>
		/// its ability to guess the format.<br/>
		/// If `closeio` is true, `src` will be closed before returning, whether this<br/>
		/// function succeeds or not. SDL_image reads everything it needs from `src`<br/>
		/// during this call in any case.<br/>
		/// When done with the returned animation, the app should dispose of it with a<br/>
		/// call to IMG_FreeAnimation().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadAnimationTyped_IO")]
		[return: NativeName(NativeNameType.Type, "IMG_Animation *")]
		public static IMGAnimation* LoadAnimationTypedIO([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream src, [NativeName(NativeNameType.Param, "closeio")] [NativeName(NativeNameType.Type, "bool")] bool closeio, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "char const *")] string type)
		{
			fixed (SDLIOStream* psrc = &src)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (type != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(type);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(type, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				IMGAnimation* ret = LoadAnimationTypedIONative((SDLIOStream*)psrc, closeio ? (byte)1 : (byte)0, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// Dispose of an IMG_Animation and free its resources.<br/>
		/// The provided `anim` pointer is not valid once this call returns.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_FreeAnimation")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FreeAnimationNative([NativeName(NativeNameType.Param, "anim")] [NativeName(NativeNameType.Type, "IMG_Animation *")] IMGAnimation* anim)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<IMGAnimation*, void>)funcTable[56])(anim);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[56])((nint)anim);
			#endif
		}

		/// <summary>
		/// Dispose of an IMG_Animation and free its resources.<br/>
		/// The provided `anim` pointer is not valid once this call returns.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_FreeAnimation")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void FreeAnimation([NativeName(NativeNameType.Param, "anim")] [NativeName(NativeNameType.Type, "IMG_Animation *")] IMGAnimation* anim)
		{
			FreeAnimationNative(anim);
		}

		/// <summary>
		/// Dispose of an IMG_Animation and free its resources.<br/>
		/// The provided `anim` pointer is not valid once this call returns.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_FreeAnimation")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void FreeAnimation([NativeName(NativeNameType.Param, "anim")] [NativeName(NativeNameType.Type, "IMG_Animation *")] ref IMGAnimation anim)
		{
			fixed (IMGAnimation* panim = &anim)
			{
				FreeAnimationNative((IMGAnimation*)panim);
			}
		}

		/// <summary>
		/// Load a GIF animation directly.<br/>
		/// If you know you definitely have a GIF image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_IOStream<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadGIFAnimation_IO")]
		[return: NativeName(NativeNameType.Type, "IMG_Animation *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static IMGAnimation* LoadGIFAnimationIONative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLIOStream*, IMGAnimation*>)funcTable[57])(src);
			#else
			return (IMGAnimation*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[57])((nint)src);
			#endif
		}

		/// <summary>
		/// Load a GIF animation directly.<br/>
		/// If you know you definitely have a GIF image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_IOStream<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadGIFAnimation_IO")]
		[return: NativeName(NativeNameType.Type, "IMG_Animation *")]
		public static IMGAnimation* LoadGIFAnimationIO([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src)
		{
			IMGAnimation* ret = LoadGIFAnimationIONative(src);
			return ret;
		}

		/// <summary>
		/// Load a GIF animation directly.<br/>
		/// If you know you definitely have a GIF image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_IOStream<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadGIFAnimation_IO")]
		[return: NativeName(NativeNameType.Type, "IMG_Animation *")]
		public static IMGAnimation* LoadGIFAnimationIO([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream src)
		{
			fixed (SDLIOStream* psrc = &src)
			{
				IMGAnimation* ret = LoadGIFAnimationIONative((SDLIOStream*)psrc);
				return ret;
			}
		}

		/// <summary>
		/// Load a WEBP animation directly.<br/>
		/// If you know you definitely have a WEBP image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_IOStream<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadWEBPAnimation_IO")]
		[return: NativeName(NativeNameType.Type, "IMG_Animation *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static IMGAnimation* LoadWEBPAnimationIONative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLIOStream*, IMGAnimation*>)funcTable[58])(src);
			#else
			return (IMGAnimation*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[58])((nint)src);
			#endif
		}

		/// <summary>
		/// Load a WEBP animation directly.<br/>
		/// If you know you definitely have a WEBP image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_IOStream<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadWEBPAnimation_IO")]
		[return: NativeName(NativeNameType.Type, "IMG_Animation *")]
		public static IMGAnimation* LoadWEBPAnimationIO([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src)
		{
			IMGAnimation* ret = LoadWEBPAnimationIONative(src);
			return ret;
		}

		/// <summary>
		/// Load a WEBP animation directly.<br/>
		/// If you know you definitely have a WEBP image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_IOStream<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadWEBPAnimation_IO")]
		[return: NativeName(NativeNameType.Type, "IMG_Animation *")]
		public static IMGAnimation* LoadWEBPAnimationIO([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream src)
		{
			fixed (SDLIOStream* psrc = &src)
			{
				IMGAnimation* ret = LoadWEBPAnimationIONative((SDLIOStream*)psrc);
				return ret;
			}
		}

	}
}
