// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;
using Hexa.NET.SDL3;

namespace Hexa.NET.SDL3.Image
{
	public unsafe partial class SDLImage
	{
		/// <summary>
		/// This function gets the version of the dynamically linked SDL_image library.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_Version")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int VersionNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int>)funcTable[0])();
			#else
			return (int)((delegate* unmanaged[Cdecl]<int>)funcTable[0])();
			#endif
		}

		/// <summary>
		/// This function gets the version of the dynamically linked SDL_image library.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_Version")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int Version()
		{
			int ret = VersionNative();
			return ret;
		}

		/// <summary>
		/// Load an image from an SDL data source into a software surface.<br/>
		/// An SDL_Surface is a buffer of pixels in memory accessible by the CPU. Use<br/>
		/// this if you plan to hand the data to something else or manipulate it<br/>
		/// further in code.<br/>
		/// There are no guarantees about what format the new SDL_Surface data will be;<br/>
		/// in many cases, SDL_image will attempt to supply a surface that exactly<br/>
		/// matches the provided image, but in others it might have to convert (either<br/>
		/// because the image is in a format that SDL doesn't directly support or<br/>
		/// because it's compressed data that could reasonably uncompress to various<br/>
		/// formats and SDL_image had to pick one). You can inspect an SDL_Surface for<br/>
		/// its specifics, and use SDL_ConvertSurface to then migrate to any supported<br/>
		/// format.<br/>
		/// If the image format supports a transparent pixel, SDL will set the colorkey<br/>
		/// for the surface. You can enable RLE acceleration on the surface afterwards<br/>
		/// by calling: SDL_SetSurfaceColorKey(image, SDL_RLEACCEL,<br/>
		/// image->format->colorkey);<br/>
		/// If `closeio` is true, `src` will be closed before returning, whether this<br/>
		/// function succeeds or not. SDL_image reads everything it needs from `src`<br/>
		/// during this call in any case.<br/>
		/// Even though this function accepts a file type, SDL_image may still try<br/>
		/// other decoders that are capable of detecting file type from the contents of<br/>
		/// the image data, but may rely on the caller-provided type string for formats<br/>
		/// that it cannot autodetect. If `type` is NULL, SDL_image will rely solely on<br/>
		/// its ability to guess the format.<br/>
		/// There is a separate function to read files from disk without having to deal<br/>
		/// with SDL_IOStream: `IMG_Load("filename.jpg")` will call this function and<br/>
		/// manage those details for you, determining the file type from the filename's<br/>
		/// extension.<br/>
		/// There is also IMG_Load_IO(), which is equivalent to this function except<br/>
		/// that it will rely on SDL_image to determine what type of data it is<br/>
		/// loading, much like passing a NULL for type.<br/>
		/// If you are using SDL's 2D rendering API, there is an equivalent call to<br/>
		/// load images directly into an SDL_Texture for use by the GPU without using a<br/>
		/// software surface: call IMG_LoadTextureTyped_IO() instead.<br/>
		/// When done with the returned surface, the app should dispose of it with a<br/>
		/// call to SDL_DestroySurface().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadTyped_IO")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLSurface* LoadTypedIONative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src, [NativeName(NativeNameType.Param, "closeio")] [NativeName(NativeNameType.Type, "bool")] byte closeio, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "char const *")] byte* type)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLIOStream*, byte, byte*, SDLSurface*>)funcTable[1])(src, closeio, type);
			#else
			return (SDLSurface*)((delegate* unmanaged[Cdecl]<nint, byte, nint, nint>)funcTable[1])((nint)src, closeio, (nint)type);
			#endif
		}

		/// <summary>
		/// Load an image from an SDL data source into a software surface.<br/>
		/// An SDL_Surface is a buffer of pixels in memory accessible by the CPU. Use<br/>
		/// this if you plan to hand the data to something else or manipulate it<br/>
		/// further in code.<br/>
		/// There are no guarantees about what format the new SDL_Surface data will be;<br/>
		/// in many cases, SDL_image will attempt to supply a surface that exactly<br/>
		/// matches the provided image, but in others it might have to convert (either<br/>
		/// because the image is in a format that SDL doesn't directly support or<br/>
		/// because it's compressed data that could reasonably uncompress to various<br/>
		/// formats and SDL_image had to pick one). You can inspect an SDL_Surface for<br/>
		/// its specifics, and use SDL_ConvertSurface to then migrate to any supported<br/>
		/// format.<br/>
		/// If the image format supports a transparent pixel, SDL will set the colorkey<br/>
		/// for the surface. You can enable RLE acceleration on the surface afterwards<br/>
		/// by calling: SDL_SetSurfaceColorKey(image, SDL_RLEACCEL,<br/>
		/// image->format->colorkey);<br/>
		/// If `closeio` is true, `src` will be closed before returning, whether this<br/>
		/// function succeeds or not. SDL_image reads everything it needs from `src`<br/>
		/// during this call in any case.<br/>
		/// Even though this function accepts a file type, SDL_image may still try<br/>
		/// other decoders that are capable of detecting file type from the contents of<br/>
		/// the image data, but may rely on the caller-provided type string for formats<br/>
		/// that it cannot autodetect. If `type` is NULL, SDL_image will rely solely on<br/>
		/// its ability to guess the format.<br/>
		/// There is a separate function to read files from disk without having to deal<br/>
		/// with SDL_IOStream: `IMG_Load("filename.jpg")` will call this function and<br/>
		/// manage those details for you, determining the file type from the filename's<br/>
		/// extension.<br/>
		/// There is also IMG_Load_IO(), which is equivalent to this function except<br/>
		/// that it will rely on SDL_image to determine what type of data it is<br/>
		/// loading, much like passing a NULL for type.<br/>
		/// If you are using SDL's 2D rendering API, there is an equivalent call to<br/>
		/// load images directly into an SDL_Texture for use by the GPU without using a<br/>
		/// software surface: call IMG_LoadTextureTyped_IO() instead.<br/>
		/// When done with the returned surface, the app should dispose of it with a<br/>
		/// call to SDL_DestroySurface().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadTyped_IO")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurface* LoadTypedIO([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src, [NativeName(NativeNameType.Param, "closeio")] [NativeName(NativeNameType.Type, "bool")] bool closeio, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "char const *")] byte* type)
		{
			SDLSurface* ret = LoadTypedIONative(src, closeio ? (byte)1 : (byte)0, type);
			return ret;
		}

		/// <summary>
		/// Load an image from an SDL data source into a software surface.<br/>
		/// An SDL_Surface is a buffer of pixels in memory accessible by the CPU. Use<br/>
		/// this if you plan to hand the data to something else or manipulate it<br/>
		/// further in code.<br/>
		/// There are no guarantees about what format the new SDL_Surface data will be;<br/>
		/// in many cases, SDL_image will attempt to supply a surface that exactly<br/>
		/// matches the provided image, but in others it might have to convert (either<br/>
		/// because the image is in a format that SDL doesn't directly support or<br/>
		/// because it's compressed data that could reasonably uncompress to various<br/>
		/// formats and SDL_image had to pick one). You can inspect an SDL_Surface for<br/>
		/// its specifics, and use SDL_ConvertSurface to then migrate to any supported<br/>
		/// format.<br/>
		/// If the image format supports a transparent pixel, SDL will set the colorkey<br/>
		/// for the surface. You can enable RLE acceleration on the surface afterwards<br/>
		/// by calling: SDL_SetSurfaceColorKey(image, SDL_RLEACCEL,<br/>
		/// image->format->colorkey);<br/>
		/// If `closeio` is true, `src` will be closed before returning, whether this<br/>
		/// function succeeds or not. SDL_image reads everything it needs from `src`<br/>
		/// during this call in any case.<br/>
		/// Even though this function accepts a file type, SDL_image may still try<br/>
		/// other decoders that are capable of detecting file type from the contents of<br/>
		/// the image data, but may rely on the caller-provided type string for formats<br/>
		/// that it cannot autodetect. If `type` is NULL, SDL_image will rely solely on<br/>
		/// its ability to guess the format.<br/>
		/// There is a separate function to read files from disk without having to deal<br/>
		/// with SDL_IOStream: `IMG_Load("filename.jpg")` will call this function and<br/>
		/// manage those details for you, determining the file type from the filename's<br/>
		/// extension.<br/>
		/// There is also IMG_Load_IO(), which is equivalent to this function except<br/>
		/// that it will rely on SDL_image to determine what type of data it is<br/>
		/// loading, much like passing a NULL for type.<br/>
		/// If you are using SDL's 2D rendering API, there is an equivalent call to<br/>
		/// load images directly into an SDL_Texture for use by the GPU without using a<br/>
		/// software surface: call IMG_LoadTextureTyped_IO() instead.<br/>
		/// When done with the returned surface, the app should dispose of it with a<br/>
		/// call to SDL_DestroySurface().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadTyped_IO")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurface* LoadTypedIO([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream src, [NativeName(NativeNameType.Param, "closeio")] [NativeName(NativeNameType.Type, "bool")] bool closeio, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "char const *")] byte* type)
		{
			fixed (SDLIOStream* psrc = &src)
			{
				SDLSurface* ret = LoadTypedIONative((SDLIOStream*)psrc, closeio ? (byte)1 : (byte)0, type);
				return ret;
			}
		}

		/// <summary>
		/// Load an image from an SDL data source into a software surface.<br/>
		/// An SDL_Surface is a buffer of pixels in memory accessible by the CPU. Use<br/>
		/// this if you plan to hand the data to something else or manipulate it<br/>
		/// further in code.<br/>
		/// There are no guarantees about what format the new SDL_Surface data will be;<br/>
		/// in many cases, SDL_image will attempt to supply a surface that exactly<br/>
		/// matches the provided image, but in others it might have to convert (either<br/>
		/// because the image is in a format that SDL doesn't directly support or<br/>
		/// because it's compressed data that could reasonably uncompress to various<br/>
		/// formats and SDL_image had to pick one). You can inspect an SDL_Surface for<br/>
		/// its specifics, and use SDL_ConvertSurface to then migrate to any supported<br/>
		/// format.<br/>
		/// If the image format supports a transparent pixel, SDL will set the colorkey<br/>
		/// for the surface. You can enable RLE acceleration on the surface afterwards<br/>
		/// by calling: SDL_SetSurfaceColorKey(image, SDL_RLEACCEL,<br/>
		/// image->format->colorkey);<br/>
		/// If `closeio` is true, `src` will be closed before returning, whether this<br/>
		/// function succeeds or not. SDL_image reads everything it needs from `src`<br/>
		/// during this call in any case.<br/>
		/// Even though this function accepts a file type, SDL_image may still try<br/>
		/// other decoders that are capable of detecting file type from the contents of<br/>
		/// the image data, but may rely on the caller-provided type string for formats<br/>
		/// that it cannot autodetect. If `type` is NULL, SDL_image will rely solely on<br/>
		/// its ability to guess the format.<br/>
		/// There is a separate function to read files from disk without having to deal<br/>
		/// with SDL_IOStream: `IMG_Load("filename.jpg")` will call this function and<br/>
		/// manage those details for you, determining the file type from the filename's<br/>
		/// extension.<br/>
		/// There is also IMG_Load_IO(), which is equivalent to this function except<br/>
		/// that it will rely on SDL_image to determine what type of data it is<br/>
		/// loading, much like passing a NULL for type.<br/>
		/// If you are using SDL's 2D rendering API, there is an equivalent call to<br/>
		/// load images directly into an SDL_Texture for use by the GPU without using a<br/>
		/// software surface: call IMG_LoadTextureTyped_IO() instead.<br/>
		/// When done with the returned surface, the app should dispose of it with a<br/>
		/// call to SDL_DestroySurface().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadTyped_IO")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurface* LoadTypedIO([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src, [NativeName(NativeNameType.Param, "closeio")] [NativeName(NativeNameType.Type, "bool")] bool closeio, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "char const *")] ref byte type)
		{
			fixed (byte* ptype = &type)
			{
				SDLSurface* ret = LoadTypedIONative(src, closeio ? (byte)1 : (byte)0, (byte*)ptype);
				return ret;
			}
		}

		/// <summary>
		/// Load an image from an SDL data source into a software surface.<br/>
		/// An SDL_Surface is a buffer of pixels in memory accessible by the CPU. Use<br/>
		/// this if you plan to hand the data to something else or manipulate it<br/>
		/// further in code.<br/>
		/// There are no guarantees about what format the new SDL_Surface data will be;<br/>
		/// in many cases, SDL_image will attempt to supply a surface that exactly<br/>
		/// matches the provided image, but in others it might have to convert (either<br/>
		/// because the image is in a format that SDL doesn't directly support or<br/>
		/// because it's compressed data that could reasonably uncompress to various<br/>
		/// formats and SDL_image had to pick one). You can inspect an SDL_Surface for<br/>
		/// its specifics, and use SDL_ConvertSurface to then migrate to any supported<br/>
		/// format.<br/>
		/// If the image format supports a transparent pixel, SDL will set the colorkey<br/>
		/// for the surface. You can enable RLE acceleration on the surface afterwards<br/>
		/// by calling: SDL_SetSurfaceColorKey(image, SDL_RLEACCEL,<br/>
		/// image->format->colorkey);<br/>
		/// If `closeio` is true, `src` will be closed before returning, whether this<br/>
		/// function succeeds or not. SDL_image reads everything it needs from `src`<br/>
		/// during this call in any case.<br/>
		/// Even though this function accepts a file type, SDL_image may still try<br/>
		/// other decoders that are capable of detecting file type from the contents of<br/>
		/// the image data, but may rely on the caller-provided type string for formats<br/>
		/// that it cannot autodetect. If `type` is NULL, SDL_image will rely solely on<br/>
		/// its ability to guess the format.<br/>
		/// There is a separate function to read files from disk without having to deal<br/>
		/// with SDL_IOStream: `IMG_Load("filename.jpg")` will call this function and<br/>
		/// manage those details for you, determining the file type from the filename's<br/>
		/// extension.<br/>
		/// There is also IMG_Load_IO(), which is equivalent to this function except<br/>
		/// that it will rely on SDL_image to determine what type of data it is<br/>
		/// loading, much like passing a NULL for type.<br/>
		/// If you are using SDL's 2D rendering API, there is an equivalent call to<br/>
		/// load images directly into an SDL_Texture for use by the GPU without using a<br/>
		/// software surface: call IMG_LoadTextureTyped_IO() instead.<br/>
		/// When done with the returned surface, the app should dispose of it with a<br/>
		/// call to SDL_DestroySurface().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadTyped_IO")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurface* LoadTypedIO([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src, [NativeName(NativeNameType.Param, "closeio")] [NativeName(NativeNameType.Type, "bool")] bool closeio, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> type)
		{
			fixed (byte* ptype = type)
			{
				SDLSurface* ret = LoadTypedIONative(src, closeio ? (byte)1 : (byte)0, (byte*)ptype);
				return ret;
			}
		}

		/// <summary>
		/// Load an image from an SDL data source into a software surface.<br/>
		/// An SDL_Surface is a buffer of pixels in memory accessible by the CPU. Use<br/>
		/// this if you plan to hand the data to something else or manipulate it<br/>
		/// further in code.<br/>
		/// There are no guarantees about what format the new SDL_Surface data will be;<br/>
		/// in many cases, SDL_image will attempt to supply a surface that exactly<br/>
		/// matches the provided image, but in others it might have to convert (either<br/>
		/// because the image is in a format that SDL doesn't directly support or<br/>
		/// because it's compressed data that could reasonably uncompress to various<br/>
		/// formats and SDL_image had to pick one). You can inspect an SDL_Surface for<br/>
		/// its specifics, and use SDL_ConvertSurface to then migrate to any supported<br/>
		/// format.<br/>
		/// If the image format supports a transparent pixel, SDL will set the colorkey<br/>
		/// for the surface. You can enable RLE acceleration on the surface afterwards<br/>
		/// by calling: SDL_SetSurfaceColorKey(image, SDL_RLEACCEL,<br/>
		/// image->format->colorkey);<br/>
		/// If `closeio` is true, `src` will be closed before returning, whether this<br/>
		/// function succeeds or not. SDL_image reads everything it needs from `src`<br/>
		/// during this call in any case.<br/>
		/// Even though this function accepts a file type, SDL_image may still try<br/>
		/// other decoders that are capable of detecting file type from the contents of<br/>
		/// the image data, but may rely on the caller-provided type string for formats<br/>
		/// that it cannot autodetect. If `type` is NULL, SDL_image will rely solely on<br/>
		/// its ability to guess the format.<br/>
		/// There is a separate function to read files from disk without having to deal<br/>
		/// with SDL_IOStream: `IMG_Load("filename.jpg")` will call this function and<br/>
		/// manage those details for you, determining the file type from the filename's<br/>
		/// extension.<br/>
		/// There is also IMG_Load_IO(), which is equivalent to this function except<br/>
		/// that it will rely on SDL_image to determine what type of data it is<br/>
		/// loading, much like passing a NULL for type.<br/>
		/// If you are using SDL's 2D rendering API, there is an equivalent call to<br/>
		/// load images directly into an SDL_Texture for use by the GPU without using a<br/>
		/// software surface: call IMG_LoadTextureTyped_IO() instead.<br/>
		/// When done with the returned surface, the app should dispose of it with a<br/>
		/// call to SDL_DestroySurface().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadTyped_IO")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurface* LoadTypedIO([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src, [NativeName(NativeNameType.Param, "closeio")] [NativeName(NativeNameType.Type, "bool")] bool closeio, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "char const *")] string type)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (type != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(type);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(type, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLSurface* ret = LoadTypedIONative(src, closeio ? (byte)1 : (byte)0, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Load an image from an SDL data source into a software surface.<br/>
		/// An SDL_Surface is a buffer of pixels in memory accessible by the CPU. Use<br/>
		/// this if you plan to hand the data to something else or manipulate it<br/>
		/// further in code.<br/>
		/// There are no guarantees about what format the new SDL_Surface data will be;<br/>
		/// in many cases, SDL_image will attempt to supply a surface that exactly<br/>
		/// matches the provided image, but in others it might have to convert (either<br/>
		/// because the image is in a format that SDL doesn't directly support or<br/>
		/// because it's compressed data that could reasonably uncompress to various<br/>
		/// formats and SDL_image had to pick one). You can inspect an SDL_Surface for<br/>
		/// its specifics, and use SDL_ConvertSurface to then migrate to any supported<br/>
		/// format.<br/>
		/// If the image format supports a transparent pixel, SDL will set the colorkey<br/>
		/// for the surface. You can enable RLE acceleration on the surface afterwards<br/>
		/// by calling: SDL_SetSurfaceColorKey(image, SDL_RLEACCEL,<br/>
		/// image->format->colorkey);<br/>
		/// If `closeio` is true, `src` will be closed before returning, whether this<br/>
		/// function succeeds or not. SDL_image reads everything it needs from `src`<br/>
		/// during this call in any case.<br/>
		/// Even though this function accepts a file type, SDL_image may still try<br/>
		/// other decoders that are capable of detecting file type from the contents of<br/>
		/// the image data, but may rely on the caller-provided type string for formats<br/>
		/// that it cannot autodetect. If `type` is NULL, SDL_image will rely solely on<br/>
		/// its ability to guess the format.<br/>
		/// There is a separate function to read files from disk without having to deal<br/>
		/// with SDL_IOStream: `IMG_Load("filename.jpg")` will call this function and<br/>
		/// manage those details for you, determining the file type from the filename's<br/>
		/// extension.<br/>
		/// There is also IMG_Load_IO(), which is equivalent to this function except<br/>
		/// that it will rely on SDL_image to determine what type of data it is<br/>
		/// loading, much like passing a NULL for type.<br/>
		/// If you are using SDL's 2D rendering API, there is an equivalent call to<br/>
		/// load images directly into an SDL_Texture for use by the GPU without using a<br/>
		/// software surface: call IMG_LoadTextureTyped_IO() instead.<br/>
		/// When done with the returned surface, the app should dispose of it with a<br/>
		/// call to SDL_DestroySurface().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadTyped_IO")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurface* LoadTypedIO([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream src, [NativeName(NativeNameType.Param, "closeio")] [NativeName(NativeNameType.Type, "bool")] bool closeio, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "char const *")] ref byte type)
		{
			fixed (SDLIOStream* psrc = &src)
			{
				fixed (byte* ptype = &type)
				{
					SDLSurface* ret = LoadTypedIONative((SDLIOStream*)psrc, closeio ? (byte)1 : (byte)0, (byte*)ptype);
					return ret;
				}
			}
		}

		/// <summary>
		/// Load an image from an SDL data source into a software surface.<br/>
		/// An SDL_Surface is a buffer of pixels in memory accessible by the CPU. Use<br/>
		/// this if you plan to hand the data to something else or manipulate it<br/>
		/// further in code.<br/>
		/// There are no guarantees about what format the new SDL_Surface data will be;<br/>
		/// in many cases, SDL_image will attempt to supply a surface that exactly<br/>
		/// matches the provided image, but in others it might have to convert (either<br/>
		/// because the image is in a format that SDL doesn't directly support or<br/>
		/// because it's compressed data that could reasonably uncompress to various<br/>
		/// formats and SDL_image had to pick one). You can inspect an SDL_Surface for<br/>
		/// its specifics, and use SDL_ConvertSurface to then migrate to any supported<br/>
		/// format.<br/>
		/// If the image format supports a transparent pixel, SDL will set the colorkey<br/>
		/// for the surface. You can enable RLE acceleration on the surface afterwards<br/>
		/// by calling: SDL_SetSurfaceColorKey(image, SDL_RLEACCEL,<br/>
		/// image->format->colorkey);<br/>
		/// If `closeio` is true, `src` will be closed before returning, whether this<br/>
		/// function succeeds or not. SDL_image reads everything it needs from `src`<br/>
		/// during this call in any case.<br/>
		/// Even though this function accepts a file type, SDL_image may still try<br/>
		/// other decoders that are capable of detecting file type from the contents of<br/>
		/// the image data, but may rely on the caller-provided type string for formats<br/>
		/// that it cannot autodetect. If `type` is NULL, SDL_image will rely solely on<br/>
		/// its ability to guess the format.<br/>
		/// There is a separate function to read files from disk without having to deal<br/>
		/// with SDL_IOStream: `IMG_Load("filename.jpg")` will call this function and<br/>
		/// manage those details for you, determining the file type from the filename's<br/>
		/// extension.<br/>
		/// There is also IMG_Load_IO(), which is equivalent to this function except<br/>
		/// that it will rely on SDL_image to determine what type of data it is<br/>
		/// loading, much like passing a NULL for type.<br/>
		/// If you are using SDL's 2D rendering API, there is an equivalent call to<br/>
		/// load images directly into an SDL_Texture for use by the GPU without using a<br/>
		/// software surface: call IMG_LoadTextureTyped_IO() instead.<br/>
		/// When done with the returned surface, the app should dispose of it with a<br/>
		/// call to SDL_DestroySurface().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadTyped_IO")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurface* LoadTypedIO([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream src, [NativeName(NativeNameType.Param, "closeio")] [NativeName(NativeNameType.Type, "bool")] bool closeio, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> type)
		{
			fixed (SDLIOStream* psrc = &src)
			{
				fixed (byte* ptype = type)
				{
					SDLSurface* ret = LoadTypedIONative((SDLIOStream*)psrc, closeio ? (byte)1 : (byte)0, (byte*)ptype);
					return ret;
				}
			}
		}

		/// <summary>
		/// Load an image from an SDL data source into a software surface.<br/>
		/// An SDL_Surface is a buffer of pixels in memory accessible by the CPU. Use<br/>
		/// this if you plan to hand the data to something else or manipulate it<br/>
		/// further in code.<br/>
		/// There are no guarantees about what format the new SDL_Surface data will be;<br/>
		/// in many cases, SDL_image will attempt to supply a surface that exactly<br/>
		/// matches the provided image, but in others it might have to convert (either<br/>
		/// because the image is in a format that SDL doesn't directly support or<br/>
		/// because it's compressed data that could reasonably uncompress to various<br/>
		/// formats and SDL_image had to pick one). You can inspect an SDL_Surface for<br/>
		/// its specifics, and use SDL_ConvertSurface to then migrate to any supported<br/>
		/// format.<br/>
		/// If the image format supports a transparent pixel, SDL will set the colorkey<br/>
		/// for the surface. You can enable RLE acceleration on the surface afterwards<br/>
		/// by calling: SDL_SetSurfaceColorKey(image, SDL_RLEACCEL,<br/>
		/// image->format->colorkey);<br/>
		/// If `closeio` is true, `src` will be closed before returning, whether this<br/>
		/// function succeeds or not. SDL_image reads everything it needs from `src`<br/>
		/// during this call in any case.<br/>
		/// Even though this function accepts a file type, SDL_image may still try<br/>
		/// other decoders that are capable of detecting file type from the contents of<br/>
		/// the image data, but may rely on the caller-provided type string for formats<br/>
		/// that it cannot autodetect. If `type` is NULL, SDL_image will rely solely on<br/>
		/// its ability to guess the format.<br/>
		/// There is a separate function to read files from disk without having to deal<br/>
		/// with SDL_IOStream: `IMG_Load("filename.jpg")` will call this function and<br/>
		/// manage those details for you, determining the file type from the filename's<br/>
		/// extension.<br/>
		/// There is also IMG_Load_IO(), which is equivalent to this function except<br/>
		/// that it will rely on SDL_image to determine what type of data it is<br/>
		/// loading, much like passing a NULL for type.<br/>
		/// If you are using SDL's 2D rendering API, there is an equivalent call to<br/>
		/// load images directly into an SDL_Texture for use by the GPU without using a<br/>
		/// software surface: call IMG_LoadTextureTyped_IO() instead.<br/>
		/// When done with the returned surface, the app should dispose of it with a<br/>
		/// call to SDL_DestroySurface().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadTyped_IO")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurface* LoadTypedIO([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream src, [NativeName(NativeNameType.Param, "closeio")] [NativeName(NativeNameType.Type, "bool")] bool closeio, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "char const *")] string type)
		{
			fixed (SDLIOStream* psrc = &src)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (type != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(type);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(type, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				SDLSurface* ret = LoadTypedIONative((SDLIOStream*)psrc, closeio ? (byte)1 : (byte)0, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// Load an image from a filesystem path into a software surface.<br/>
		/// An SDL_Surface is a buffer of pixels in memory accessible by the CPU. Use<br/>
		/// this if you plan to hand the data to something else or manipulate it<br/>
		/// further in code.<br/>
		/// There are no guarantees about what format the new SDL_Surface data will be;<br/>
		/// in many cases, SDL_image will attempt to supply a surface that exactly<br/>
		/// matches the provided image, but in others it might have to convert (either<br/>
		/// because the image is in a format that SDL doesn't directly support or<br/>
		/// because it's compressed data that could reasonably uncompress to various<br/>
		/// formats and SDL_image had to pick one). You can inspect an SDL_Surface for<br/>
		/// its specifics, and use SDL_ConvertSurface to then migrate to any supported<br/>
		/// format.<br/>
		/// If the image format supports a transparent pixel, SDL will set the colorkey<br/>
		/// for the surface. You can enable RLE acceleration on the surface afterwards<br/>
		/// by calling: SDL_SetSurfaceColorKey(image, SDL_RLEACCEL,<br/>
		/// image->format->colorkey);<br/>
		/// There is a separate function to read files from an SDL_IOStream, if you<br/>
		/// need an i/o abstraction to provide data from anywhere instead of a simple<br/>
		/// filesystem read; that function is IMG_Load_IO().<br/>
		/// If you are using SDL's 2D rendering API, there is an equivalent call to<br/>
		/// load images directly into an SDL_Texture for use by the GPU without using a<br/>
		/// software surface: call IMG_LoadTexture() instead.<br/>
		/// When done with the returned surface, the app should dispose of it with a<br/>
		/// call to<br/>
		/// [SDL_DestroySurface](https://wiki.libsdl.org/SDL3/SDL_DestroySurface)<br/>
		/// ().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_Load")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLSurface* LoadNative([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] byte* file)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, SDLSurface*>)funcTable[2])(file);
			#else
			return (SDLSurface*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[2])((nint)file);
			#endif
		}

		/// <summary>
		/// Load an image from a filesystem path into a software surface.<br/>
		/// An SDL_Surface is a buffer of pixels in memory accessible by the CPU. Use<br/>
		/// this if you plan to hand the data to something else or manipulate it<br/>
		/// further in code.<br/>
		/// There are no guarantees about what format the new SDL_Surface data will be;<br/>
		/// in many cases, SDL_image will attempt to supply a surface that exactly<br/>
		/// matches the provided image, but in others it might have to convert (either<br/>
		/// because the image is in a format that SDL doesn't directly support or<br/>
		/// because it's compressed data that could reasonably uncompress to various<br/>
		/// formats and SDL_image had to pick one). You can inspect an SDL_Surface for<br/>
		/// its specifics, and use SDL_ConvertSurface to then migrate to any supported<br/>
		/// format.<br/>
		/// If the image format supports a transparent pixel, SDL will set the colorkey<br/>
		/// for the surface. You can enable RLE acceleration on the surface afterwards<br/>
		/// by calling: SDL_SetSurfaceColorKey(image, SDL_RLEACCEL,<br/>
		/// image->format->colorkey);<br/>
		/// There is a separate function to read files from an SDL_IOStream, if you<br/>
		/// need an i/o abstraction to provide data from anywhere instead of a simple<br/>
		/// filesystem read; that function is IMG_Load_IO().<br/>
		/// If you are using SDL's 2D rendering API, there is an equivalent call to<br/>
		/// load images directly into an SDL_Texture for use by the GPU without using a<br/>
		/// software surface: call IMG_LoadTexture() instead.<br/>
		/// When done with the returned surface, the app should dispose of it with a<br/>
		/// call to<br/>
		/// [SDL_DestroySurface](https://wiki.libsdl.org/SDL3/SDL_DestroySurface)<br/>
		/// ().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_Load")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurface* Load([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] byte* file)
		{
			SDLSurface* ret = LoadNative(file);
			return ret;
		}

		/// <summary>
		/// Load an image from a filesystem path into a software surface.<br/>
		/// An SDL_Surface is a buffer of pixels in memory accessible by the CPU. Use<br/>
		/// this if you plan to hand the data to something else or manipulate it<br/>
		/// further in code.<br/>
		/// There are no guarantees about what format the new SDL_Surface data will be;<br/>
		/// in many cases, SDL_image will attempt to supply a surface that exactly<br/>
		/// matches the provided image, but in others it might have to convert (either<br/>
		/// because the image is in a format that SDL doesn't directly support or<br/>
		/// because it's compressed data that could reasonably uncompress to various<br/>
		/// formats and SDL_image had to pick one). You can inspect an SDL_Surface for<br/>
		/// its specifics, and use SDL_ConvertSurface to then migrate to any supported<br/>
		/// format.<br/>
		/// If the image format supports a transparent pixel, SDL will set the colorkey<br/>
		/// for the surface. You can enable RLE acceleration on the surface afterwards<br/>
		/// by calling: SDL_SetSurfaceColorKey(image, SDL_RLEACCEL,<br/>
		/// image->format->colorkey);<br/>
		/// There is a separate function to read files from an SDL_IOStream, if you<br/>
		/// need an i/o abstraction to provide data from anywhere instead of a simple<br/>
		/// filesystem read; that function is IMG_Load_IO().<br/>
		/// If you are using SDL's 2D rendering API, there is an equivalent call to<br/>
		/// load images directly into an SDL_Texture for use by the GPU without using a<br/>
		/// software surface: call IMG_LoadTexture() instead.<br/>
		/// When done with the returned surface, the app should dispose of it with a<br/>
		/// call to<br/>
		/// [SDL_DestroySurface](https://wiki.libsdl.org/SDL3/SDL_DestroySurface)<br/>
		/// ().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_Load")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurface* Load([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] ref byte file)
		{
			fixed (byte* pfile = &file)
			{
				SDLSurface* ret = LoadNative((byte*)pfile);
				return ret;
			}
		}

		/// <summary>
		/// Load an image from a filesystem path into a software surface.<br/>
		/// An SDL_Surface is a buffer of pixels in memory accessible by the CPU. Use<br/>
		/// this if you plan to hand the data to something else or manipulate it<br/>
		/// further in code.<br/>
		/// There are no guarantees about what format the new SDL_Surface data will be;<br/>
		/// in many cases, SDL_image will attempt to supply a surface that exactly<br/>
		/// matches the provided image, but in others it might have to convert (either<br/>
		/// because the image is in a format that SDL doesn't directly support or<br/>
		/// because it's compressed data that could reasonably uncompress to various<br/>
		/// formats and SDL_image had to pick one). You can inspect an SDL_Surface for<br/>
		/// its specifics, and use SDL_ConvertSurface to then migrate to any supported<br/>
		/// format.<br/>
		/// If the image format supports a transparent pixel, SDL will set the colorkey<br/>
		/// for the surface. You can enable RLE acceleration on the surface afterwards<br/>
		/// by calling: SDL_SetSurfaceColorKey(image, SDL_RLEACCEL,<br/>
		/// image->format->colorkey);<br/>
		/// There is a separate function to read files from an SDL_IOStream, if you<br/>
		/// need an i/o abstraction to provide data from anywhere instead of a simple<br/>
		/// filesystem read; that function is IMG_Load_IO().<br/>
		/// If you are using SDL's 2D rendering API, there is an equivalent call to<br/>
		/// load images directly into an SDL_Texture for use by the GPU without using a<br/>
		/// software surface: call IMG_LoadTexture() instead.<br/>
		/// When done with the returned surface, the app should dispose of it with a<br/>
		/// call to<br/>
		/// [SDL_DestroySurface](https://wiki.libsdl.org/SDL3/SDL_DestroySurface)<br/>
		/// ().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_Load")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurface* Load([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> file)
		{
			fixed (byte* pfile = file)
			{
				SDLSurface* ret = LoadNative((byte*)pfile);
				return ret;
			}
		}

		/// <summary>
		/// Load an image from a filesystem path into a software surface.<br/>
		/// An SDL_Surface is a buffer of pixels in memory accessible by the CPU. Use<br/>
		/// this if you plan to hand the data to something else or manipulate it<br/>
		/// further in code.<br/>
		/// There are no guarantees about what format the new SDL_Surface data will be;<br/>
		/// in many cases, SDL_image will attempt to supply a surface that exactly<br/>
		/// matches the provided image, but in others it might have to convert (either<br/>
		/// because the image is in a format that SDL doesn't directly support or<br/>
		/// because it's compressed data that could reasonably uncompress to various<br/>
		/// formats and SDL_image had to pick one). You can inspect an SDL_Surface for<br/>
		/// its specifics, and use SDL_ConvertSurface to then migrate to any supported<br/>
		/// format.<br/>
		/// If the image format supports a transparent pixel, SDL will set the colorkey<br/>
		/// for the surface. You can enable RLE acceleration on the surface afterwards<br/>
		/// by calling: SDL_SetSurfaceColorKey(image, SDL_RLEACCEL,<br/>
		/// image->format->colorkey);<br/>
		/// There is a separate function to read files from an SDL_IOStream, if you<br/>
		/// need an i/o abstraction to provide data from anywhere instead of a simple<br/>
		/// filesystem read; that function is IMG_Load_IO().<br/>
		/// If you are using SDL's 2D rendering API, there is an equivalent call to<br/>
		/// load images directly into an SDL_Texture for use by the GPU without using a<br/>
		/// software surface: call IMG_LoadTexture() instead.<br/>
		/// When done with the returned surface, the app should dispose of it with a<br/>
		/// call to<br/>
		/// [SDL_DestroySurface](https://wiki.libsdl.org/SDL3/SDL_DestroySurface)<br/>
		/// ().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_Load")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurface* Load([NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] string file)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (file != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(file);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(file, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLSurface* ret = LoadNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Load an image from an SDL data source into a software surface.<br/>
		/// An SDL_Surface is a buffer of pixels in memory accessible by the CPU. Use<br/>
		/// this if you plan to hand the data to something else or manipulate it<br/>
		/// further in code.<br/>
		/// There are no guarantees about what format the new SDL_Surface data will be;<br/>
		/// in many cases, SDL_image will attempt to supply a surface that exactly<br/>
		/// matches the provided image, but in others it might have to convert (either<br/>
		/// because the image is in a format that SDL doesn't directly support or<br/>
		/// because it's compressed data that could reasonably uncompress to various<br/>
		/// formats and SDL_image had to pick one). You can inspect an SDL_Surface for<br/>
		/// its specifics, and use SDL_ConvertSurface to then migrate to any supported<br/>
		/// format.<br/>
		/// If the image format supports a transparent pixel, SDL will set the colorkey<br/>
		/// for the surface. You can enable RLE acceleration on the surface afterwards<br/>
		/// by calling: SDL_SetSurfaceColorKey(image, SDL_RLEACCEL,<br/>
		/// image->format->colorkey);<br/>
		/// If `closeio` is true, `src` will be closed before returning, whether this<br/>
		/// function succeeds or not. SDL_image reads everything it needs from `src`<br/>
		/// during this call in any case.<br/>
		/// There is a separate function to read files from disk without having to deal<br/>
		/// with SDL_IOStream: `IMG_Load("filename.jpg")` will call this function and<br/>
		/// manage those details for you, determining the file type from the filename's<br/>
		/// extension.<br/>
		/// There is also IMG_LoadTyped_IO(), which is equivalent to this function<br/>
		/// except a file extension (like "BMP", "JPG", etc) can be specified, in case<br/>
		/// SDL_image cannot autodetect the file format.<br/>
		/// If you are using SDL's 2D rendering API, there is an equivalent call to<br/>
		/// load images directly into an SDL_Texture for use by the GPU without using a<br/>
		/// software surface: call IMG_LoadTexture_IO() instead.<br/>
		/// When done with the returned surface, the app should dispose of it with a<br/>
		/// call to SDL_DestroySurface().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_Load_IO")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLSurface* LoadIONative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src, [NativeName(NativeNameType.Param, "closeio")] [NativeName(NativeNameType.Type, "bool")] byte closeio)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLIOStream*, byte, SDLSurface*>)funcTable[3])(src, closeio);
			#else
			return (SDLSurface*)((delegate* unmanaged[Cdecl]<nint, byte, nint>)funcTable[3])((nint)src, closeio);
			#endif
		}

		/// <summary>
		/// Load an image from an SDL data source into a software surface.<br/>
		/// An SDL_Surface is a buffer of pixels in memory accessible by the CPU. Use<br/>
		/// this if you plan to hand the data to something else or manipulate it<br/>
		/// further in code.<br/>
		/// There are no guarantees about what format the new SDL_Surface data will be;<br/>
		/// in many cases, SDL_image will attempt to supply a surface that exactly<br/>
		/// matches the provided image, but in others it might have to convert (either<br/>
		/// because the image is in a format that SDL doesn't directly support or<br/>
		/// because it's compressed data that could reasonably uncompress to various<br/>
		/// formats and SDL_image had to pick one). You can inspect an SDL_Surface for<br/>
		/// its specifics, and use SDL_ConvertSurface to then migrate to any supported<br/>
		/// format.<br/>
		/// If the image format supports a transparent pixel, SDL will set the colorkey<br/>
		/// for the surface. You can enable RLE acceleration on the surface afterwards<br/>
		/// by calling: SDL_SetSurfaceColorKey(image, SDL_RLEACCEL,<br/>
		/// image->format->colorkey);<br/>
		/// If `closeio` is true, `src` will be closed before returning, whether this<br/>
		/// function succeeds or not. SDL_image reads everything it needs from `src`<br/>
		/// during this call in any case.<br/>
		/// There is a separate function to read files from disk without having to deal<br/>
		/// with SDL_IOStream: `IMG_Load("filename.jpg")` will call this function and<br/>
		/// manage those details for you, determining the file type from the filename's<br/>
		/// extension.<br/>
		/// There is also IMG_LoadTyped_IO(), which is equivalent to this function<br/>
		/// except a file extension (like "BMP", "JPG", etc) can be specified, in case<br/>
		/// SDL_image cannot autodetect the file format.<br/>
		/// If you are using SDL's 2D rendering API, there is an equivalent call to<br/>
		/// load images directly into an SDL_Texture for use by the GPU without using a<br/>
		/// software surface: call IMG_LoadTexture_IO() instead.<br/>
		/// When done with the returned surface, the app should dispose of it with a<br/>
		/// call to SDL_DestroySurface().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_Load_IO")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurface* LoadIO([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src, [NativeName(NativeNameType.Param, "closeio")] [NativeName(NativeNameType.Type, "bool")] bool closeio)
		{
			SDLSurface* ret = LoadIONative(src, closeio ? (byte)1 : (byte)0);
			return ret;
		}

		/// <summary>
		/// Load an image from an SDL data source into a software surface.<br/>
		/// An SDL_Surface is a buffer of pixels in memory accessible by the CPU. Use<br/>
		/// this if you plan to hand the data to something else or manipulate it<br/>
		/// further in code.<br/>
		/// There are no guarantees about what format the new SDL_Surface data will be;<br/>
		/// in many cases, SDL_image will attempt to supply a surface that exactly<br/>
		/// matches the provided image, but in others it might have to convert (either<br/>
		/// because the image is in a format that SDL doesn't directly support or<br/>
		/// because it's compressed data that could reasonably uncompress to various<br/>
		/// formats and SDL_image had to pick one). You can inspect an SDL_Surface for<br/>
		/// its specifics, and use SDL_ConvertSurface to then migrate to any supported<br/>
		/// format.<br/>
		/// If the image format supports a transparent pixel, SDL will set the colorkey<br/>
		/// for the surface. You can enable RLE acceleration on the surface afterwards<br/>
		/// by calling: SDL_SetSurfaceColorKey(image, SDL_RLEACCEL,<br/>
		/// image->format->colorkey);<br/>
		/// If `closeio` is true, `src` will be closed before returning, whether this<br/>
		/// function succeeds or not. SDL_image reads everything it needs from `src`<br/>
		/// during this call in any case.<br/>
		/// There is a separate function to read files from disk without having to deal<br/>
		/// with SDL_IOStream: `IMG_Load("filename.jpg")` will call this function and<br/>
		/// manage those details for you, determining the file type from the filename's<br/>
		/// extension.<br/>
		/// There is also IMG_LoadTyped_IO(), which is equivalent to this function<br/>
		/// except a file extension (like "BMP", "JPG", etc) can be specified, in case<br/>
		/// SDL_image cannot autodetect the file format.<br/>
		/// If you are using SDL's 2D rendering API, there is an equivalent call to<br/>
		/// load images directly into an SDL_Texture for use by the GPU without using a<br/>
		/// software surface: call IMG_LoadTexture_IO() instead.<br/>
		/// When done with the returned surface, the app should dispose of it with a<br/>
		/// call to SDL_DestroySurface().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_Load_IO")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurface* LoadIO([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream src, [NativeName(NativeNameType.Param, "closeio")] [NativeName(NativeNameType.Type, "bool")] bool closeio)
		{
			fixed (SDLIOStream* psrc = &src)
			{
				SDLSurface* ret = LoadIONative((SDLIOStream*)psrc, closeio ? (byte)1 : (byte)0);
				return ret;
			}
		}

		/// <summary>
		/// Load an image from a filesystem path into a GPU texture.<br/>
		/// An SDL_Texture represents an image in GPU memory, usable by SDL's 2D Render<br/>
		/// API. This can be significantly more efficient than using a CPU-bound<br/>
		/// SDL_Surface if you don't need to manipulate the image directly after<br/>
		/// loading it.<br/>
		/// If the loaded image has transparency or a colorkey, a texture with an alpha<br/>
		/// channel will be created. Otherwise, SDL_image will attempt to create an<br/>
		/// SDL_Texture in the most format that most reasonably represents the image<br/>
		/// data (but in many cases, this will just end up being 32-bit RGB or 32-bit<br/>
		/// RGBA).<br/>
		/// There is a separate function to read files from an SDL_IOStream, if you<br/>
		/// need an i/o abstraction to provide data from anywhere instead of a simple<br/>
		/// filesystem read; that function is IMG_LoadTexture_IO().<br/>
		/// If you would rather decode an image to an SDL_Surface (a buffer of pixels<br/>
		/// in CPU memory), call IMG_Load() instead.<br/>
		/// When done with the returned texture, the app should dispose of it with a<br/>
		/// call to SDL_DestroyTexture().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadTexture")]
		[return: NativeName(NativeNameType.Type, "SDL_Texture *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLTexture* LoadTextureNative([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer *")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] byte* file)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRenderer*, byte*, SDLTexture*>)funcTable[4])(renderer, file);
			#else
			return (SDLTexture*)((delegate* unmanaged[Cdecl]<nint, nint, nint>)funcTable[4])((nint)renderer, (nint)file);
			#endif
		}

		/// <summary>
		/// Load an image from a filesystem path into a GPU texture.<br/>
		/// An SDL_Texture represents an image in GPU memory, usable by SDL's 2D Render<br/>
		/// API. This can be significantly more efficient than using a CPU-bound<br/>
		/// SDL_Surface if you don't need to manipulate the image directly after<br/>
		/// loading it.<br/>
		/// If the loaded image has transparency or a colorkey, a texture with an alpha<br/>
		/// channel will be created. Otherwise, SDL_image will attempt to create an<br/>
		/// SDL_Texture in the most format that most reasonably represents the image<br/>
		/// data (but in many cases, this will just end up being 32-bit RGB or 32-bit<br/>
		/// RGBA).<br/>
		/// There is a separate function to read files from an SDL_IOStream, if you<br/>
		/// need an i/o abstraction to provide data from anywhere instead of a simple<br/>
		/// filesystem read; that function is IMG_LoadTexture_IO().<br/>
		/// If you would rather decode an image to an SDL_Surface (a buffer of pixels<br/>
		/// in CPU memory), call IMG_Load() instead.<br/>
		/// When done with the returned texture, the app should dispose of it with a<br/>
		/// call to SDL_DestroyTexture().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadTexture")]
		[return: NativeName(NativeNameType.Type, "SDL_Texture *")]
		public static SDLTexture* LoadTexture([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer *")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] byte* file)
		{
			SDLTexture* ret = LoadTextureNative(renderer, file);
			return ret;
		}

		/// <summary>
		/// Load an image from a filesystem path into a GPU texture.<br/>
		/// An SDL_Texture represents an image in GPU memory, usable by SDL's 2D Render<br/>
		/// API. This can be significantly more efficient than using a CPU-bound<br/>
		/// SDL_Surface if you don't need to manipulate the image directly after<br/>
		/// loading it.<br/>
		/// If the loaded image has transparency or a colorkey, a texture with an alpha<br/>
		/// channel will be created. Otherwise, SDL_image will attempt to create an<br/>
		/// SDL_Texture in the most format that most reasonably represents the image<br/>
		/// data (but in many cases, this will just end up being 32-bit RGB or 32-bit<br/>
		/// RGBA).<br/>
		/// There is a separate function to read files from an SDL_IOStream, if you<br/>
		/// need an i/o abstraction to provide data from anywhere instead of a simple<br/>
		/// filesystem read; that function is IMG_LoadTexture_IO().<br/>
		/// If you would rather decode an image to an SDL_Surface (a buffer of pixels<br/>
		/// in CPU memory), call IMG_Load() instead.<br/>
		/// When done with the returned texture, the app should dispose of it with a<br/>
		/// call to SDL_DestroyTexture().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadTexture")]
		[return: NativeName(NativeNameType.Type, "SDL_Texture *")]
		public static SDLTexture* LoadTexture([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer *")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] byte* file)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				SDLTexture* ret = LoadTextureNative((SDLRenderer*)prenderer, file);
				return ret;
			}
		}

		/// <summary>
		/// Load an image from a filesystem path into a GPU texture.<br/>
		/// An SDL_Texture represents an image in GPU memory, usable by SDL's 2D Render<br/>
		/// API. This can be significantly more efficient than using a CPU-bound<br/>
		/// SDL_Surface if you don't need to manipulate the image directly after<br/>
		/// loading it.<br/>
		/// If the loaded image has transparency or a colorkey, a texture with an alpha<br/>
		/// channel will be created. Otherwise, SDL_image will attempt to create an<br/>
		/// SDL_Texture in the most format that most reasonably represents the image<br/>
		/// data (but in many cases, this will just end up being 32-bit RGB or 32-bit<br/>
		/// RGBA).<br/>
		/// There is a separate function to read files from an SDL_IOStream, if you<br/>
		/// need an i/o abstraction to provide data from anywhere instead of a simple<br/>
		/// filesystem read; that function is IMG_LoadTexture_IO().<br/>
		/// If you would rather decode an image to an SDL_Surface (a buffer of pixels<br/>
		/// in CPU memory), call IMG_Load() instead.<br/>
		/// When done with the returned texture, the app should dispose of it with a<br/>
		/// call to SDL_DestroyTexture().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadTexture")]
		[return: NativeName(NativeNameType.Type, "SDL_Texture *")]
		public static SDLTexture* LoadTexture([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer *")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] ref byte file)
		{
			fixed (byte* pfile = &file)
			{
				SDLTexture* ret = LoadTextureNative(renderer, (byte*)pfile);
				return ret;
			}
		}

		/// <summary>
		/// Load an image from a filesystem path into a GPU texture.<br/>
		/// An SDL_Texture represents an image in GPU memory, usable by SDL's 2D Render<br/>
		/// API. This can be significantly more efficient than using a CPU-bound<br/>
		/// SDL_Surface if you don't need to manipulate the image directly after<br/>
		/// loading it.<br/>
		/// If the loaded image has transparency or a colorkey, a texture with an alpha<br/>
		/// channel will be created. Otherwise, SDL_image will attempt to create an<br/>
		/// SDL_Texture in the most format that most reasonably represents the image<br/>
		/// data (but in many cases, this will just end up being 32-bit RGB or 32-bit<br/>
		/// RGBA).<br/>
		/// There is a separate function to read files from an SDL_IOStream, if you<br/>
		/// need an i/o abstraction to provide data from anywhere instead of a simple<br/>
		/// filesystem read; that function is IMG_LoadTexture_IO().<br/>
		/// If you would rather decode an image to an SDL_Surface (a buffer of pixels<br/>
		/// in CPU memory), call IMG_Load() instead.<br/>
		/// When done with the returned texture, the app should dispose of it with a<br/>
		/// call to SDL_DestroyTexture().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadTexture")]
		[return: NativeName(NativeNameType.Type, "SDL_Texture *")]
		public static SDLTexture* LoadTexture([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer *")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> file)
		{
			fixed (byte* pfile = file)
			{
				SDLTexture* ret = LoadTextureNative(renderer, (byte*)pfile);
				return ret;
			}
		}

		/// <summary>
		/// Load an image from a filesystem path into a GPU texture.<br/>
		/// An SDL_Texture represents an image in GPU memory, usable by SDL's 2D Render<br/>
		/// API. This can be significantly more efficient than using a CPU-bound<br/>
		/// SDL_Surface if you don't need to manipulate the image directly after<br/>
		/// loading it.<br/>
		/// If the loaded image has transparency or a colorkey, a texture with an alpha<br/>
		/// channel will be created. Otherwise, SDL_image will attempt to create an<br/>
		/// SDL_Texture in the most format that most reasonably represents the image<br/>
		/// data (but in many cases, this will just end up being 32-bit RGB or 32-bit<br/>
		/// RGBA).<br/>
		/// There is a separate function to read files from an SDL_IOStream, if you<br/>
		/// need an i/o abstraction to provide data from anywhere instead of a simple<br/>
		/// filesystem read; that function is IMG_LoadTexture_IO().<br/>
		/// If you would rather decode an image to an SDL_Surface (a buffer of pixels<br/>
		/// in CPU memory), call IMG_Load() instead.<br/>
		/// When done with the returned texture, the app should dispose of it with a<br/>
		/// call to SDL_DestroyTexture().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadTexture")]
		[return: NativeName(NativeNameType.Type, "SDL_Texture *")]
		public static SDLTexture* LoadTexture([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer *")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] string file)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (file != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(file);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(file, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLTexture* ret = LoadTextureNative(renderer, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Load an image from a filesystem path into a GPU texture.<br/>
		/// An SDL_Texture represents an image in GPU memory, usable by SDL's 2D Render<br/>
		/// API. This can be significantly more efficient than using a CPU-bound<br/>
		/// SDL_Surface if you don't need to manipulate the image directly after<br/>
		/// loading it.<br/>
		/// If the loaded image has transparency or a colorkey, a texture with an alpha<br/>
		/// channel will be created. Otherwise, SDL_image will attempt to create an<br/>
		/// SDL_Texture in the most format that most reasonably represents the image<br/>
		/// data (but in many cases, this will just end up being 32-bit RGB or 32-bit<br/>
		/// RGBA).<br/>
		/// There is a separate function to read files from an SDL_IOStream, if you<br/>
		/// need an i/o abstraction to provide data from anywhere instead of a simple<br/>
		/// filesystem read; that function is IMG_LoadTexture_IO().<br/>
		/// If you would rather decode an image to an SDL_Surface (a buffer of pixels<br/>
		/// in CPU memory), call IMG_Load() instead.<br/>
		/// When done with the returned texture, the app should dispose of it with a<br/>
		/// call to SDL_DestroyTexture().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadTexture")]
		[return: NativeName(NativeNameType.Type, "SDL_Texture *")]
		public static SDLTexture* LoadTexture([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer *")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] ref byte file)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (byte* pfile = &file)
				{
					SDLTexture* ret = LoadTextureNative((SDLRenderer*)prenderer, (byte*)pfile);
					return ret;
				}
			}
		}

		/// <summary>
		/// Load an image from a filesystem path into a GPU texture.<br/>
		/// An SDL_Texture represents an image in GPU memory, usable by SDL's 2D Render<br/>
		/// API. This can be significantly more efficient than using a CPU-bound<br/>
		/// SDL_Surface if you don't need to manipulate the image directly after<br/>
		/// loading it.<br/>
		/// If the loaded image has transparency or a colorkey, a texture with an alpha<br/>
		/// channel will be created. Otherwise, SDL_image will attempt to create an<br/>
		/// SDL_Texture in the most format that most reasonably represents the image<br/>
		/// data (but in many cases, this will just end up being 32-bit RGB or 32-bit<br/>
		/// RGBA).<br/>
		/// There is a separate function to read files from an SDL_IOStream, if you<br/>
		/// need an i/o abstraction to provide data from anywhere instead of a simple<br/>
		/// filesystem read; that function is IMG_LoadTexture_IO().<br/>
		/// If you would rather decode an image to an SDL_Surface (a buffer of pixels<br/>
		/// in CPU memory), call IMG_Load() instead.<br/>
		/// When done with the returned texture, the app should dispose of it with a<br/>
		/// call to SDL_DestroyTexture().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadTexture")]
		[return: NativeName(NativeNameType.Type, "SDL_Texture *")]
		public static SDLTexture* LoadTexture([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer *")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> file)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (byte* pfile = file)
				{
					SDLTexture* ret = LoadTextureNative((SDLRenderer*)prenderer, (byte*)pfile);
					return ret;
				}
			}
		}

		/// <summary>
		/// Load an image from a filesystem path into a GPU texture.<br/>
		/// An SDL_Texture represents an image in GPU memory, usable by SDL's 2D Render<br/>
		/// API. This can be significantly more efficient than using a CPU-bound<br/>
		/// SDL_Surface if you don't need to manipulate the image directly after<br/>
		/// loading it.<br/>
		/// If the loaded image has transparency or a colorkey, a texture with an alpha<br/>
		/// channel will be created. Otherwise, SDL_image will attempt to create an<br/>
		/// SDL_Texture in the most format that most reasonably represents the image<br/>
		/// data (but in many cases, this will just end up being 32-bit RGB or 32-bit<br/>
		/// RGBA).<br/>
		/// There is a separate function to read files from an SDL_IOStream, if you<br/>
		/// need an i/o abstraction to provide data from anywhere instead of a simple<br/>
		/// filesystem read; that function is IMG_LoadTexture_IO().<br/>
		/// If you would rather decode an image to an SDL_Surface (a buffer of pixels<br/>
		/// in CPU memory), call IMG_Load() instead.<br/>
		/// When done with the returned texture, the app should dispose of it with a<br/>
		/// call to SDL_DestroyTexture().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadTexture")]
		[return: NativeName(NativeNameType.Type, "SDL_Texture *")]
		public static SDLTexture* LoadTexture([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer *")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "file")] [NativeName(NativeNameType.Type, "char const *")] string file)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (file != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(file);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(file, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				SDLTexture* ret = LoadTextureNative((SDLRenderer*)prenderer, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// Load an image from an SDL data source into a GPU texture.<br/>
		/// An SDL_Texture represents an image in GPU memory, usable by SDL's 2D Render<br/>
		/// API. This can be significantly more efficient than using a CPU-bound<br/>
		/// SDL_Surface if you don't need to manipulate the image directly after<br/>
		/// loading it.<br/>
		/// If the loaded image has transparency or a colorkey, a texture with an alpha<br/>
		/// channel will be created. Otherwise, SDL_image will attempt to create an<br/>
		/// SDL_Texture in the most format that most reasonably represents the image<br/>
		/// data (but in many cases, this will just end up being 32-bit RGB or 32-bit<br/>
		/// RGBA).<br/>
		/// If `closeio` is true, `src` will be closed before returning, whether this<br/>
		/// function succeeds or not. SDL_image reads everything it needs from `src`<br/>
		/// during this call in any case.<br/>
		/// There is a separate function to read files from disk without having to deal<br/>
		/// with SDL_IOStream: `IMG_LoadTexture(renderer, "filename.jpg")` will call<br/>
		/// this function and manage those details for you, determining the file type<br/>
		/// from the filename's extension.<br/>
		/// There is also IMG_LoadTextureTyped_IO(), which is equivalent to this<br/>
		/// function except a file extension (like "BMP", "JPG", etc) can be specified,<br/>
		/// in case SDL_image cannot autodetect the file format.<br/>
		/// If you would rather decode an image to an SDL_Surface (a buffer of pixels<br/>
		/// in CPU memory), call IMG_Load() instead.<br/>
		/// When done with the returned texture, the app should dispose of it with a<br/>
		/// call to SDL_DestroyTexture().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadTexture_IO")]
		[return: NativeName(NativeNameType.Type, "SDL_Texture *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLTexture* LoadTextureIONative([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer *")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src, [NativeName(NativeNameType.Param, "closeio")] [NativeName(NativeNameType.Type, "bool")] byte closeio)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRenderer*, SDLIOStream*, byte, SDLTexture*>)funcTable[5])(renderer, src, closeio);
			#else
			return (SDLTexture*)((delegate* unmanaged[Cdecl]<nint, nint, byte, nint>)funcTable[5])((nint)renderer, (nint)src, closeio);
			#endif
		}

		/// <summary>
		/// Load an image from an SDL data source into a GPU texture.<br/>
		/// An SDL_Texture represents an image in GPU memory, usable by SDL's 2D Render<br/>
		/// API. This can be significantly more efficient than using a CPU-bound<br/>
		/// SDL_Surface if you don't need to manipulate the image directly after<br/>
		/// loading it.<br/>
		/// If the loaded image has transparency or a colorkey, a texture with an alpha<br/>
		/// channel will be created. Otherwise, SDL_image will attempt to create an<br/>
		/// SDL_Texture in the most format that most reasonably represents the image<br/>
		/// data (but in many cases, this will just end up being 32-bit RGB or 32-bit<br/>
		/// RGBA).<br/>
		/// If `closeio` is true, `src` will be closed before returning, whether this<br/>
		/// function succeeds or not. SDL_image reads everything it needs from `src`<br/>
		/// during this call in any case.<br/>
		/// There is a separate function to read files from disk without having to deal<br/>
		/// with SDL_IOStream: `IMG_LoadTexture(renderer, "filename.jpg")` will call<br/>
		/// this function and manage those details for you, determining the file type<br/>
		/// from the filename's extension.<br/>
		/// There is also IMG_LoadTextureTyped_IO(), which is equivalent to this<br/>
		/// function except a file extension (like "BMP", "JPG", etc) can be specified,<br/>
		/// in case SDL_image cannot autodetect the file format.<br/>
		/// If you would rather decode an image to an SDL_Surface (a buffer of pixels<br/>
		/// in CPU memory), call IMG_Load() instead.<br/>
		/// When done with the returned texture, the app should dispose of it with a<br/>
		/// call to SDL_DestroyTexture().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadTexture_IO")]
		[return: NativeName(NativeNameType.Type, "SDL_Texture *")]
		public static SDLTexture* LoadTextureIO([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer *")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src, [NativeName(NativeNameType.Param, "closeio")] [NativeName(NativeNameType.Type, "bool")] bool closeio)
		{
			SDLTexture* ret = LoadTextureIONative(renderer, src, closeio ? (byte)1 : (byte)0);
			return ret;
		}

		/// <summary>
		/// Load an image from an SDL data source into a GPU texture.<br/>
		/// An SDL_Texture represents an image in GPU memory, usable by SDL's 2D Render<br/>
		/// API. This can be significantly more efficient than using a CPU-bound<br/>
		/// SDL_Surface if you don't need to manipulate the image directly after<br/>
		/// loading it.<br/>
		/// If the loaded image has transparency or a colorkey, a texture with an alpha<br/>
		/// channel will be created. Otherwise, SDL_image will attempt to create an<br/>
		/// SDL_Texture in the most format that most reasonably represents the image<br/>
		/// data (but in many cases, this will just end up being 32-bit RGB or 32-bit<br/>
		/// RGBA).<br/>
		/// If `closeio` is true, `src` will be closed before returning, whether this<br/>
		/// function succeeds or not. SDL_image reads everything it needs from `src`<br/>
		/// during this call in any case.<br/>
		/// There is a separate function to read files from disk without having to deal<br/>
		/// with SDL_IOStream: `IMG_LoadTexture(renderer, "filename.jpg")` will call<br/>
		/// this function and manage those details for you, determining the file type<br/>
		/// from the filename's extension.<br/>
		/// There is also IMG_LoadTextureTyped_IO(), which is equivalent to this<br/>
		/// function except a file extension (like "BMP", "JPG", etc) can be specified,<br/>
		/// in case SDL_image cannot autodetect the file format.<br/>
		/// If you would rather decode an image to an SDL_Surface (a buffer of pixels<br/>
		/// in CPU memory), call IMG_Load() instead.<br/>
		/// When done with the returned texture, the app should dispose of it with a<br/>
		/// call to SDL_DestroyTexture().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadTexture_IO")]
		[return: NativeName(NativeNameType.Type, "SDL_Texture *")]
		public static SDLTexture* LoadTextureIO([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer *")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src, [NativeName(NativeNameType.Param, "closeio")] [NativeName(NativeNameType.Type, "bool")] bool closeio)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				SDLTexture* ret = LoadTextureIONative((SDLRenderer*)prenderer, src, closeio ? (byte)1 : (byte)0);
				return ret;
			}
		}

		/// <summary>
		/// Load an image from an SDL data source into a GPU texture.<br/>
		/// An SDL_Texture represents an image in GPU memory, usable by SDL's 2D Render<br/>
		/// API. This can be significantly more efficient than using a CPU-bound<br/>
		/// SDL_Surface if you don't need to manipulate the image directly after<br/>
		/// loading it.<br/>
		/// If the loaded image has transparency or a colorkey, a texture with an alpha<br/>
		/// channel will be created. Otherwise, SDL_image will attempt to create an<br/>
		/// SDL_Texture in the most format that most reasonably represents the image<br/>
		/// data (but in many cases, this will just end up being 32-bit RGB or 32-bit<br/>
		/// RGBA).<br/>
		/// If `closeio` is true, `src` will be closed before returning, whether this<br/>
		/// function succeeds or not. SDL_image reads everything it needs from `src`<br/>
		/// during this call in any case.<br/>
		/// There is a separate function to read files from disk without having to deal<br/>
		/// with SDL_IOStream: `IMG_LoadTexture(renderer, "filename.jpg")` will call<br/>
		/// this function and manage those details for you, determining the file type<br/>
		/// from the filename's extension.<br/>
		/// There is also IMG_LoadTextureTyped_IO(), which is equivalent to this<br/>
		/// function except a file extension (like "BMP", "JPG", etc) can be specified,<br/>
		/// in case SDL_image cannot autodetect the file format.<br/>
		/// If you would rather decode an image to an SDL_Surface (a buffer of pixels<br/>
		/// in CPU memory), call IMG_Load() instead.<br/>
		/// When done with the returned texture, the app should dispose of it with a<br/>
		/// call to SDL_DestroyTexture().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadTexture_IO")]
		[return: NativeName(NativeNameType.Type, "SDL_Texture *")]
		public static SDLTexture* LoadTextureIO([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer *")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream src, [NativeName(NativeNameType.Param, "closeio")] [NativeName(NativeNameType.Type, "bool")] bool closeio)
		{
			fixed (SDLIOStream* psrc = &src)
			{
				SDLTexture* ret = LoadTextureIONative(renderer, (SDLIOStream*)psrc, closeio ? (byte)1 : (byte)0);
				return ret;
			}
		}

		/// <summary>
		/// Load an image from an SDL data source into a GPU texture.<br/>
		/// An SDL_Texture represents an image in GPU memory, usable by SDL's 2D Render<br/>
		/// API. This can be significantly more efficient than using a CPU-bound<br/>
		/// SDL_Surface if you don't need to manipulate the image directly after<br/>
		/// loading it.<br/>
		/// If the loaded image has transparency or a colorkey, a texture with an alpha<br/>
		/// channel will be created. Otherwise, SDL_image will attempt to create an<br/>
		/// SDL_Texture in the most format that most reasonably represents the image<br/>
		/// data (but in many cases, this will just end up being 32-bit RGB or 32-bit<br/>
		/// RGBA).<br/>
		/// If `closeio` is true, `src` will be closed before returning, whether this<br/>
		/// function succeeds or not. SDL_image reads everything it needs from `src`<br/>
		/// during this call in any case.<br/>
		/// There is a separate function to read files from disk without having to deal<br/>
		/// with SDL_IOStream: `IMG_LoadTexture(renderer, "filename.jpg")` will call<br/>
		/// this function and manage those details for you, determining the file type<br/>
		/// from the filename's extension.<br/>
		/// There is also IMG_LoadTextureTyped_IO(), which is equivalent to this<br/>
		/// function except a file extension (like "BMP", "JPG", etc) can be specified,<br/>
		/// in case SDL_image cannot autodetect the file format.<br/>
		/// If you would rather decode an image to an SDL_Surface (a buffer of pixels<br/>
		/// in CPU memory), call IMG_Load() instead.<br/>
		/// When done with the returned texture, the app should dispose of it with a<br/>
		/// call to SDL_DestroyTexture().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadTexture_IO")]
		[return: NativeName(NativeNameType.Type, "SDL_Texture *")]
		public static SDLTexture* LoadTextureIO([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer *")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream src, [NativeName(NativeNameType.Param, "closeio")] [NativeName(NativeNameType.Type, "bool")] bool closeio)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLIOStream* psrc = &src)
				{
					SDLTexture* ret = LoadTextureIONative((SDLRenderer*)prenderer, (SDLIOStream*)psrc, closeio ? (byte)1 : (byte)0);
					return ret;
				}
			}
		}

		/// <summary>
		/// Load an image from an SDL data source into a GPU texture.<br/>
		/// An SDL_Texture represents an image in GPU memory, usable by SDL's 2D Render<br/>
		/// API. This can be significantly more efficient than using a CPU-bound<br/>
		/// SDL_Surface if you don't need to manipulate the image directly after<br/>
		/// loading it.<br/>
		/// If the loaded image has transparency or a colorkey, a texture with an alpha<br/>
		/// channel will be created. Otherwise, SDL_image will attempt to create an<br/>
		/// SDL_Texture in the most format that most reasonably represents the image<br/>
		/// data (but in many cases, this will just end up being 32-bit RGB or 32-bit<br/>
		/// RGBA).<br/>
		/// If `closeio` is true, `src` will be closed before returning, whether this<br/>
		/// function succeeds or not. SDL_image reads everything it needs from `src`<br/>
		/// during this call in any case.<br/>
		/// Even though this function accepts a file type, SDL_image may still try<br/>
		/// other decoders that are capable of detecting file type from the contents of<br/>
		/// the image data, but may rely on the caller-provided type string for formats<br/>
		/// that it cannot autodetect. If `type` is NULL, SDL_image will rely solely on<br/>
		/// its ability to guess the format.<br/>
		/// There is a separate function to read files from disk without having to deal<br/>
		/// with SDL_IOStream: `IMG_LoadTexture("filename.jpg")` will call this<br/>
		/// function and manage those details for you, determining the file type from<br/>
		/// the filename's extension.<br/>
		/// There is also IMG_LoadTexture_IO(), which is equivalent to this function<br/>
		/// except that it will rely on SDL_image to determine what type of data it is<br/>
		/// loading, much like passing a NULL for type.<br/>
		/// If you would rather decode an image to an SDL_Surface (a buffer of pixels<br/>
		/// in CPU memory), call IMG_LoadTyped_IO() instead.<br/>
		/// When done with the returned texture, the app should dispose of it with a<br/>
		/// call to SDL_DestroyTexture().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadTextureTyped_IO")]
		[return: NativeName(NativeNameType.Type, "SDL_Texture *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLTexture* LoadTextureTypedIONative([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer *")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src, [NativeName(NativeNameType.Param, "closeio")] [NativeName(NativeNameType.Type, "bool")] byte closeio, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "char const *")] byte* type)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLRenderer*, SDLIOStream*, byte, byte*, SDLTexture*>)funcTable[6])(renderer, src, closeio, type);
			#else
			return (SDLTexture*)((delegate* unmanaged[Cdecl]<nint, nint, byte, nint, nint>)funcTable[6])((nint)renderer, (nint)src, closeio, (nint)type);
			#endif
		}

		/// <summary>
		/// Load an image from an SDL data source into a GPU texture.<br/>
		/// An SDL_Texture represents an image in GPU memory, usable by SDL's 2D Render<br/>
		/// API. This can be significantly more efficient than using a CPU-bound<br/>
		/// SDL_Surface if you don't need to manipulate the image directly after<br/>
		/// loading it.<br/>
		/// If the loaded image has transparency or a colorkey, a texture with an alpha<br/>
		/// channel will be created. Otherwise, SDL_image will attempt to create an<br/>
		/// SDL_Texture in the most format that most reasonably represents the image<br/>
		/// data (but in many cases, this will just end up being 32-bit RGB or 32-bit<br/>
		/// RGBA).<br/>
		/// If `closeio` is true, `src` will be closed before returning, whether this<br/>
		/// function succeeds or not. SDL_image reads everything it needs from `src`<br/>
		/// during this call in any case.<br/>
		/// Even though this function accepts a file type, SDL_image may still try<br/>
		/// other decoders that are capable of detecting file type from the contents of<br/>
		/// the image data, but may rely on the caller-provided type string for formats<br/>
		/// that it cannot autodetect. If `type` is NULL, SDL_image will rely solely on<br/>
		/// its ability to guess the format.<br/>
		/// There is a separate function to read files from disk without having to deal<br/>
		/// with SDL_IOStream: `IMG_LoadTexture("filename.jpg")` will call this<br/>
		/// function and manage those details for you, determining the file type from<br/>
		/// the filename's extension.<br/>
		/// There is also IMG_LoadTexture_IO(), which is equivalent to this function<br/>
		/// except that it will rely on SDL_image to determine what type of data it is<br/>
		/// loading, much like passing a NULL for type.<br/>
		/// If you would rather decode an image to an SDL_Surface (a buffer of pixels<br/>
		/// in CPU memory), call IMG_LoadTyped_IO() instead.<br/>
		/// When done with the returned texture, the app should dispose of it with a<br/>
		/// call to SDL_DestroyTexture().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadTextureTyped_IO")]
		[return: NativeName(NativeNameType.Type, "SDL_Texture *")]
		public static SDLTexture* LoadTextureTypedIO([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer *")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src, [NativeName(NativeNameType.Param, "closeio")] [NativeName(NativeNameType.Type, "bool")] bool closeio, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "char const *")] byte* type)
		{
			SDLTexture* ret = LoadTextureTypedIONative(renderer, src, closeio ? (byte)1 : (byte)0, type);
			return ret;
		}

		/// <summary>
		/// Load an image from an SDL data source into a GPU texture.<br/>
		/// An SDL_Texture represents an image in GPU memory, usable by SDL's 2D Render<br/>
		/// API. This can be significantly more efficient than using a CPU-bound<br/>
		/// SDL_Surface if you don't need to manipulate the image directly after<br/>
		/// loading it.<br/>
		/// If the loaded image has transparency or a colorkey, a texture with an alpha<br/>
		/// channel will be created. Otherwise, SDL_image will attempt to create an<br/>
		/// SDL_Texture in the most format that most reasonably represents the image<br/>
		/// data (but in many cases, this will just end up being 32-bit RGB or 32-bit<br/>
		/// RGBA).<br/>
		/// If `closeio` is true, `src` will be closed before returning, whether this<br/>
		/// function succeeds or not. SDL_image reads everything it needs from `src`<br/>
		/// during this call in any case.<br/>
		/// Even though this function accepts a file type, SDL_image may still try<br/>
		/// other decoders that are capable of detecting file type from the contents of<br/>
		/// the image data, but may rely on the caller-provided type string for formats<br/>
		/// that it cannot autodetect. If `type` is NULL, SDL_image will rely solely on<br/>
		/// its ability to guess the format.<br/>
		/// There is a separate function to read files from disk without having to deal<br/>
		/// with SDL_IOStream: `IMG_LoadTexture("filename.jpg")` will call this<br/>
		/// function and manage those details for you, determining the file type from<br/>
		/// the filename's extension.<br/>
		/// There is also IMG_LoadTexture_IO(), which is equivalent to this function<br/>
		/// except that it will rely on SDL_image to determine what type of data it is<br/>
		/// loading, much like passing a NULL for type.<br/>
		/// If you would rather decode an image to an SDL_Surface (a buffer of pixels<br/>
		/// in CPU memory), call IMG_LoadTyped_IO() instead.<br/>
		/// When done with the returned texture, the app should dispose of it with a<br/>
		/// call to SDL_DestroyTexture().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadTextureTyped_IO")]
		[return: NativeName(NativeNameType.Type, "SDL_Texture *")]
		public static SDLTexture* LoadTextureTypedIO([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer *")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src, [NativeName(NativeNameType.Param, "closeio")] [NativeName(NativeNameType.Type, "bool")] bool closeio, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "char const *")] byte* type)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				SDLTexture* ret = LoadTextureTypedIONative((SDLRenderer*)prenderer, src, closeio ? (byte)1 : (byte)0, type);
				return ret;
			}
		}

		/// <summary>
		/// Load an image from an SDL data source into a GPU texture.<br/>
		/// An SDL_Texture represents an image in GPU memory, usable by SDL's 2D Render<br/>
		/// API. This can be significantly more efficient than using a CPU-bound<br/>
		/// SDL_Surface if you don't need to manipulate the image directly after<br/>
		/// loading it.<br/>
		/// If the loaded image has transparency or a colorkey, a texture with an alpha<br/>
		/// channel will be created. Otherwise, SDL_image will attempt to create an<br/>
		/// SDL_Texture in the most format that most reasonably represents the image<br/>
		/// data (but in many cases, this will just end up being 32-bit RGB or 32-bit<br/>
		/// RGBA).<br/>
		/// If `closeio` is true, `src` will be closed before returning, whether this<br/>
		/// function succeeds or not. SDL_image reads everything it needs from `src`<br/>
		/// during this call in any case.<br/>
		/// Even though this function accepts a file type, SDL_image may still try<br/>
		/// other decoders that are capable of detecting file type from the contents of<br/>
		/// the image data, but may rely on the caller-provided type string for formats<br/>
		/// that it cannot autodetect. If `type` is NULL, SDL_image will rely solely on<br/>
		/// its ability to guess the format.<br/>
		/// There is a separate function to read files from disk without having to deal<br/>
		/// with SDL_IOStream: `IMG_LoadTexture("filename.jpg")` will call this<br/>
		/// function and manage those details for you, determining the file type from<br/>
		/// the filename's extension.<br/>
		/// There is also IMG_LoadTexture_IO(), which is equivalent to this function<br/>
		/// except that it will rely on SDL_image to determine what type of data it is<br/>
		/// loading, much like passing a NULL for type.<br/>
		/// If you would rather decode an image to an SDL_Surface (a buffer of pixels<br/>
		/// in CPU memory), call IMG_LoadTyped_IO() instead.<br/>
		/// When done with the returned texture, the app should dispose of it with a<br/>
		/// call to SDL_DestroyTexture().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadTextureTyped_IO")]
		[return: NativeName(NativeNameType.Type, "SDL_Texture *")]
		public static SDLTexture* LoadTextureTypedIO([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer *")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream src, [NativeName(NativeNameType.Param, "closeio")] [NativeName(NativeNameType.Type, "bool")] bool closeio, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "char const *")] byte* type)
		{
			fixed (SDLIOStream* psrc = &src)
			{
				SDLTexture* ret = LoadTextureTypedIONative(renderer, (SDLIOStream*)psrc, closeio ? (byte)1 : (byte)0, type);
				return ret;
			}
		}

		/// <summary>
		/// Load an image from an SDL data source into a GPU texture.<br/>
		/// An SDL_Texture represents an image in GPU memory, usable by SDL's 2D Render<br/>
		/// API. This can be significantly more efficient than using a CPU-bound<br/>
		/// SDL_Surface if you don't need to manipulate the image directly after<br/>
		/// loading it.<br/>
		/// If the loaded image has transparency or a colorkey, a texture with an alpha<br/>
		/// channel will be created. Otherwise, SDL_image will attempt to create an<br/>
		/// SDL_Texture in the most format that most reasonably represents the image<br/>
		/// data (but in many cases, this will just end up being 32-bit RGB or 32-bit<br/>
		/// RGBA).<br/>
		/// If `closeio` is true, `src` will be closed before returning, whether this<br/>
		/// function succeeds or not. SDL_image reads everything it needs from `src`<br/>
		/// during this call in any case.<br/>
		/// Even though this function accepts a file type, SDL_image may still try<br/>
		/// other decoders that are capable of detecting file type from the contents of<br/>
		/// the image data, but may rely on the caller-provided type string for formats<br/>
		/// that it cannot autodetect. If `type` is NULL, SDL_image will rely solely on<br/>
		/// its ability to guess the format.<br/>
		/// There is a separate function to read files from disk without having to deal<br/>
		/// with SDL_IOStream: `IMG_LoadTexture("filename.jpg")` will call this<br/>
		/// function and manage those details for you, determining the file type from<br/>
		/// the filename's extension.<br/>
		/// There is also IMG_LoadTexture_IO(), which is equivalent to this function<br/>
		/// except that it will rely on SDL_image to determine what type of data it is<br/>
		/// loading, much like passing a NULL for type.<br/>
		/// If you would rather decode an image to an SDL_Surface (a buffer of pixels<br/>
		/// in CPU memory), call IMG_LoadTyped_IO() instead.<br/>
		/// When done with the returned texture, the app should dispose of it with a<br/>
		/// call to SDL_DestroyTexture().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadTextureTyped_IO")]
		[return: NativeName(NativeNameType.Type, "SDL_Texture *")]
		public static SDLTexture* LoadTextureTypedIO([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer *")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream src, [NativeName(NativeNameType.Param, "closeio")] [NativeName(NativeNameType.Type, "bool")] bool closeio, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "char const *")] byte* type)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLIOStream* psrc = &src)
				{
					SDLTexture* ret = LoadTextureTypedIONative((SDLRenderer*)prenderer, (SDLIOStream*)psrc, closeio ? (byte)1 : (byte)0, type);
					return ret;
				}
			}
		}

		/// <summary>
		/// Load an image from an SDL data source into a GPU texture.<br/>
		/// An SDL_Texture represents an image in GPU memory, usable by SDL's 2D Render<br/>
		/// API. This can be significantly more efficient than using a CPU-bound<br/>
		/// SDL_Surface if you don't need to manipulate the image directly after<br/>
		/// loading it.<br/>
		/// If the loaded image has transparency or a colorkey, a texture with an alpha<br/>
		/// channel will be created. Otherwise, SDL_image will attempt to create an<br/>
		/// SDL_Texture in the most format that most reasonably represents the image<br/>
		/// data (but in many cases, this will just end up being 32-bit RGB or 32-bit<br/>
		/// RGBA).<br/>
		/// If `closeio` is true, `src` will be closed before returning, whether this<br/>
		/// function succeeds or not. SDL_image reads everything it needs from `src`<br/>
		/// during this call in any case.<br/>
		/// Even though this function accepts a file type, SDL_image may still try<br/>
		/// other decoders that are capable of detecting file type from the contents of<br/>
		/// the image data, but may rely on the caller-provided type string for formats<br/>
		/// that it cannot autodetect. If `type` is NULL, SDL_image will rely solely on<br/>
		/// its ability to guess the format.<br/>
		/// There is a separate function to read files from disk without having to deal<br/>
		/// with SDL_IOStream: `IMG_LoadTexture("filename.jpg")` will call this<br/>
		/// function and manage those details for you, determining the file type from<br/>
		/// the filename's extension.<br/>
		/// There is also IMG_LoadTexture_IO(), which is equivalent to this function<br/>
		/// except that it will rely on SDL_image to determine what type of data it is<br/>
		/// loading, much like passing a NULL for type.<br/>
		/// If you would rather decode an image to an SDL_Surface (a buffer of pixels<br/>
		/// in CPU memory), call IMG_LoadTyped_IO() instead.<br/>
		/// When done with the returned texture, the app should dispose of it with a<br/>
		/// call to SDL_DestroyTexture().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadTextureTyped_IO")]
		[return: NativeName(NativeNameType.Type, "SDL_Texture *")]
		public static SDLTexture* LoadTextureTypedIO([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer *")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src, [NativeName(NativeNameType.Param, "closeio")] [NativeName(NativeNameType.Type, "bool")] bool closeio, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "char const *")] ref byte type)
		{
			fixed (byte* ptype = &type)
			{
				SDLTexture* ret = LoadTextureTypedIONative(renderer, src, closeio ? (byte)1 : (byte)0, (byte*)ptype);
				return ret;
			}
		}

		/// <summary>
		/// Load an image from an SDL data source into a GPU texture.<br/>
		/// An SDL_Texture represents an image in GPU memory, usable by SDL's 2D Render<br/>
		/// API. This can be significantly more efficient than using a CPU-bound<br/>
		/// SDL_Surface if you don't need to manipulate the image directly after<br/>
		/// loading it.<br/>
		/// If the loaded image has transparency or a colorkey, a texture with an alpha<br/>
		/// channel will be created. Otherwise, SDL_image will attempt to create an<br/>
		/// SDL_Texture in the most format that most reasonably represents the image<br/>
		/// data (but in many cases, this will just end up being 32-bit RGB or 32-bit<br/>
		/// RGBA).<br/>
		/// If `closeio` is true, `src` will be closed before returning, whether this<br/>
		/// function succeeds or not. SDL_image reads everything it needs from `src`<br/>
		/// during this call in any case.<br/>
		/// Even though this function accepts a file type, SDL_image may still try<br/>
		/// other decoders that are capable of detecting file type from the contents of<br/>
		/// the image data, but may rely on the caller-provided type string for formats<br/>
		/// that it cannot autodetect. If `type` is NULL, SDL_image will rely solely on<br/>
		/// its ability to guess the format.<br/>
		/// There is a separate function to read files from disk without having to deal<br/>
		/// with SDL_IOStream: `IMG_LoadTexture("filename.jpg")` will call this<br/>
		/// function and manage those details for you, determining the file type from<br/>
		/// the filename's extension.<br/>
		/// There is also IMG_LoadTexture_IO(), which is equivalent to this function<br/>
		/// except that it will rely on SDL_image to determine what type of data it is<br/>
		/// loading, much like passing a NULL for type.<br/>
		/// If you would rather decode an image to an SDL_Surface (a buffer of pixels<br/>
		/// in CPU memory), call IMG_LoadTyped_IO() instead.<br/>
		/// When done with the returned texture, the app should dispose of it with a<br/>
		/// call to SDL_DestroyTexture().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadTextureTyped_IO")]
		[return: NativeName(NativeNameType.Type, "SDL_Texture *")]
		public static SDLTexture* LoadTextureTypedIO([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer *")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src, [NativeName(NativeNameType.Param, "closeio")] [NativeName(NativeNameType.Type, "bool")] bool closeio, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> type)
		{
			fixed (byte* ptype = type)
			{
				SDLTexture* ret = LoadTextureTypedIONative(renderer, src, closeio ? (byte)1 : (byte)0, (byte*)ptype);
				return ret;
			}
		}

		/// <summary>
		/// Load an image from an SDL data source into a GPU texture.<br/>
		/// An SDL_Texture represents an image in GPU memory, usable by SDL's 2D Render<br/>
		/// API. This can be significantly more efficient than using a CPU-bound<br/>
		/// SDL_Surface if you don't need to manipulate the image directly after<br/>
		/// loading it.<br/>
		/// If the loaded image has transparency or a colorkey, a texture with an alpha<br/>
		/// channel will be created. Otherwise, SDL_image will attempt to create an<br/>
		/// SDL_Texture in the most format that most reasonably represents the image<br/>
		/// data (but in many cases, this will just end up being 32-bit RGB or 32-bit<br/>
		/// RGBA).<br/>
		/// If `closeio` is true, `src` will be closed before returning, whether this<br/>
		/// function succeeds or not. SDL_image reads everything it needs from `src`<br/>
		/// during this call in any case.<br/>
		/// Even though this function accepts a file type, SDL_image may still try<br/>
		/// other decoders that are capable of detecting file type from the contents of<br/>
		/// the image data, but may rely on the caller-provided type string for formats<br/>
		/// that it cannot autodetect. If `type` is NULL, SDL_image will rely solely on<br/>
		/// its ability to guess the format.<br/>
		/// There is a separate function to read files from disk without having to deal<br/>
		/// with SDL_IOStream: `IMG_LoadTexture("filename.jpg")` will call this<br/>
		/// function and manage those details for you, determining the file type from<br/>
		/// the filename's extension.<br/>
		/// There is also IMG_LoadTexture_IO(), which is equivalent to this function<br/>
		/// except that it will rely on SDL_image to determine what type of data it is<br/>
		/// loading, much like passing a NULL for type.<br/>
		/// If you would rather decode an image to an SDL_Surface (a buffer of pixels<br/>
		/// in CPU memory), call IMG_LoadTyped_IO() instead.<br/>
		/// When done with the returned texture, the app should dispose of it with a<br/>
		/// call to SDL_DestroyTexture().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadTextureTyped_IO")]
		[return: NativeName(NativeNameType.Type, "SDL_Texture *")]
		public static SDLTexture* LoadTextureTypedIO([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer *")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src, [NativeName(NativeNameType.Param, "closeio")] [NativeName(NativeNameType.Type, "bool")] bool closeio, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "char const *")] string type)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (type != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(type);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(type, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SDLTexture* ret = LoadTextureTypedIONative(renderer, src, closeio ? (byte)1 : (byte)0, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Load an image from an SDL data source into a GPU texture.<br/>
		/// An SDL_Texture represents an image in GPU memory, usable by SDL's 2D Render<br/>
		/// API. This can be significantly more efficient than using a CPU-bound<br/>
		/// SDL_Surface if you don't need to manipulate the image directly after<br/>
		/// loading it.<br/>
		/// If the loaded image has transparency or a colorkey, a texture with an alpha<br/>
		/// channel will be created. Otherwise, SDL_image will attempt to create an<br/>
		/// SDL_Texture in the most format that most reasonably represents the image<br/>
		/// data (but in many cases, this will just end up being 32-bit RGB or 32-bit<br/>
		/// RGBA).<br/>
		/// If `closeio` is true, `src` will be closed before returning, whether this<br/>
		/// function succeeds or not. SDL_image reads everything it needs from `src`<br/>
		/// during this call in any case.<br/>
		/// Even though this function accepts a file type, SDL_image may still try<br/>
		/// other decoders that are capable of detecting file type from the contents of<br/>
		/// the image data, but may rely on the caller-provided type string for formats<br/>
		/// that it cannot autodetect. If `type` is NULL, SDL_image will rely solely on<br/>
		/// its ability to guess the format.<br/>
		/// There is a separate function to read files from disk without having to deal<br/>
		/// with SDL_IOStream: `IMG_LoadTexture("filename.jpg")` will call this<br/>
		/// function and manage those details for you, determining the file type from<br/>
		/// the filename's extension.<br/>
		/// There is also IMG_LoadTexture_IO(), which is equivalent to this function<br/>
		/// except that it will rely on SDL_image to determine what type of data it is<br/>
		/// loading, much like passing a NULL for type.<br/>
		/// If you would rather decode an image to an SDL_Surface (a buffer of pixels<br/>
		/// in CPU memory), call IMG_LoadTyped_IO() instead.<br/>
		/// When done with the returned texture, the app should dispose of it with a<br/>
		/// call to SDL_DestroyTexture().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadTextureTyped_IO")]
		[return: NativeName(NativeNameType.Type, "SDL_Texture *")]
		public static SDLTexture* LoadTextureTypedIO([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer *")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src, [NativeName(NativeNameType.Param, "closeio")] [NativeName(NativeNameType.Type, "bool")] bool closeio, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "char const *")] ref byte type)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (byte* ptype = &type)
				{
					SDLTexture* ret = LoadTextureTypedIONative((SDLRenderer*)prenderer, src, closeio ? (byte)1 : (byte)0, (byte*)ptype);
					return ret;
				}
			}
		}

		/// <summary>
		/// Load an image from an SDL data source into a GPU texture.<br/>
		/// An SDL_Texture represents an image in GPU memory, usable by SDL's 2D Render<br/>
		/// API. This can be significantly more efficient than using a CPU-bound<br/>
		/// SDL_Surface if you don't need to manipulate the image directly after<br/>
		/// loading it.<br/>
		/// If the loaded image has transparency or a colorkey, a texture with an alpha<br/>
		/// channel will be created. Otherwise, SDL_image will attempt to create an<br/>
		/// SDL_Texture in the most format that most reasonably represents the image<br/>
		/// data (but in many cases, this will just end up being 32-bit RGB or 32-bit<br/>
		/// RGBA).<br/>
		/// If `closeio` is true, `src` will be closed before returning, whether this<br/>
		/// function succeeds or not. SDL_image reads everything it needs from `src`<br/>
		/// during this call in any case.<br/>
		/// Even though this function accepts a file type, SDL_image may still try<br/>
		/// other decoders that are capable of detecting file type from the contents of<br/>
		/// the image data, but may rely on the caller-provided type string for formats<br/>
		/// that it cannot autodetect. If `type` is NULL, SDL_image will rely solely on<br/>
		/// its ability to guess the format.<br/>
		/// There is a separate function to read files from disk without having to deal<br/>
		/// with SDL_IOStream: `IMG_LoadTexture("filename.jpg")` will call this<br/>
		/// function and manage those details for you, determining the file type from<br/>
		/// the filename's extension.<br/>
		/// There is also IMG_LoadTexture_IO(), which is equivalent to this function<br/>
		/// except that it will rely on SDL_image to determine what type of data it is<br/>
		/// loading, much like passing a NULL for type.<br/>
		/// If you would rather decode an image to an SDL_Surface (a buffer of pixels<br/>
		/// in CPU memory), call IMG_LoadTyped_IO() instead.<br/>
		/// When done with the returned texture, the app should dispose of it with a<br/>
		/// call to SDL_DestroyTexture().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadTextureTyped_IO")]
		[return: NativeName(NativeNameType.Type, "SDL_Texture *")]
		public static SDLTexture* LoadTextureTypedIO([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer *")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src, [NativeName(NativeNameType.Param, "closeio")] [NativeName(NativeNameType.Type, "bool")] bool closeio, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> type)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (byte* ptype = type)
				{
					SDLTexture* ret = LoadTextureTypedIONative((SDLRenderer*)prenderer, src, closeio ? (byte)1 : (byte)0, (byte*)ptype);
					return ret;
				}
			}
		}

		/// <summary>
		/// Load an image from an SDL data source into a GPU texture.<br/>
		/// An SDL_Texture represents an image in GPU memory, usable by SDL's 2D Render<br/>
		/// API. This can be significantly more efficient than using a CPU-bound<br/>
		/// SDL_Surface if you don't need to manipulate the image directly after<br/>
		/// loading it.<br/>
		/// If the loaded image has transparency or a colorkey, a texture with an alpha<br/>
		/// channel will be created. Otherwise, SDL_image will attempt to create an<br/>
		/// SDL_Texture in the most format that most reasonably represents the image<br/>
		/// data (but in many cases, this will just end up being 32-bit RGB or 32-bit<br/>
		/// RGBA).<br/>
		/// If `closeio` is true, `src` will be closed before returning, whether this<br/>
		/// function succeeds or not. SDL_image reads everything it needs from `src`<br/>
		/// during this call in any case.<br/>
		/// Even though this function accepts a file type, SDL_image may still try<br/>
		/// other decoders that are capable of detecting file type from the contents of<br/>
		/// the image data, but may rely on the caller-provided type string for formats<br/>
		/// that it cannot autodetect. If `type` is NULL, SDL_image will rely solely on<br/>
		/// its ability to guess the format.<br/>
		/// There is a separate function to read files from disk without having to deal<br/>
		/// with SDL_IOStream: `IMG_LoadTexture("filename.jpg")` will call this<br/>
		/// function and manage those details for you, determining the file type from<br/>
		/// the filename's extension.<br/>
		/// There is also IMG_LoadTexture_IO(), which is equivalent to this function<br/>
		/// except that it will rely on SDL_image to determine what type of data it is<br/>
		/// loading, much like passing a NULL for type.<br/>
		/// If you would rather decode an image to an SDL_Surface (a buffer of pixels<br/>
		/// in CPU memory), call IMG_LoadTyped_IO() instead.<br/>
		/// When done with the returned texture, the app should dispose of it with a<br/>
		/// call to SDL_DestroyTexture().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadTextureTyped_IO")]
		[return: NativeName(NativeNameType.Type, "SDL_Texture *")]
		public static SDLTexture* LoadTextureTypedIO([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer *")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src, [NativeName(NativeNameType.Param, "closeio")] [NativeName(NativeNameType.Type, "bool")] bool closeio, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "char const *")] string type)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (type != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(type);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(type, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				SDLTexture* ret = LoadTextureTypedIONative((SDLRenderer*)prenderer, src, closeio ? (byte)1 : (byte)0, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// Load an image from an SDL data source into a GPU texture.<br/>
		/// An SDL_Texture represents an image in GPU memory, usable by SDL's 2D Render<br/>
		/// API. This can be significantly more efficient than using a CPU-bound<br/>
		/// SDL_Surface if you don't need to manipulate the image directly after<br/>
		/// loading it.<br/>
		/// If the loaded image has transparency or a colorkey, a texture with an alpha<br/>
		/// channel will be created. Otherwise, SDL_image will attempt to create an<br/>
		/// SDL_Texture in the most format that most reasonably represents the image<br/>
		/// data (but in many cases, this will just end up being 32-bit RGB or 32-bit<br/>
		/// RGBA).<br/>
		/// If `closeio` is true, `src` will be closed before returning, whether this<br/>
		/// function succeeds or not. SDL_image reads everything it needs from `src`<br/>
		/// during this call in any case.<br/>
		/// Even though this function accepts a file type, SDL_image may still try<br/>
		/// other decoders that are capable of detecting file type from the contents of<br/>
		/// the image data, but may rely on the caller-provided type string for formats<br/>
		/// that it cannot autodetect. If `type` is NULL, SDL_image will rely solely on<br/>
		/// its ability to guess the format.<br/>
		/// There is a separate function to read files from disk without having to deal<br/>
		/// with SDL_IOStream: `IMG_LoadTexture("filename.jpg")` will call this<br/>
		/// function and manage those details for you, determining the file type from<br/>
		/// the filename's extension.<br/>
		/// There is also IMG_LoadTexture_IO(), which is equivalent to this function<br/>
		/// except that it will rely on SDL_image to determine what type of data it is<br/>
		/// loading, much like passing a NULL for type.<br/>
		/// If you would rather decode an image to an SDL_Surface (a buffer of pixels<br/>
		/// in CPU memory), call IMG_LoadTyped_IO() instead.<br/>
		/// When done with the returned texture, the app should dispose of it with a<br/>
		/// call to SDL_DestroyTexture().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadTextureTyped_IO")]
		[return: NativeName(NativeNameType.Type, "SDL_Texture *")]
		public static SDLTexture* LoadTextureTypedIO([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer *")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream src, [NativeName(NativeNameType.Param, "closeio")] [NativeName(NativeNameType.Type, "bool")] bool closeio, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "char const *")] ref byte type)
		{
			fixed (SDLIOStream* psrc = &src)
			{
				fixed (byte* ptype = &type)
				{
					SDLTexture* ret = LoadTextureTypedIONative(renderer, (SDLIOStream*)psrc, closeio ? (byte)1 : (byte)0, (byte*)ptype);
					return ret;
				}
			}
		}

		/// <summary>
		/// Load an image from an SDL data source into a GPU texture.<br/>
		/// An SDL_Texture represents an image in GPU memory, usable by SDL's 2D Render<br/>
		/// API. This can be significantly more efficient than using a CPU-bound<br/>
		/// SDL_Surface if you don't need to manipulate the image directly after<br/>
		/// loading it.<br/>
		/// If the loaded image has transparency or a colorkey, a texture with an alpha<br/>
		/// channel will be created. Otherwise, SDL_image will attempt to create an<br/>
		/// SDL_Texture in the most format that most reasonably represents the image<br/>
		/// data (but in many cases, this will just end up being 32-bit RGB or 32-bit<br/>
		/// RGBA).<br/>
		/// If `closeio` is true, `src` will be closed before returning, whether this<br/>
		/// function succeeds or not. SDL_image reads everything it needs from `src`<br/>
		/// during this call in any case.<br/>
		/// Even though this function accepts a file type, SDL_image may still try<br/>
		/// other decoders that are capable of detecting file type from the contents of<br/>
		/// the image data, but may rely on the caller-provided type string for formats<br/>
		/// that it cannot autodetect. If `type` is NULL, SDL_image will rely solely on<br/>
		/// its ability to guess the format.<br/>
		/// There is a separate function to read files from disk without having to deal<br/>
		/// with SDL_IOStream: `IMG_LoadTexture("filename.jpg")` will call this<br/>
		/// function and manage those details for you, determining the file type from<br/>
		/// the filename's extension.<br/>
		/// There is also IMG_LoadTexture_IO(), which is equivalent to this function<br/>
		/// except that it will rely on SDL_image to determine what type of data it is<br/>
		/// loading, much like passing a NULL for type.<br/>
		/// If you would rather decode an image to an SDL_Surface (a buffer of pixels<br/>
		/// in CPU memory), call IMG_LoadTyped_IO() instead.<br/>
		/// When done with the returned texture, the app should dispose of it with a<br/>
		/// call to SDL_DestroyTexture().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadTextureTyped_IO")]
		[return: NativeName(NativeNameType.Type, "SDL_Texture *")]
		public static SDLTexture* LoadTextureTypedIO([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer *")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream src, [NativeName(NativeNameType.Param, "closeio")] [NativeName(NativeNameType.Type, "bool")] bool closeio, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> type)
		{
			fixed (SDLIOStream* psrc = &src)
			{
				fixed (byte* ptype = type)
				{
					SDLTexture* ret = LoadTextureTypedIONative(renderer, (SDLIOStream*)psrc, closeio ? (byte)1 : (byte)0, (byte*)ptype);
					return ret;
				}
			}
		}

		/// <summary>
		/// Load an image from an SDL data source into a GPU texture.<br/>
		/// An SDL_Texture represents an image in GPU memory, usable by SDL's 2D Render<br/>
		/// API. This can be significantly more efficient than using a CPU-bound<br/>
		/// SDL_Surface if you don't need to manipulate the image directly after<br/>
		/// loading it.<br/>
		/// If the loaded image has transparency or a colorkey, a texture with an alpha<br/>
		/// channel will be created. Otherwise, SDL_image will attempt to create an<br/>
		/// SDL_Texture in the most format that most reasonably represents the image<br/>
		/// data (but in many cases, this will just end up being 32-bit RGB or 32-bit<br/>
		/// RGBA).<br/>
		/// If `closeio` is true, `src` will be closed before returning, whether this<br/>
		/// function succeeds or not. SDL_image reads everything it needs from `src`<br/>
		/// during this call in any case.<br/>
		/// Even though this function accepts a file type, SDL_image may still try<br/>
		/// other decoders that are capable of detecting file type from the contents of<br/>
		/// the image data, but may rely on the caller-provided type string for formats<br/>
		/// that it cannot autodetect. If `type` is NULL, SDL_image will rely solely on<br/>
		/// its ability to guess the format.<br/>
		/// There is a separate function to read files from disk without having to deal<br/>
		/// with SDL_IOStream: `IMG_LoadTexture("filename.jpg")` will call this<br/>
		/// function and manage those details for you, determining the file type from<br/>
		/// the filename's extension.<br/>
		/// There is also IMG_LoadTexture_IO(), which is equivalent to this function<br/>
		/// except that it will rely on SDL_image to determine what type of data it is<br/>
		/// loading, much like passing a NULL for type.<br/>
		/// If you would rather decode an image to an SDL_Surface (a buffer of pixels<br/>
		/// in CPU memory), call IMG_LoadTyped_IO() instead.<br/>
		/// When done with the returned texture, the app should dispose of it with a<br/>
		/// call to SDL_DestroyTexture().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadTextureTyped_IO")]
		[return: NativeName(NativeNameType.Type, "SDL_Texture *")]
		public static SDLTexture* LoadTextureTypedIO([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer *")] SDLRenderer* renderer, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream src, [NativeName(NativeNameType.Param, "closeio")] [NativeName(NativeNameType.Type, "bool")] bool closeio, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "char const *")] string type)
		{
			fixed (SDLIOStream* psrc = &src)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (type != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(type);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(type, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				SDLTexture* ret = LoadTextureTypedIONative(renderer, (SDLIOStream*)psrc, closeio ? (byte)1 : (byte)0, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// Load an image from an SDL data source into a GPU texture.<br/>
		/// An SDL_Texture represents an image in GPU memory, usable by SDL's 2D Render<br/>
		/// API. This can be significantly more efficient than using a CPU-bound<br/>
		/// SDL_Surface if you don't need to manipulate the image directly after<br/>
		/// loading it.<br/>
		/// If the loaded image has transparency or a colorkey, a texture with an alpha<br/>
		/// channel will be created. Otherwise, SDL_image will attempt to create an<br/>
		/// SDL_Texture in the most format that most reasonably represents the image<br/>
		/// data (but in many cases, this will just end up being 32-bit RGB or 32-bit<br/>
		/// RGBA).<br/>
		/// If `closeio` is true, `src` will be closed before returning, whether this<br/>
		/// function succeeds or not. SDL_image reads everything it needs from `src`<br/>
		/// during this call in any case.<br/>
		/// Even though this function accepts a file type, SDL_image may still try<br/>
		/// other decoders that are capable of detecting file type from the contents of<br/>
		/// the image data, but may rely on the caller-provided type string for formats<br/>
		/// that it cannot autodetect. If `type` is NULL, SDL_image will rely solely on<br/>
		/// its ability to guess the format.<br/>
		/// There is a separate function to read files from disk without having to deal<br/>
		/// with SDL_IOStream: `IMG_LoadTexture("filename.jpg")` will call this<br/>
		/// function and manage those details for you, determining the file type from<br/>
		/// the filename's extension.<br/>
		/// There is also IMG_LoadTexture_IO(), which is equivalent to this function<br/>
		/// except that it will rely on SDL_image to determine what type of data it is<br/>
		/// loading, much like passing a NULL for type.<br/>
		/// If you would rather decode an image to an SDL_Surface (a buffer of pixels<br/>
		/// in CPU memory), call IMG_LoadTyped_IO() instead.<br/>
		/// When done with the returned texture, the app should dispose of it with a<br/>
		/// call to SDL_DestroyTexture().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadTextureTyped_IO")]
		[return: NativeName(NativeNameType.Type, "SDL_Texture *")]
		public static SDLTexture* LoadTextureTypedIO([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer *")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream src, [NativeName(NativeNameType.Param, "closeio")] [NativeName(NativeNameType.Type, "bool")] bool closeio, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "char const *")] ref byte type)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLIOStream* psrc = &src)
				{
					fixed (byte* ptype = &type)
					{
						SDLTexture* ret = LoadTextureTypedIONative((SDLRenderer*)prenderer, (SDLIOStream*)psrc, closeio ? (byte)1 : (byte)0, (byte*)ptype);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Load an image from an SDL data source into a GPU texture.<br/>
		/// An SDL_Texture represents an image in GPU memory, usable by SDL's 2D Render<br/>
		/// API. This can be significantly more efficient than using a CPU-bound<br/>
		/// SDL_Surface if you don't need to manipulate the image directly after<br/>
		/// loading it.<br/>
		/// If the loaded image has transparency or a colorkey, a texture with an alpha<br/>
		/// channel will be created. Otherwise, SDL_image will attempt to create an<br/>
		/// SDL_Texture in the most format that most reasonably represents the image<br/>
		/// data (but in many cases, this will just end up being 32-bit RGB or 32-bit<br/>
		/// RGBA).<br/>
		/// If `closeio` is true, `src` will be closed before returning, whether this<br/>
		/// function succeeds or not. SDL_image reads everything it needs from `src`<br/>
		/// during this call in any case.<br/>
		/// Even though this function accepts a file type, SDL_image may still try<br/>
		/// other decoders that are capable of detecting file type from the contents of<br/>
		/// the image data, but may rely on the caller-provided type string for formats<br/>
		/// that it cannot autodetect. If `type` is NULL, SDL_image will rely solely on<br/>
		/// its ability to guess the format.<br/>
		/// There is a separate function to read files from disk without having to deal<br/>
		/// with SDL_IOStream: `IMG_LoadTexture("filename.jpg")` will call this<br/>
		/// function and manage those details for you, determining the file type from<br/>
		/// the filename's extension.<br/>
		/// There is also IMG_LoadTexture_IO(), which is equivalent to this function<br/>
		/// except that it will rely on SDL_image to determine what type of data it is<br/>
		/// loading, much like passing a NULL for type.<br/>
		/// If you would rather decode an image to an SDL_Surface (a buffer of pixels<br/>
		/// in CPU memory), call IMG_LoadTyped_IO() instead.<br/>
		/// When done with the returned texture, the app should dispose of it with a<br/>
		/// call to SDL_DestroyTexture().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadTextureTyped_IO")]
		[return: NativeName(NativeNameType.Type, "SDL_Texture *")]
		public static SDLTexture* LoadTextureTypedIO([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer *")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream src, [NativeName(NativeNameType.Param, "closeio")] [NativeName(NativeNameType.Type, "bool")] bool closeio, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> type)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLIOStream* psrc = &src)
				{
					fixed (byte* ptype = type)
					{
						SDLTexture* ret = LoadTextureTypedIONative((SDLRenderer*)prenderer, (SDLIOStream*)psrc, closeio ? (byte)1 : (byte)0, (byte*)ptype);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Load an image from an SDL data source into a GPU texture.<br/>
		/// An SDL_Texture represents an image in GPU memory, usable by SDL's 2D Render<br/>
		/// API. This can be significantly more efficient than using a CPU-bound<br/>
		/// SDL_Surface if you don't need to manipulate the image directly after<br/>
		/// loading it.<br/>
		/// If the loaded image has transparency or a colorkey, a texture with an alpha<br/>
		/// channel will be created. Otherwise, SDL_image will attempt to create an<br/>
		/// SDL_Texture in the most format that most reasonably represents the image<br/>
		/// data (but in many cases, this will just end up being 32-bit RGB or 32-bit<br/>
		/// RGBA).<br/>
		/// If `closeio` is true, `src` will be closed before returning, whether this<br/>
		/// function succeeds or not. SDL_image reads everything it needs from `src`<br/>
		/// during this call in any case.<br/>
		/// Even though this function accepts a file type, SDL_image may still try<br/>
		/// other decoders that are capable of detecting file type from the contents of<br/>
		/// the image data, but may rely on the caller-provided type string for formats<br/>
		/// that it cannot autodetect. If `type` is NULL, SDL_image will rely solely on<br/>
		/// its ability to guess the format.<br/>
		/// There is a separate function to read files from disk without having to deal<br/>
		/// with SDL_IOStream: `IMG_LoadTexture("filename.jpg")` will call this<br/>
		/// function and manage those details for you, determining the file type from<br/>
		/// the filename's extension.<br/>
		/// There is also IMG_LoadTexture_IO(), which is equivalent to this function<br/>
		/// except that it will rely on SDL_image to determine what type of data it is<br/>
		/// loading, much like passing a NULL for type.<br/>
		/// If you would rather decode an image to an SDL_Surface (a buffer of pixels<br/>
		/// in CPU memory), call IMG_LoadTyped_IO() instead.<br/>
		/// When done with the returned texture, the app should dispose of it with a<br/>
		/// call to SDL_DestroyTexture().<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadTextureTyped_IO")]
		[return: NativeName(NativeNameType.Type, "SDL_Texture *")]
		public static SDLTexture* LoadTextureTypedIO([NativeName(NativeNameType.Param, "renderer")] [NativeName(NativeNameType.Type, "SDL_Renderer *")] ref SDLRenderer renderer, [NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream src, [NativeName(NativeNameType.Param, "closeio")] [NativeName(NativeNameType.Type, "bool")] bool closeio, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "char const *")] string type)
		{
			fixed (SDLRenderer* prenderer = &renderer)
			{
				fixed (SDLIOStream* psrc = &src)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (type != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(type);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(type, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					SDLTexture* ret = LoadTextureTypedIONative((SDLRenderer*)prenderer, (SDLIOStream*)psrc, closeio ? (byte)1 : (byte)0, pStr0);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		/// <summary>
		/// Detect AVIF image data on a readable/seekable SDL_IOStream.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_IOStream (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek `src` back to where it started<br/>
		/// when this function was called, but it will not report any errors in doing<br/>
		/// so, but assuming seeking works, this means you can immediately use this<br/>
		/// with a different IMG_isTYPE function, or load the image without further<br/>
		/// seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isAVIF")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsAVIFNative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLIOStream*, byte>)funcTable[7])(src);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[7])((nint)src);
			#endif
		}

		/// <summary>
		/// Detect AVIF image data on a readable/seekable SDL_IOStream.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_IOStream (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek `src` back to where it started<br/>
		/// when this function was called, but it will not report any errors in doing<br/>
		/// so, but assuming seeking works, this means you can immediately use this<br/>
		/// with a different IMG_isTYPE function, or load the image without further<br/>
		/// seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isAVIF")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool IsAVIF([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src)
		{
			byte ret = IsAVIFNative(src);
			return ret != 0;
		}

		/// <summary>
		/// Detect AVIF image data on a readable/seekable SDL_IOStream.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_IOStream (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek `src` back to where it started<br/>
		/// when this function was called, but it will not report any errors in doing<br/>
		/// so, but assuming seeking works, this means you can immediately use this<br/>
		/// with a different IMG_isTYPE function, or load the image without further<br/>
		/// seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isAVIF")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool IsAVIF([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream src)
		{
			fixed (SDLIOStream* psrc = &src)
			{
				byte ret = IsAVIFNative((SDLIOStream*)psrc);
				return ret != 0;
			}
		}

		/// <summary>
		/// Detect ICO image data on a readable/seekable SDL_IOStream.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_IOStream (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek `src` back to where it started<br/>
		/// when this function was called, but it will not report any errors in doing<br/>
		/// so, but assuming seeking works, this means you can immediately use this<br/>
		/// with a different IMG_isTYPE function, or load the image without further<br/>
		/// seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isICO")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsICONative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLIOStream*, byte>)funcTable[8])(src);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[8])((nint)src);
			#endif
		}

		/// <summary>
		/// Detect ICO image data on a readable/seekable SDL_IOStream.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_IOStream (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek `src` back to where it started<br/>
		/// when this function was called, but it will not report any errors in doing<br/>
		/// so, but assuming seeking works, this means you can immediately use this<br/>
		/// with a different IMG_isTYPE function, or load the image without further<br/>
		/// seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isICO")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool IsICO([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src)
		{
			byte ret = IsICONative(src);
			return ret != 0;
		}

		/// <summary>
		/// Detect ICO image data on a readable/seekable SDL_IOStream.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_IOStream (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek `src` back to where it started<br/>
		/// when this function was called, but it will not report any errors in doing<br/>
		/// so, but assuming seeking works, this means you can immediately use this<br/>
		/// with a different IMG_isTYPE function, or load the image without further<br/>
		/// seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isICO")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool IsICO([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream src)
		{
			fixed (SDLIOStream* psrc = &src)
			{
				byte ret = IsICONative((SDLIOStream*)psrc);
				return ret != 0;
			}
		}

		/// <summary>
		/// Detect CUR image data on a readable/seekable SDL_IOStream.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_IOStream (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek `src` back to where it started<br/>
		/// when this function was called, but it will not report any errors in doing<br/>
		/// so, but assuming seeking works, this means you can immediately use this<br/>
		/// with a different IMG_isTYPE function, or load the image without further<br/>
		/// seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isCUR")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsCURNative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLIOStream*, byte>)funcTable[9])(src);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[9])((nint)src);
			#endif
		}

		/// <summary>
		/// Detect CUR image data on a readable/seekable SDL_IOStream.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_IOStream (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek `src` back to where it started<br/>
		/// when this function was called, but it will not report any errors in doing<br/>
		/// so, but assuming seeking works, this means you can immediately use this<br/>
		/// with a different IMG_isTYPE function, or load the image without further<br/>
		/// seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isCUR")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool IsCUR([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src)
		{
			byte ret = IsCURNative(src);
			return ret != 0;
		}

		/// <summary>
		/// Detect CUR image data on a readable/seekable SDL_IOStream.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_IOStream (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek `src` back to where it started<br/>
		/// when this function was called, but it will not report any errors in doing<br/>
		/// so, but assuming seeking works, this means you can immediately use this<br/>
		/// with a different IMG_isTYPE function, or load the image without further<br/>
		/// seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isCUR")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool IsCUR([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream src)
		{
			fixed (SDLIOStream* psrc = &src)
			{
				byte ret = IsCURNative((SDLIOStream*)psrc);
				return ret != 0;
			}
		}

		/// <summary>
		/// Detect BMP image data on a readable/seekable SDL_IOStream.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_IOStream (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek `src` back to where it started<br/>
		/// when this function was called, but it will not report any errors in doing<br/>
		/// so, but assuming seeking works, this means you can immediately use this<br/>
		/// with a different IMG_isTYPE function, or load the image without further<br/>
		/// seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isBMP")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsBMPNative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLIOStream*, byte>)funcTable[10])(src);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[10])((nint)src);
			#endif
		}

		/// <summary>
		/// Detect BMP image data on a readable/seekable SDL_IOStream.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_IOStream (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek `src` back to where it started<br/>
		/// when this function was called, but it will not report any errors in doing<br/>
		/// so, but assuming seeking works, this means you can immediately use this<br/>
		/// with a different IMG_isTYPE function, or load the image without further<br/>
		/// seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isBMP")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool IsBMP([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src)
		{
			byte ret = IsBMPNative(src);
			return ret != 0;
		}

		/// <summary>
		/// Detect BMP image data on a readable/seekable SDL_IOStream.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_IOStream (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek `src` back to where it started<br/>
		/// when this function was called, but it will not report any errors in doing<br/>
		/// so, but assuming seeking works, this means you can immediately use this<br/>
		/// with a different IMG_isTYPE function, or load the image without further<br/>
		/// seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isBMP")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool IsBMP([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream src)
		{
			fixed (SDLIOStream* psrc = &src)
			{
				byte ret = IsBMPNative((SDLIOStream*)psrc);
				return ret != 0;
			}
		}

		/// <summary>
		/// Detect GIF image data on a readable/seekable SDL_IOStream.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_IOStream (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek `src` back to where it started<br/>
		/// when this function was called, but it will not report any errors in doing<br/>
		/// so, but assuming seeking works, this means you can immediately use this<br/>
		/// with a different IMG_isTYPE function, or load the image without further<br/>
		/// seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isGIF")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsGIFNative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLIOStream*, byte>)funcTable[11])(src);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[11])((nint)src);
			#endif
		}

		/// <summary>
		/// Detect GIF image data on a readable/seekable SDL_IOStream.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_IOStream (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek `src` back to where it started<br/>
		/// when this function was called, but it will not report any errors in doing<br/>
		/// so, but assuming seeking works, this means you can immediately use this<br/>
		/// with a different IMG_isTYPE function, or load the image without further<br/>
		/// seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isGIF")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool IsGIF([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src)
		{
			byte ret = IsGIFNative(src);
			return ret != 0;
		}

		/// <summary>
		/// Detect GIF image data on a readable/seekable SDL_IOStream.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_IOStream (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek `src` back to where it started<br/>
		/// when this function was called, but it will not report any errors in doing<br/>
		/// so, but assuming seeking works, this means you can immediately use this<br/>
		/// with a different IMG_isTYPE function, or load the image without further<br/>
		/// seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isGIF")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool IsGIF([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream src)
		{
			fixed (SDLIOStream* psrc = &src)
			{
				byte ret = IsGIFNative((SDLIOStream*)psrc);
				return ret != 0;
			}
		}

		/// <summary>
		/// Detect JPG image data on a readable/seekable SDL_IOStream.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_IOStream (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek `src` back to where it started<br/>
		/// when this function was called, but it will not report any errors in doing<br/>
		/// so, but assuming seeking works, this means you can immediately use this<br/>
		/// with a different IMG_isTYPE function, or load the image without further<br/>
		/// seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isJPG")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsJPGNative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLIOStream*, byte>)funcTable[12])(src);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[12])((nint)src);
			#endif
		}

		/// <summary>
		/// Detect JPG image data on a readable/seekable SDL_IOStream.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_IOStream (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek `src` back to where it started<br/>
		/// when this function was called, but it will not report any errors in doing<br/>
		/// so, but assuming seeking works, this means you can immediately use this<br/>
		/// with a different IMG_isTYPE function, or load the image without further<br/>
		/// seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isJPG")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool IsJPG([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src)
		{
			byte ret = IsJPGNative(src);
			return ret != 0;
		}

		/// <summary>
		/// Detect JPG image data on a readable/seekable SDL_IOStream.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_IOStream (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek `src` back to where it started<br/>
		/// when this function was called, but it will not report any errors in doing<br/>
		/// so, but assuming seeking works, this means you can immediately use this<br/>
		/// with a different IMG_isTYPE function, or load the image without further<br/>
		/// seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isJPG")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool IsJPG([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream src)
		{
			fixed (SDLIOStream* psrc = &src)
			{
				byte ret = IsJPGNative((SDLIOStream*)psrc);
				return ret != 0;
			}
		}

		/// <summary>
		/// Detect JXL image data on a readable/seekable SDL_IOStream.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_IOStream (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek `src` back to where it started<br/>
		/// when this function was called, but it will not report any errors in doing<br/>
		/// so, but assuming seeking works, this means you can immediately use this<br/>
		/// with a different IMG_isTYPE function, or load the image without further<br/>
		/// seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isJXL")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsJXLNative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLIOStream*, byte>)funcTable[13])(src);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[13])((nint)src);
			#endif
		}

		/// <summary>
		/// Detect JXL image data on a readable/seekable SDL_IOStream.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_IOStream (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek `src` back to where it started<br/>
		/// when this function was called, but it will not report any errors in doing<br/>
		/// so, but assuming seeking works, this means you can immediately use this<br/>
		/// with a different IMG_isTYPE function, or load the image without further<br/>
		/// seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isJXL")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool IsJXL([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src)
		{
			byte ret = IsJXLNative(src);
			return ret != 0;
		}

		/// <summary>
		/// Detect JXL image data on a readable/seekable SDL_IOStream.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_IOStream (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek `src` back to where it started<br/>
		/// when this function was called, but it will not report any errors in doing<br/>
		/// so, but assuming seeking works, this means you can immediately use this<br/>
		/// with a different IMG_isTYPE function, or load the image without further<br/>
		/// seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isJXL")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool IsJXL([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream src)
		{
			fixed (SDLIOStream* psrc = &src)
			{
				byte ret = IsJXLNative((SDLIOStream*)psrc);
				return ret != 0;
			}
		}

		/// <summary>
		/// Detect LBM image data on a readable/seekable SDL_IOStream.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_IOStream (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek `src` back to where it started<br/>
		/// when this function was called, but it will not report any errors in doing<br/>
		/// so, but assuming seeking works, this means you can immediately use this<br/>
		/// with a different IMG_isTYPE function, or load the image without further<br/>
		/// seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isLBM")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsLBMNative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLIOStream*, byte>)funcTable[14])(src);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[14])((nint)src);
			#endif
		}

		/// <summary>
		/// Detect LBM image data on a readable/seekable SDL_IOStream.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_IOStream (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek `src` back to where it started<br/>
		/// when this function was called, but it will not report any errors in doing<br/>
		/// so, but assuming seeking works, this means you can immediately use this<br/>
		/// with a different IMG_isTYPE function, or load the image without further<br/>
		/// seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isLBM")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool IsLBM([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src)
		{
			byte ret = IsLBMNative(src);
			return ret != 0;
		}

		/// <summary>
		/// Detect LBM image data on a readable/seekable SDL_IOStream.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_IOStream (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek `src` back to where it started<br/>
		/// when this function was called, but it will not report any errors in doing<br/>
		/// so, but assuming seeking works, this means you can immediately use this<br/>
		/// with a different IMG_isTYPE function, or load the image without further<br/>
		/// seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isLBM")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool IsLBM([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream src)
		{
			fixed (SDLIOStream* psrc = &src)
			{
				byte ret = IsLBMNative((SDLIOStream*)psrc);
				return ret != 0;
			}
		}

		/// <summary>
		/// Detect PCX image data on a readable/seekable SDL_IOStream.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_IOStream (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek `src` back to where it started<br/>
		/// when this function was called, but it will not report any errors in doing<br/>
		/// so, but assuming seeking works, this means you can immediately use this<br/>
		/// with a different IMG_isTYPE function, or load the image without further<br/>
		/// seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isPCX")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsPCXNative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLIOStream*, byte>)funcTable[15])(src);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[15])((nint)src);
			#endif
		}

		/// <summary>
		/// Detect PCX image data on a readable/seekable SDL_IOStream.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_IOStream (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek `src` back to where it started<br/>
		/// when this function was called, but it will not report any errors in doing<br/>
		/// so, but assuming seeking works, this means you can immediately use this<br/>
		/// with a different IMG_isTYPE function, or load the image without further<br/>
		/// seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isPCX")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool IsPCX([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src)
		{
			byte ret = IsPCXNative(src);
			return ret != 0;
		}

		/// <summary>
		/// Detect PCX image data on a readable/seekable SDL_IOStream.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_IOStream (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek `src` back to where it started<br/>
		/// when this function was called, but it will not report any errors in doing<br/>
		/// so, but assuming seeking works, this means you can immediately use this<br/>
		/// with a different IMG_isTYPE function, or load the image without further<br/>
		/// seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isPCX")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool IsPCX([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream src)
		{
			fixed (SDLIOStream* psrc = &src)
			{
				byte ret = IsPCXNative((SDLIOStream*)psrc);
				return ret != 0;
			}
		}

		/// <summary>
		/// Detect PNG image data on a readable/seekable SDL_IOStream.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_IOStream (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek `src` back to where it started<br/>
		/// when this function was called, but it will not report any errors in doing<br/>
		/// so, but assuming seeking works, this means you can immediately use this<br/>
		/// with a different IMG_isTYPE function, or load the image without further<br/>
		/// seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isPNG")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsPNGNative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLIOStream*, byte>)funcTable[16])(src);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[16])((nint)src);
			#endif
		}

		/// <summary>
		/// Detect PNG image data on a readable/seekable SDL_IOStream.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_IOStream (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek `src` back to where it started<br/>
		/// when this function was called, but it will not report any errors in doing<br/>
		/// so, but assuming seeking works, this means you can immediately use this<br/>
		/// with a different IMG_isTYPE function, or load the image without further<br/>
		/// seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isPNG")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool IsPNG([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src)
		{
			byte ret = IsPNGNative(src);
			return ret != 0;
		}

		/// <summary>
		/// Detect PNG image data on a readable/seekable SDL_IOStream.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_IOStream (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek `src` back to where it started<br/>
		/// when this function was called, but it will not report any errors in doing<br/>
		/// so, but assuming seeking works, this means you can immediately use this<br/>
		/// with a different IMG_isTYPE function, or load the image without further<br/>
		/// seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isPNG")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool IsPNG([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream src)
		{
			fixed (SDLIOStream* psrc = &src)
			{
				byte ret = IsPNGNative((SDLIOStream*)psrc);
				return ret != 0;
			}
		}

		/// <summary>
		/// Detect PNM image data on a readable/seekable SDL_IOStream.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_IOStream (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek `src` back to where it started<br/>
		/// when this function was called, but it will not report any errors in doing<br/>
		/// so, but assuming seeking works, this means you can immediately use this<br/>
		/// with a different IMG_isTYPE function, or load the image without further<br/>
		/// seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isPNM")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsPNMNative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLIOStream*, byte>)funcTable[17])(src);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[17])((nint)src);
			#endif
		}

		/// <summary>
		/// Detect PNM image data on a readable/seekable SDL_IOStream.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_IOStream (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek `src` back to where it started<br/>
		/// when this function was called, but it will not report any errors in doing<br/>
		/// so, but assuming seeking works, this means you can immediately use this<br/>
		/// with a different IMG_isTYPE function, or load the image without further<br/>
		/// seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isPNM")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool IsPNM([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src)
		{
			byte ret = IsPNMNative(src);
			return ret != 0;
		}

		/// <summary>
		/// Detect PNM image data on a readable/seekable SDL_IOStream.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_IOStream (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek `src` back to where it started<br/>
		/// when this function was called, but it will not report any errors in doing<br/>
		/// so, but assuming seeking works, this means you can immediately use this<br/>
		/// with a different IMG_isTYPE function, or load the image without further<br/>
		/// seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isPNM")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool IsPNM([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream src)
		{
			fixed (SDLIOStream* psrc = &src)
			{
				byte ret = IsPNMNative((SDLIOStream*)psrc);
				return ret != 0;
			}
		}

		/// <summary>
		/// Detect SVG image data on a readable/seekable SDL_IOStream.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_IOStream (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek `src` back to where it started<br/>
		/// when this function was called, but it will not report any errors in doing<br/>
		/// so, but assuming seeking works, this means you can immediately use this<br/>
		/// with a different IMG_isTYPE function, or load the image without further<br/>
		/// seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isSVG")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsSVGNative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLIOStream*, byte>)funcTable[18])(src);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[18])((nint)src);
			#endif
		}

		/// <summary>
		/// Detect SVG image data on a readable/seekable SDL_IOStream.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_IOStream (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek `src` back to where it started<br/>
		/// when this function was called, but it will not report any errors in doing<br/>
		/// so, but assuming seeking works, this means you can immediately use this<br/>
		/// with a different IMG_isTYPE function, or load the image without further<br/>
		/// seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isSVG")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool IsSVG([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src)
		{
			byte ret = IsSVGNative(src);
			return ret != 0;
		}

		/// <summary>
		/// Detect SVG image data on a readable/seekable SDL_IOStream.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_IOStream (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek `src` back to where it started<br/>
		/// when this function was called, but it will not report any errors in doing<br/>
		/// so, but assuming seeking works, this means you can immediately use this<br/>
		/// with a different IMG_isTYPE function, or load the image without further<br/>
		/// seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isSVG")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool IsSVG([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream src)
		{
			fixed (SDLIOStream* psrc = &src)
			{
				byte ret = IsSVGNative((SDLIOStream*)psrc);
				return ret != 0;
			}
		}

		/// <summary>
		/// Detect QOI image data on a readable/seekable SDL_IOStream.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_IOStream (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek `src` back to where it started<br/>
		/// when this function was called, but it will not report any errors in doing<br/>
		/// so, but assuming seeking works, this means you can immediately use this<br/>
		/// with a different IMG_isTYPE function, or load the image without further<br/>
		/// seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isQOI")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsQOINative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLIOStream*, byte>)funcTable[19])(src);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[19])((nint)src);
			#endif
		}

		/// <summary>
		/// Detect QOI image data on a readable/seekable SDL_IOStream.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_IOStream (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek `src` back to where it started<br/>
		/// when this function was called, but it will not report any errors in doing<br/>
		/// so, but assuming seeking works, this means you can immediately use this<br/>
		/// with a different IMG_isTYPE function, or load the image without further<br/>
		/// seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isQOI")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool IsQOI([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src)
		{
			byte ret = IsQOINative(src);
			return ret != 0;
		}

		/// <summary>
		/// Detect QOI image data on a readable/seekable SDL_IOStream.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_IOStream (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek `src` back to where it started<br/>
		/// when this function was called, but it will not report any errors in doing<br/>
		/// so, but assuming seeking works, this means you can immediately use this<br/>
		/// with a different IMG_isTYPE function, or load the image without further<br/>
		/// seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isQOI")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool IsQOI([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream src)
		{
			fixed (SDLIOStream* psrc = &src)
			{
				byte ret = IsQOINative((SDLIOStream*)psrc);
				return ret != 0;
			}
		}

		/// <summary>
		/// Detect TIFF image data on a readable/seekable SDL_IOStream.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_IOStream (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek `src` back to where it started<br/>
		/// when this function was called, but it will not report any errors in doing<br/>
		/// so, but assuming seeking works, this means you can immediately use this<br/>
		/// with a different IMG_isTYPE function, or load the image without further<br/>
		/// seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isTIF")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsTIFNative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLIOStream*, byte>)funcTable[20])(src);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[20])((nint)src);
			#endif
		}

		/// <summary>
		/// Detect TIFF image data on a readable/seekable SDL_IOStream.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_IOStream (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek `src` back to where it started<br/>
		/// when this function was called, but it will not report any errors in doing<br/>
		/// so, but assuming seeking works, this means you can immediately use this<br/>
		/// with a different IMG_isTYPE function, or load the image without further<br/>
		/// seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isTIF")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool IsTIF([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src)
		{
			byte ret = IsTIFNative(src);
			return ret != 0;
		}

		/// <summary>
		/// Detect TIFF image data on a readable/seekable SDL_IOStream.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_IOStream (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek `src` back to where it started<br/>
		/// when this function was called, but it will not report any errors in doing<br/>
		/// so, but assuming seeking works, this means you can immediately use this<br/>
		/// with a different IMG_isTYPE function, or load the image without further<br/>
		/// seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isTIF")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool IsTIF([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream src)
		{
			fixed (SDLIOStream* psrc = &src)
			{
				byte ret = IsTIFNative((SDLIOStream*)psrc);
				return ret != 0;
			}
		}

		/// <summary>
		/// Detect XCF image data on a readable/seekable SDL_IOStream.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_IOStream (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek `src` back to where it started<br/>
		/// when this function was called, but it will not report any errors in doing<br/>
		/// so, but assuming seeking works, this means you can immediately use this<br/>
		/// with a different IMG_isTYPE function, or load the image without further<br/>
		/// seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isXCF")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsXCFNative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLIOStream*, byte>)funcTable[21])(src);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[21])((nint)src);
			#endif
		}

		/// <summary>
		/// Detect XCF image data on a readable/seekable SDL_IOStream.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_IOStream (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek `src` back to where it started<br/>
		/// when this function was called, but it will not report any errors in doing<br/>
		/// so, but assuming seeking works, this means you can immediately use this<br/>
		/// with a different IMG_isTYPE function, or load the image without further<br/>
		/// seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isXCF")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool IsXCF([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src)
		{
			byte ret = IsXCFNative(src);
			return ret != 0;
		}

		/// <summary>
		/// Detect XCF image data on a readable/seekable SDL_IOStream.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_IOStream (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek `src` back to where it started<br/>
		/// when this function was called, but it will not report any errors in doing<br/>
		/// so, but assuming seeking works, this means you can immediately use this<br/>
		/// with a different IMG_isTYPE function, or load the image without further<br/>
		/// seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isXCF")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool IsXCF([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream src)
		{
			fixed (SDLIOStream* psrc = &src)
			{
				byte ret = IsXCFNative((SDLIOStream*)psrc);
				return ret != 0;
			}
		}

		/// <summary>
		/// Detect XPM image data on a readable/seekable SDL_IOStream.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_IOStream (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek `src` back to where it started<br/>
		/// when this function was called, but it will not report any errors in doing<br/>
		/// so, but assuming seeking works, this means you can immediately use this<br/>
		/// with a different IMG_isTYPE function, or load the image without further<br/>
		/// seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isXPM")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsXPMNative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLIOStream*, byte>)funcTable[22])(src);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[22])((nint)src);
			#endif
		}

		/// <summary>
		/// Detect XPM image data on a readable/seekable SDL_IOStream.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_IOStream (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek `src` back to where it started<br/>
		/// when this function was called, but it will not report any errors in doing<br/>
		/// so, but assuming seeking works, this means you can immediately use this<br/>
		/// with a different IMG_isTYPE function, or load the image without further<br/>
		/// seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isXPM")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool IsXPM([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src)
		{
			byte ret = IsXPMNative(src);
			return ret != 0;
		}

		/// <summary>
		/// Detect XPM image data on a readable/seekable SDL_IOStream.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_IOStream (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek `src` back to where it started<br/>
		/// when this function was called, but it will not report any errors in doing<br/>
		/// so, but assuming seeking works, this means you can immediately use this<br/>
		/// with a different IMG_isTYPE function, or load the image without further<br/>
		/// seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isXPM")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool IsXPM([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream src)
		{
			fixed (SDLIOStream* psrc = &src)
			{
				byte ret = IsXPMNative((SDLIOStream*)psrc);
				return ret != 0;
			}
		}

		/// <summary>
		/// Detect XV image data on a readable/seekable SDL_IOStream.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_IOStream (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek `src` back to where it started<br/>
		/// when this function was called, but it will not report any errors in doing<br/>
		/// so, but assuming seeking works, this means you can immediately use this<br/>
		/// with a different IMG_isTYPE function, or load the image without further<br/>
		/// seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isXV")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsXVNative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLIOStream*, byte>)funcTable[23])(src);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[23])((nint)src);
			#endif
		}

		/// <summary>
		/// Detect XV image data on a readable/seekable SDL_IOStream.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_IOStream (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek `src` back to where it started<br/>
		/// when this function was called, but it will not report any errors in doing<br/>
		/// so, but assuming seeking works, this means you can immediately use this<br/>
		/// with a different IMG_isTYPE function, or load the image without further<br/>
		/// seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isXV")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool IsXV([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src)
		{
			byte ret = IsXVNative(src);
			return ret != 0;
		}

		/// <summary>
		/// Detect XV image data on a readable/seekable SDL_IOStream.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_IOStream (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek `src` back to where it started<br/>
		/// when this function was called, but it will not report any errors in doing<br/>
		/// so, but assuming seeking works, this means you can immediately use this<br/>
		/// with a different IMG_isTYPE function, or load the image without further<br/>
		/// seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isXV")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool IsXV([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream src)
		{
			fixed (SDLIOStream* psrc = &src)
			{
				byte ret = IsXVNative((SDLIOStream*)psrc);
				return ret != 0;
			}
		}

		/// <summary>
		/// Detect WEBP image data on a readable/seekable SDL_IOStream.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_IOStream (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek `src` back to where it started<br/>
		/// when this function was called, but it will not report any errors in doing<br/>
		/// so, but assuming seeking works, this means you can immediately use this<br/>
		/// with a different IMG_isTYPE function, or load the image without further<br/>
		/// seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isWEBP")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsWEBPNative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLIOStream*, byte>)funcTable[24])(src);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[24])((nint)src);
			#endif
		}

		/// <summary>
		/// Detect WEBP image data on a readable/seekable SDL_IOStream.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_IOStream (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek `src` back to where it started<br/>
		/// when this function was called, but it will not report any errors in doing<br/>
		/// so, but assuming seeking works, this means you can immediately use this<br/>
		/// with a different IMG_isTYPE function, or load the image without further<br/>
		/// seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isWEBP")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool IsWEBP([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src)
		{
			byte ret = IsWEBPNative(src);
			return ret != 0;
		}

		/// <summary>
		/// Detect WEBP image data on a readable/seekable SDL_IOStream.<br/>
		/// This function attempts to determine if a file is a given filetype, reading<br/>
		/// the least amount possible from the SDL_IOStream (usually a few bytes).<br/>
		/// There is no distinction made between "not the filetype in question" and<br/>
		/// basic i/o errors.<br/>
		/// This function will always attempt to seek `src` back to where it started<br/>
		/// when this function was called, but it will not report any errors in doing<br/>
		/// so, but assuming seeking works, this means you can immediately use this<br/>
		/// with a different IMG_isTYPE function, or load the image without further<br/>
		/// seeking.<br/>
		/// You do not need to call this function to load data; SDL_image can work to<br/>
		/// determine file type in many cases in its standard load functions.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_isWEBP")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool IsWEBP([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream src)
		{
			fixed (SDLIOStream* psrc = &src)
			{
				byte ret = IsWEBPNative((SDLIOStream*)psrc);
				return ret != 0;
			}
		}

		/// <summary>
		/// Load a AVIF image directly.<br/>
		/// If you know you definitely have a AVIF image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_IOStream<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadAVIF_IO")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLSurface* LoadAVIFIONative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLIOStream*, SDLSurface*>)funcTable[25])(src);
			#else
			return (SDLSurface*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[25])((nint)src);
			#endif
		}

		/// <summary>
		/// Load a AVIF image directly.<br/>
		/// If you know you definitely have a AVIF image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_IOStream<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadAVIF_IO")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurface* LoadAVIFIO([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src)
		{
			SDLSurface* ret = LoadAVIFIONative(src);
			return ret;
		}

		/// <summary>
		/// Load a AVIF image directly.<br/>
		/// If you know you definitely have a AVIF image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_IOStream<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadAVIF_IO")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurface* LoadAVIFIO([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream src)
		{
			fixed (SDLIOStream* psrc = &src)
			{
				SDLSurface* ret = LoadAVIFIONative((SDLIOStream*)psrc);
				return ret;
			}
		}

		/// <summary>
		/// Load a ICO image directly.<br/>
		/// If you know you definitely have a ICO image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_IOStream<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadICO_IO")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLSurface* LoadICOIONative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLIOStream*, SDLSurface*>)funcTable[26])(src);
			#else
			return (SDLSurface*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[26])((nint)src);
			#endif
		}

		/// <summary>
		/// Load a ICO image directly.<br/>
		/// If you know you definitely have a ICO image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_IOStream<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadICO_IO")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurface* LoadICOIO([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src)
		{
			SDLSurface* ret = LoadICOIONative(src);
			return ret;
		}

		/// <summary>
		/// Load a ICO image directly.<br/>
		/// If you know you definitely have a ICO image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_IOStream<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadICO_IO")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurface* LoadICOIO([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream src)
		{
			fixed (SDLIOStream* psrc = &src)
			{
				SDLSurface* ret = LoadICOIONative((SDLIOStream*)psrc);
				return ret;
			}
		}

		/// <summary>
		/// Load a CUR image directly.<br/>
		/// If you know you definitely have a CUR image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_IOStream<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadCUR_IO")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLSurface* LoadCURIONative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLIOStream*, SDLSurface*>)funcTable[27])(src);
			#else
			return (SDLSurface*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[27])((nint)src);
			#endif
		}

		/// <summary>
		/// Load a CUR image directly.<br/>
		/// If you know you definitely have a CUR image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_IOStream<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadCUR_IO")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurface* LoadCURIO([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src)
		{
			SDLSurface* ret = LoadCURIONative(src);
			return ret;
		}

		/// <summary>
		/// Load a CUR image directly.<br/>
		/// If you know you definitely have a CUR image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_IOStream<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadCUR_IO")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurface* LoadCURIO([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream src)
		{
			fixed (SDLIOStream* psrc = &src)
			{
				SDLSurface* ret = LoadCURIONative((SDLIOStream*)psrc);
				return ret;
			}
		}

		/// <summary>
		/// Load a BMP image directly.<br/>
		/// If you know you definitely have a BMP image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_IOStream<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadBMP_IO")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLSurface* LoadBMPIONative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLIOStream*, SDLSurface*>)funcTable[28])(src);
			#else
			return (SDLSurface*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[28])((nint)src);
			#endif
		}

		/// <summary>
		/// Load a BMP image directly.<br/>
		/// If you know you definitely have a BMP image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_IOStream<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadBMP_IO")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurface* LoadBMPIO([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src)
		{
			SDLSurface* ret = LoadBMPIONative(src);
			return ret;
		}

		/// <summary>
		/// Load a BMP image directly.<br/>
		/// If you know you definitely have a BMP image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_IOStream<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadBMP_IO")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurface* LoadBMPIO([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream src)
		{
			fixed (SDLIOStream* psrc = &src)
			{
				SDLSurface* ret = LoadBMPIONative((SDLIOStream*)psrc);
				return ret;
			}
		}

		/// <summary>
		/// Load a GIF image directly.<br/>
		/// If you know you definitely have a GIF image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_IOStream<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadGIF_IO")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLSurface* LoadGIFIONative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLIOStream*, SDLSurface*>)funcTable[29])(src);
			#else
			return (SDLSurface*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[29])((nint)src);
			#endif
		}

		/// <summary>
		/// Load a GIF image directly.<br/>
		/// If you know you definitely have a GIF image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_IOStream<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadGIF_IO")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurface* LoadGIFIO([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src)
		{
			SDLSurface* ret = LoadGIFIONative(src);
			return ret;
		}

		/// <summary>
		/// Load a GIF image directly.<br/>
		/// If you know you definitely have a GIF image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_IOStream<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadGIF_IO")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurface* LoadGIFIO([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream src)
		{
			fixed (SDLIOStream* psrc = &src)
			{
				SDLSurface* ret = LoadGIFIONative((SDLIOStream*)psrc);
				return ret;
			}
		}

		/// <summary>
		/// Load a JPG image directly.<br/>
		/// If you know you definitely have a JPG image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_IOStream<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadJPG_IO")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLSurface* LoadJPGIONative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLIOStream*, SDLSurface*>)funcTable[30])(src);
			#else
			return (SDLSurface*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[30])((nint)src);
			#endif
		}

		/// <summary>
		/// Load a JPG image directly.<br/>
		/// If you know you definitely have a JPG image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_IOStream<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadJPG_IO")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurface* LoadJPGIO([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src)
		{
			SDLSurface* ret = LoadJPGIONative(src);
			return ret;
		}

		/// <summary>
		/// Load a JPG image directly.<br/>
		/// If you know you definitely have a JPG image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_IOStream<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadJPG_IO")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurface* LoadJPGIO([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream src)
		{
			fixed (SDLIOStream* psrc = &src)
			{
				SDLSurface* ret = LoadJPGIONative((SDLIOStream*)psrc);
				return ret;
			}
		}

		/// <summary>
		/// Load a JXL image directly.<br/>
		/// If you know you definitely have a JXL image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_IOStream<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadJXL_IO")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLSurface* LoadJXLIONative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLIOStream*, SDLSurface*>)funcTable[31])(src);
			#else
			return (SDLSurface*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[31])((nint)src);
			#endif
		}

		/// <summary>
		/// Load a JXL image directly.<br/>
		/// If you know you definitely have a JXL image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_IOStream<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadJXL_IO")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurface* LoadJXLIO([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src)
		{
			SDLSurface* ret = LoadJXLIONative(src);
			return ret;
		}

		/// <summary>
		/// Load a JXL image directly.<br/>
		/// If you know you definitely have a JXL image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_IOStream<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadJXL_IO")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurface* LoadJXLIO([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream src)
		{
			fixed (SDLIOStream* psrc = &src)
			{
				SDLSurface* ret = LoadJXLIONative((SDLIOStream*)psrc);
				return ret;
			}
		}

		/// <summary>
		/// Load a LBM image directly.<br/>
		/// If you know you definitely have a LBM image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_IOStream<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadLBM_IO")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLSurface* LoadLBMIONative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLIOStream*, SDLSurface*>)funcTable[32])(src);
			#else
			return (SDLSurface*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[32])((nint)src);
			#endif
		}

		/// <summary>
		/// Load a LBM image directly.<br/>
		/// If you know you definitely have a LBM image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_IOStream<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadLBM_IO")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurface* LoadLBMIO([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src)
		{
			SDLSurface* ret = LoadLBMIONative(src);
			return ret;
		}

		/// <summary>
		/// Load a LBM image directly.<br/>
		/// If you know you definitely have a LBM image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_IOStream<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadLBM_IO")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurface* LoadLBMIO([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream src)
		{
			fixed (SDLIOStream* psrc = &src)
			{
				SDLSurface* ret = LoadLBMIONative((SDLIOStream*)psrc);
				return ret;
			}
		}

		/// <summary>
		/// Load a PCX image directly.<br/>
		/// If you know you definitely have a PCX image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_IOStream<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadPCX_IO")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLSurface* LoadPCXIONative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLIOStream*, SDLSurface*>)funcTable[33])(src);
			#else
			return (SDLSurface*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[33])((nint)src);
			#endif
		}

		/// <summary>
		/// Load a PCX image directly.<br/>
		/// If you know you definitely have a PCX image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_IOStream<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadPCX_IO")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurface* LoadPCXIO([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src)
		{
			SDLSurface* ret = LoadPCXIONative(src);
			return ret;
		}

		/// <summary>
		/// Load a PCX image directly.<br/>
		/// If you know you definitely have a PCX image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_IOStream<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadPCX_IO")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurface* LoadPCXIO([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream src)
		{
			fixed (SDLIOStream* psrc = &src)
			{
				SDLSurface* ret = LoadPCXIONative((SDLIOStream*)psrc);
				return ret;
			}
		}

		/// <summary>
		/// Load a PNG image directly.<br/>
		/// If you know you definitely have a PNG image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_IOStream<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadPNG_IO")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLSurface* LoadPNGIONative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLIOStream*, SDLSurface*>)funcTable[34])(src);
			#else
			return (SDLSurface*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[34])((nint)src);
			#endif
		}

		/// <summary>
		/// Load a PNG image directly.<br/>
		/// If you know you definitely have a PNG image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_IOStream<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadPNG_IO")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurface* LoadPNGIO([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src)
		{
			SDLSurface* ret = LoadPNGIONative(src);
			return ret;
		}

		/// <summary>
		/// Load a PNG image directly.<br/>
		/// If you know you definitely have a PNG image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_IOStream<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadPNG_IO")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurface* LoadPNGIO([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream src)
		{
			fixed (SDLIOStream* psrc = &src)
			{
				SDLSurface* ret = LoadPNGIONative((SDLIOStream*)psrc);
				return ret;
			}
		}

		/// <summary>
		/// Load a PNM image directly.<br/>
		/// If you know you definitely have a PNM image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_IOStream<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadPNM_IO")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLSurface* LoadPNMIONative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLIOStream*, SDLSurface*>)funcTable[35])(src);
			#else
			return (SDLSurface*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[35])((nint)src);
			#endif
		}

		/// <summary>
		/// Load a PNM image directly.<br/>
		/// If you know you definitely have a PNM image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_IOStream<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadPNM_IO")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurface* LoadPNMIO([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src)
		{
			SDLSurface* ret = LoadPNMIONative(src);
			return ret;
		}

		/// <summary>
		/// Load a PNM image directly.<br/>
		/// If you know you definitely have a PNM image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_IOStream<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadPNM_IO")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurface* LoadPNMIO([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream src)
		{
			fixed (SDLIOStream* psrc = &src)
			{
				SDLSurface* ret = LoadPNMIONative((SDLIOStream*)psrc);
				return ret;
			}
		}

		/// <summary>
		/// Load a SVG image directly.<br/>
		/// If you know you definitely have a SVG image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_IOStream<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadSVG_IO")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLSurface* LoadSVGIONative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLIOStream*, SDLSurface*>)funcTable[36])(src);
			#else
			return (SDLSurface*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[36])((nint)src);
			#endif
		}

		/// <summary>
		/// Load a SVG image directly.<br/>
		/// If you know you definitely have a SVG image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_IOStream<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadSVG_IO")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurface* LoadSVGIO([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src)
		{
			SDLSurface* ret = LoadSVGIONative(src);
			return ret;
		}

		/// <summary>
		/// Load a SVG image directly.<br/>
		/// If you know you definitely have a SVG image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_IOStream<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadSVG_IO")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurface* LoadSVGIO([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream src)
		{
			fixed (SDLIOStream* psrc = &src)
			{
				SDLSurface* ret = LoadSVGIONative((SDLIOStream*)psrc);
				return ret;
			}
		}

		/// <summary>
		/// Load a QOI image directly.<br/>
		/// If you know you definitely have a QOI image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_IOStream<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadQOI_IO")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLSurface* LoadQOIIONative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLIOStream*, SDLSurface*>)funcTable[37])(src);
			#else
			return (SDLSurface*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[37])((nint)src);
			#endif
		}

		/// <summary>
		/// Load a QOI image directly.<br/>
		/// If you know you definitely have a QOI image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_IOStream<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadQOI_IO")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurface* LoadQOIIO([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src)
		{
			SDLSurface* ret = LoadQOIIONative(src);
			return ret;
		}

		/// <summary>
		/// Load a QOI image directly.<br/>
		/// If you know you definitely have a QOI image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_IOStream<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadQOI_IO")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurface* LoadQOIIO([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream src)
		{
			fixed (SDLIOStream* psrc = &src)
			{
				SDLSurface* ret = LoadQOIIONative((SDLIOStream*)psrc);
				return ret;
			}
		}

		/// <summary>
		/// Load a TGA image directly.<br/>
		/// If you know you definitely have a TGA image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_IOStream<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadTGA_IO")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLSurface* LoadTGAIONative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLIOStream*, SDLSurface*>)funcTable[38])(src);
			#else
			return (SDLSurface*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[38])((nint)src);
			#endif
		}

		/// <summary>
		/// Load a TGA image directly.<br/>
		/// If you know you definitely have a TGA image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_IOStream<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadTGA_IO")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurface* LoadTGAIO([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src)
		{
			SDLSurface* ret = LoadTGAIONative(src);
			return ret;
		}

		/// <summary>
		/// Load a TGA image directly.<br/>
		/// If you know you definitely have a TGA image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_IOStream<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadTGA_IO")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurface* LoadTGAIO([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream src)
		{
			fixed (SDLIOStream* psrc = &src)
			{
				SDLSurface* ret = LoadTGAIONative((SDLIOStream*)psrc);
				return ret;
			}
		}

		/// <summary>
		/// Load a TIFF image directly.<br/>
		/// If you know you definitely have a TIFF image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_IOStream<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadTIF_IO")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLSurface* LoadTIFIONative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLIOStream*, SDLSurface*>)funcTable[39])(src);
			#else
			return (SDLSurface*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[39])((nint)src);
			#endif
		}

		/// <summary>
		/// Load a TIFF image directly.<br/>
		/// If you know you definitely have a TIFF image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_IOStream<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadTIF_IO")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurface* LoadTIFIO([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src)
		{
			SDLSurface* ret = LoadTIFIONative(src);
			return ret;
		}

		/// <summary>
		/// Load a TIFF image directly.<br/>
		/// If you know you definitely have a TIFF image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_IOStream<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadTIF_IO")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurface* LoadTIFIO([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream src)
		{
			fixed (SDLIOStream* psrc = &src)
			{
				SDLSurface* ret = LoadTIFIONative((SDLIOStream*)psrc);
				return ret;
			}
		}

		/// <summary>
		/// Load a XCF image directly.<br/>
		/// If you know you definitely have a XCF image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_IOStream<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadXCF_IO")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLSurface* LoadXCFIONative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLIOStream*, SDLSurface*>)funcTable[40])(src);
			#else
			return (SDLSurface*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[40])((nint)src);
			#endif
		}

		/// <summary>
		/// Load a XCF image directly.<br/>
		/// If you know you definitely have a XCF image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_IOStream<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadXCF_IO")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurface* LoadXCFIO([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src)
		{
			SDLSurface* ret = LoadXCFIONative(src);
			return ret;
		}

		/// <summary>
		/// Load a XCF image directly.<br/>
		/// If you know you definitely have a XCF image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_IOStream<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadXCF_IO")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurface* LoadXCFIO([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream src)
		{
			fixed (SDLIOStream* psrc = &src)
			{
				SDLSurface* ret = LoadXCFIONative((SDLIOStream*)psrc);
				return ret;
			}
		}

		/// <summary>
		/// Load a XPM image directly.<br/>
		/// If you know you definitely have a XPM image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_IOStream<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadXPM_IO")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLSurface* LoadXPMIONative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLIOStream*, SDLSurface*>)funcTable[41])(src);
			#else
			return (SDLSurface*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[41])((nint)src);
			#endif
		}

		/// <summary>
		/// Load a XPM image directly.<br/>
		/// If you know you definitely have a XPM image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_IOStream<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadXPM_IO")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurface* LoadXPMIO([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src)
		{
			SDLSurface* ret = LoadXPMIONative(src);
			return ret;
		}

		/// <summary>
		/// Load a XPM image directly.<br/>
		/// If you know you definitely have a XPM image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_IOStream<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadXPM_IO")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurface* LoadXPMIO([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream src)
		{
			fixed (SDLIOStream* psrc = &src)
			{
				SDLSurface* ret = LoadXPMIONative((SDLIOStream*)psrc);
				return ret;
			}
		}

		/// <summary>
		/// Load a XV image directly.<br/>
		/// If you know you definitely have a XV image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_IOStream<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadXV_IO")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLSurface* LoadXVIONative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLIOStream*, SDLSurface*>)funcTable[42])(src);
			#else
			return (SDLSurface*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[42])((nint)src);
			#endif
		}

		/// <summary>
		/// Load a XV image directly.<br/>
		/// If you know you definitely have a XV image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_IOStream<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadXV_IO")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurface* LoadXVIO([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src)
		{
			SDLSurface* ret = LoadXVIONative(src);
			return ret;
		}

		/// <summary>
		/// Load a XV image directly.<br/>
		/// If you know you definitely have a XV image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_IOStream<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadXV_IO")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurface* LoadXVIO([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream src)
		{
			fixed (SDLIOStream* psrc = &src)
			{
				SDLSurface* ret = LoadXVIONative((SDLIOStream*)psrc);
				return ret;
			}
		}

		/// <summary>
		/// Load a WEBP image directly.<br/>
		/// If you know you definitely have a WEBP image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_IOStream<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadWEBP_IO")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLSurface* LoadWEBPIONative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLIOStream*, SDLSurface*>)funcTable[43])(src);
			#else
			return (SDLSurface*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[43])((nint)src);
			#endif
		}

		/// <summary>
		/// Load a WEBP image directly.<br/>
		/// If you know you definitely have a WEBP image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_IOStream<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadWEBP_IO")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurface* LoadWEBPIO([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src)
		{
			SDLSurface* ret = LoadWEBPIONative(src);
			return ret;
		}

		/// <summary>
		/// Load a WEBP image directly.<br/>
		/// If you know you definitely have a WEBP image, you can call this function,<br/>
		/// which will skip SDL_image's file format detection routines. Generally it's<br/>
		/// better to use the abstract interfaces; also, there is only an SDL_IOStream<br/>
		/// interface available here.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadWEBP_IO")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurface* LoadWEBPIO([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] ref SDLIOStream src)
		{
			fixed (SDLIOStream* psrc = &src)
			{
				SDLSurface* ret = LoadWEBPIONative((SDLIOStream*)psrc);
				return ret;
			}
		}

		/// <summary>
		/// Load an SVG image, scaled to a specific size.<br/>
		/// Since SVG files are resolution-independent, you specify the size you would<br/>
		/// like the output image to be and it will be generated at those dimensions.<br/>
		/// Either width or height may be 0 and the image will be auto-sized to<br/>
		/// preserve aspect ratio.<br/>
		/// When done with the returned surface, the app should dispose of it with a<br/>
		/// call to SDL_DestroySurface().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadSizedSVG_IO")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static SDLSurface* LoadSizedSVGIONative([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src, [NativeName(NativeNameType.Param, "width")] [NativeName(NativeNameType.Type, "int")] int width, [NativeName(NativeNameType.Param, "height")] [NativeName(NativeNameType.Type, "int")] int height)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<SDLIOStream*, int, int, SDLSurface*>)funcTable[44])(src, width, height);
			#else
			return (SDLSurface*)((delegate* unmanaged[Cdecl]<nint, int, int, nint>)funcTable[44])((nint)src, width, height);
			#endif
		}

		/// <summary>
		/// Load an SVG image, scaled to a specific size.<br/>
		/// Since SVG files are resolution-independent, you specify the size you would<br/>
		/// like the output image to be and it will be generated at those dimensions.<br/>
		/// Either width or height may be 0 and the image will be auto-sized to<br/>
		/// preserve aspect ratio.<br/>
		/// When done with the returned surface, the app should dispose of it with a<br/>
		/// call to SDL_DestroySurface().<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "IMG_LoadSizedSVG_IO")]
		[return: NativeName(NativeNameType.Type, "SDL_Surface *")]
		public static SDLSurface* LoadSizedSVGIO([NativeName(NativeNameType.Param, "src")] [NativeName(NativeNameType.Type, "SDL_IOStream *")] SDLIOStream* src, [NativeName(NativeNameType.Param, "width")] [NativeName(NativeNameType.Type, "int")] int width, [NativeName(NativeNameType.Param, "height")] [NativeName(NativeNameType.Type, "int")] int height)
		{
			SDLSurface* ret = LoadSizedSVGIONative(src, width, height);
			return ret;
		}
	}
}
